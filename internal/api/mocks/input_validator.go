// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package mocks

//go:generate minimock -i HomeWork_1/internal/api.InputValidator -o input_validator.go -n InputValidator -p mocks

import (
	"HomeWork_1/internal/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// InputValidator implements api.InputValidator
type InputValidator struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcValidateGetOrderFromCourier          func(orderID string, clientID string, date string, pack string, price int, weight int) (op1 *model.Order, err error)
	inspectFuncValidateGetOrderFromCourier   func(orderID string, clientID string, date string, pack string, price int, weight int)
	afterValidateGetOrderFromCourierCounter  uint64
	beforeValidateGetOrderFromCourierCounter uint64
	ValidateGetOrderFromCourierMock          mInputValidatorValidateGetOrderFromCourier

	funcValidateGiveOrder          func(orders string, pack string, loadedPackages []model.Package) (oa1 []model.OrderID, pp1 *model.PackageType, err error)
	inspectFuncValidateGiveOrder   func(orders string, pack string, loadedPackages []model.Package)
	afterValidateGiveOrderCounter  uint64
	beforeValidateGiveOrderCounter uint64
	ValidateGiveOrderMock          mInputValidatorValidateGiveOrder

	funcValidateListOrders          func(clientID string, action string) (c1 model.ClientID, err error)
	inspectFuncValidateListOrders   func(clientID string, action string)
	afterValidateListOrdersCounter  uint64
	beforeValidateListOrdersCounter uint64
	ValidateListOrdersMock          mInputValidatorValidateListOrders

	funcValidateListReturns          func(pageSize int, pageNumber int) (i1 int, i2 int, err error)
	inspectFuncValidateListReturns   func(pageSize int, pageNumber int)
	afterValidateListReturnsCounter  uint64
	beforeValidateListReturnsCounter uint64
	ValidateListReturnsMock          mInputValidatorValidateListReturns

	funcValidatePackage          func(weight int, pack model.PackageType, loadedPackages []model.Package) (err error)
	inspectFuncValidatePackage   func(weight int, pack model.PackageType, loadedPackages []model.Package)
	afterValidatePackageCounter  uint64
	beforeValidatePackageCounter uint64
	ValidatePackageMock          mInputValidatorValidatePackage

	funcValidateReturnFromClient          func(orderID string, clientID string) (o1 model.OrderID, c1 model.ClientID, err error)
	inspectFuncValidateReturnFromClient   func(orderID string, clientID string)
	afterValidateReturnFromClientCounter  uint64
	beforeValidateReturnFromClientCounter uint64
	ValidateReturnFromClientMock          mInputValidatorValidateReturnFromClient

	funcValidateReturnOrder          func(orderID string) (o1 model.OrderID, err error)
	inspectFuncValidateReturnOrder   func(orderID string)
	afterValidateReturnOrderCounter  uint64
	beforeValidateReturnOrderCounter uint64
	ValidateReturnOrderMock          mInputValidatorValidateReturnOrder
}

// NewInputValidator returns a mock for api.InputValidator
func NewInputValidator(t minimock.Tester) *InputValidator {
	m := &InputValidator{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ValidateGetOrderFromCourierMock = mInputValidatorValidateGetOrderFromCourier{mock: m}
	m.ValidateGetOrderFromCourierMock.callArgs = []*InputValidatorValidateGetOrderFromCourierParams{}

	m.ValidateGiveOrderMock = mInputValidatorValidateGiveOrder{mock: m}
	m.ValidateGiveOrderMock.callArgs = []*InputValidatorValidateGiveOrderParams{}

	m.ValidateListOrdersMock = mInputValidatorValidateListOrders{mock: m}
	m.ValidateListOrdersMock.callArgs = []*InputValidatorValidateListOrdersParams{}

	m.ValidateListReturnsMock = mInputValidatorValidateListReturns{mock: m}
	m.ValidateListReturnsMock.callArgs = []*InputValidatorValidateListReturnsParams{}

	m.ValidatePackageMock = mInputValidatorValidatePackage{mock: m}
	m.ValidatePackageMock.callArgs = []*InputValidatorValidatePackageParams{}

	m.ValidateReturnFromClientMock = mInputValidatorValidateReturnFromClient{mock: m}
	m.ValidateReturnFromClientMock.callArgs = []*InputValidatorValidateReturnFromClientParams{}

	m.ValidateReturnOrderMock = mInputValidatorValidateReturnOrder{mock: m}
	m.ValidateReturnOrderMock.callArgs = []*InputValidatorValidateReturnOrderParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mInputValidatorValidateGetOrderFromCourier struct {
	optional           bool
	mock               *InputValidator
	defaultExpectation *InputValidatorValidateGetOrderFromCourierExpectation
	expectations       []*InputValidatorValidateGetOrderFromCourierExpectation

	callArgs []*InputValidatorValidateGetOrderFromCourierParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// InputValidatorValidateGetOrderFromCourierExpectation specifies expectation struct of the InputValidator.ValidateGetOrderFromCourier
type InputValidatorValidateGetOrderFromCourierExpectation struct {
	mock      *InputValidator
	params    *InputValidatorValidateGetOrderFromCourierParams
	paramPtrs *InputValidatorValidateGetOrderFromCourierParamPtrs
	results   *InputValidatorValidateGetOrderFromCourierResults
	Counter   uint64
}

// InputValidatorValidateGetOrderFromCourierParams contains parameters of the InputValidator.ValidateGetOrderFromCourier
type InputValidatorValidateGetOrderFromCourierParams struct {
	orderID  string
	clientID string
	date     string
	pack     string
	price    int
	weight   int
}

// InputValidatorValidateGetOrderFromCourierParamPtrs contains pointers to parameters of the InputValidator.ValidateGetOrderFromCourier
type InputValidatorValidateGetOrderFromCourierParamPtrs struct {
	orderID  *string
	clientID *string
	date     *string
	pack     *string
	price    *int
	weight   *int
}

// InputValidatorValidateGetOrderFromCourierResults contains results of the InputValidator.ValidateGetOrderFromCourier
type InputValidatorValidateGetOrderFromCourierResults struct {
	op1 *model.Order
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidateGetOrderFromCourier *mInputValidatorValidateGetOrderFromCourier) Optional() *mInputValidatorValidateGetOrderFromCourier {
	mmValidateGetOrderFromCourier.optional = true
	return mmValidateGetOrderFromCourier
}

// Expect sets up expected params for InputValidator.ValidateGetOrderFromCourier
func (mmValidateGetOrderFromCourier *mInputValidatorValidateGetOrderFromCourier) Expect(orderID string, clientID string, date string, pack string, price int, weight int) *mInputValidatorValidateGetOrderFromCourier {
	if mmValidateGetOrderFromCourier.mock.funcValidateGetOrderFromCourier != nil {
		mmValidateGetOrderFromCourier.mock.t.Fatalf("InputValidator.ValidateGetOrderFromCourier mock is already set by Set")
	}

	if mmValidateGetOrderFromCourier.defaultExpectation == nil {
		mmValidateGetOrderFromCourier.defaultExpectation = &InputValidatorValidateGetOrderFromCourierExpectation{}
	}

	if mmValidateGetOrderFromCourier.defaultExpectation.paramPtrs != nil {
		mmValidateGetOrderFromCourier.mock.t.Fatalf("InputValidator.ValidateGetOrderFromCourier mock is already set by ExpectParams functions")
	}

	mmValidateGetOrderFromCourier.defaultExpectation.params = &InputValidatorValidateGetOrderFromCourierParams{orderID, clientID, date, pack, price, weight}
	for _, e := range mmValidateGetOrderFromCourier.expectations {
		if minimock.Equal(e.params, mmValidateGetOrderFromCourier.defaultExpectation.params) {
			mmValidateGetOrderFromCourier.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidateGetOrderFromCourier.defaultExpectation.params)
		}
	}

	return mmValidateGetOrderFromCourier
}

// ExpectOrderIDParam1 sets up expected param orderID for InputValidator.ValidateGetOrderFromCourier
func (mmValidateGetOrderFromCourier *mInputValidatorValidateGetOrderFromCourier) ExpectOrderIDParam1(orderID string) *mInputValidatorValidateGetOrderFromCourier {
	if mmValidateGetOrderFromCourier.mock.funcValidateGetOrderFromCourier != nil {
		mmValidateGetOrderFromCourier.mock.t.Fatalf("InputValidator.ValidateGetOrderFromCourier mock is already set by Set")
	}

	if mmValidateGetOrderFromCourier.defaultExpectation == nil {
		mmValidateGetOrderFromCourier.defaultExpectation = &InputValidatorValidateGetOrderFromCourierExpectation{}
	}

	if mmValidateGetOrderFromCourier.defaultExpectation.params != nil {
		mmValidateGetOrderFromCourier.mock.t.Fatalf("InputValidator.ValidateGetOrderFromCourier mock is already set by Expect")
	}

	if mmValidateGetOrderFromCourier.defaultExpectation.paramPtrs == nil {
		mmValidateGetOrderFromCourier.defaultExpectation.paramPtrs = &InputValidatorValidateGetOrderFromCourierParamPtrs{}
	}
	mmValidateGetOrderFromCourier.defaultExpectation.paramPtrs.orderID = &orderID

	return mmValidateGetOrderFromCourier
}

// ExpectClientIDParam2 sets up expected param clientID for InputValidator.ValidateGetOrderFromCourier
func (mmValidateGetOrderFromCourier *mInputValidatorValidateGetOrderFromCourier) ExpectClientIDParam2(clientID string) *mInputValidatorValidateGetOrderFromCourier {
	if mmValidateGetOrderFromCourier.mock.funcValidateGetOrderFromCourier != nil {
		mmValidateGetOrderFromCourier.mock.t.Fatalf("InputValidator.ValidateGetOrderFromCourier mock is already set by Set")
	}

	if mmValidateGetOrderFromCourier.defaultExpectation == nil {
		mmValidateGetOrderFromCourier.defaultExpectation = &InputValidatorValidateGetOrderFromCourierExpectation{}
	}

	if mmValidateGetOrderFromCourier.defaultExpectation.params != nil {
		mmValidateGetOrderFromCourier.mock.t.Fatalf("InputValidator.ValidateGetOrderFromCourier mock is already set by Expect")
	}

	if mmValidateGetOrderFromCourier.defaultExpectation.paramPtrs == nil {
		mmValidateGetOrderFromCourier.defaultExpectation.paramPtrs = &InputValidatorValidateGetOrderFromCourierParamPtrs{}
	}
	mmValidateGetOrderFromCourier.defaultExpectation.paramPtrs.clientID = &clientID

	return mmValidateGetOrderFromCourier
}

// ExpectDateParam3 sets up expected param date for InputValidator.ValidateGetOrderFromCourier
func (mmValidateGetOrderFromCourier *mInputValidatorValidateGetOrderFromCourier) ExpectDateParam3(date string) *mInputValidatorValidateGetOrderFromCourier {
	if mmValidateGetOrderFromCourier.mock.funcValidateGetOrderFromCourier != nil {
		mmValidateGetOrderFromCourier.mock.t.Fatalf("InputValidator.ValidateGetOrderFromCourier mock is already set by Set")
	}

	if mmValidateGetOrderFromCourier.defaultExpectation == nil {
		mmValidateGetOrderFromCourier.defaultExpectation = &InputValidatorValidateGetOrderFromCourierExpectation{}
	}

	if mmValidateGetOrderFromCourier.defaultExpectation.params != nil {
		mmValidateGetOrderFromCourier.mock.t.Fatalf("InputValidator.ValidateGetOrderFromCourier mock is already set by Expect")
	}

	if mmValidateGetOrderFromCourier.defaultExpectation.paramPtrs == nil {
		mmValidateGetOrderFromCourier.defaultExpectation.paramPtrs = &InputValidatorValidateGetOrderFromCourierParamPtrs{}
	}
	mmValidateGetOrderFromCourier.defaultExpectation.paramPtrs.date = &date

	return mmValidateGetOrderFromCourier
}

// ExpectPackParam4 sets up expected param pack for InputValidator.ValidateGetOrderFromCourier
func (mmValidateGetOrderFromCourier *mInputValidatorValidateGetOrderFromCourier) ExpectPackParam4(pack string) *mInputValidatorValidateGetOrderFromCourier {
	if mmValidateGetOrderFromCourier.mock.funcValidateGetOrderFromCourier != nil {
		mmValidateGetOrderFromCourier.mock.t.Fatalf("InputValidator.ValidateGetOrderFromCourier mock is already set by Set")
	}

	if mmValidateGetOrderFromCourier.defaultExpectation == nil {
		mmValidateGetOrderFromCourier.defaultExpectation = &InputValidatorValidateGetOrderFromCourierExpectation{}
	}

	if mmValidateGetOrderFromCourier.defaultExpectation.params != nil {
		mmValidateGetOrderFromCourier.mock.t.Fatalf("InputValidator.ValidateGetOrderFromCourier mock is already set by Expect")
	}

	if mmValidateGetOrderFromCourier.defaultExpectation.paramPtrs == nil {
		mmValidateGetOrderFromCourier.defaultExpectation.paramPtrs = &InputValidatorValidateGetOrderFromCourierParamPtrs{}
	}
	mmValidateGetOrderFromCourier.defaultExpectation.paramPtrs.pack = &pack

	return mmValidateGetOrderFromCourier
}

// ExpectPriceParam5 sets up expected param price for InputValidator.ValidateGetOrderFromCourier
func (mmValidateGetOrderFromCourier *mInputValidatorValidateGetOrderFromCourier) ExpectPriceParam5(price int) *mInputValidatorValidateGetOrderFromCourier {
	if mmValidateGetOrderFromCourier.mock.funcValidateGetOrderFromCourier != nil {
		mmValidateGetOrderFromCourier.mock.t.Fatalf("InputValidator.ValidateGetOrderFromCourier mock is already set by Set")
	}

	if mmValidateGetOrderFromCourier.defaultExpectation == nil {
		mmValidateGetOrderFromCourier.defaultExpectation = &InputValidatorValidateGetOrderFromCourierExpectation{}
	}

	if mmValidateGetOrderFromCourier.defaultExpectation.params != nil {
		mmValidateGetOrderFromCourier.mock.t.Fatalf("InputValidator.ValidateGetOrderFromCourier mock is already set by Expect")
	}

	if mmValidateGetOrderFromCourier.defaultExpectation.paramPtrs == nil {
		mmValidateGetOrderFromCourier.defaultExpectation.paramPtrs = &InputValidatorValidateGetOrderFromCourierParamPtrs{}
	}
	mmValidateGetOrderFromCourier.defaultExpectation.paramPtrs.price = &price

	return mmValidateGetOrderFromCourier
}

// ExpectWeightParam6 sets up expected param weight for InputValidator.ValidateGetOrderFromCourier
func (mmValidateGetOrderFromCourier *mInputValidatorValidateGetOrderFromCourier) ExpectWeightParam6(weight int) *mInputValidatorValidateGetOrderFromCourier {
	if mmValidateGetOrderFromCourier.mock.funcValidateGetOrderFromCourier != nil {
		mmValidateGetOrderFromCourier.mock.t.Fatalf("InputValidator.ValidateGetOrderFromCourier mock is already set by Set")
	}

	if mmValidateGetOrderFromCourier.defaultExpectation == nil {
		mmValidateGetOrderFromCourier.defaultExpectation = &InputValidatorValidateGetOrderFromCourierExpectation{}
	}

	if mmValidateGetOrderFromCourier.defaultExpectation.params != nil {
		mmValidateGetOrderFromCourier.mock.t.Fatalf("InputValidator.ValidateGetOrderFromCourier mock is already set by Expect")
	}

	if mmValidateGetOrderFromCourier.defaultExpectation.paramPtrs == nil {
		mmValidateGetOrderFromCourier.defaultExpectation.paramPtrs = &InputValidatorValidateGetOrderFromCourierParamPtrs{}
	}
	mmValidateGetOrderFromCourier.defaultExpectation.paramPtrs.weight = &weight

	return mmValidateGetOrderFromCourier
}

// Inspect accepts an inspector function that has same arguments as the InputValidator.ValidateGetOrderFromCourier
func (mmValidateGetOrderFromCourier *mInputValidatorValidateGetOrderFromCourier) Inspect(f func(orderID string, clientID string, date string, pack string, price int, weight int)) *mInputValidatorValidateGetOrderFromCourier {
	if mmValidateGetOrderFromCourier.mock.inspectFuncValidateGetOrderFromCourier != nil {
		mmValidateGetOrderFromCourier.mock.t.Fatalf("Inspect function is already set for InputValidator.ValidateGetOrderFromCourier")
	}

	mmValidateGetOrderFromCourier.mock.inspectFuncValidateGetOrderFromCourier = f

	return mmValidateGetOrderFromCourier
}

// Return sets up results that will be returned by InputValidator.ValidateGetOrderFromCourier
func (mmValidateGetOrderFromCourier *mInputValidatorValidateGetOrderFromCourier) Return(op1 *model.Order, err error) *InputValidator {
	if mmValidateGetOrderFromCourier.mock.funcValidateGetOrderFromCourier != nil {
		mmValidateGetOrderFromCourier.mock.t.Fatalf("InputValidator.ValidateGetOrderFromCourier mock is already set by Set")
	}

	if mmValidateGetOrderFromCourier.defaultExpectation == nil {
		mmValidateGetOrderFromCourier.defaultExpectation = &InputValidatorValidateGetOrderFromCourierExpectation{mock: mmValidateGetOrderFromCourier.mock}
	}
	mmValidateGetOrderFromCourier.defaultExpectation.results = &InputValidatorValidateGetOrderFromCourierResults{op1, err}
	return mmValidateGetOrderFromCourier.mock
}

// Set uses given function f to mock the InputValidator.ValidateGetOrderFromCourier method
func (mmValidateGetOrderFromCourier *mInputValidatorValidateGetOrderFromCourier) Set(f func(orderID string, clientID string, date string, pack string, price int, weight int) (op1 *model.Order, err error)) *InputValidator {
	if mmValidateGetOrderFromCourier.defaultExpectation != nil {
		mmValidateGetOrderFromCourier.mock.t.Fatalf("Default expectation is already set for the InputValidator.ValidateGetOrderFromCourier method")
	}

	if len(mmValidateGetOrderFromCourier.expectations) > 0 {
		mmValidateGetOrderFromCourier.mock.t.Fatalf("Some expectations are already set for the InputValidator.ValidateGetOrderFromCourier method")
	}

	mmValidateGetOrderFromCourier.mock.funcValidateGetOrderFromCourier = f
	return mmValidateGetOrderFromCourier.mock
}

// When sets expectation for the InputValidator.ValidateGetOrderFromCourier which will trigger the result defined by the following
// Then helper
func (mmValidateGetOrderFromCourier *mInputValidatorValidateGetOrderFromCourier) When(orderID string, clientID string, date string, pack string, price int, weight int) *InputValidatorValidateGetOrderFromCourierExpectation {
	if mmValidateGetOrderFromCourier.mock.funcValidateGetOrderFromCourier != nil {
		mmValidateGetOrderFromCourier.mock.t.Fatalf("InputValidator.ValidateGetOrderFromCourier mock is already set by Set")
	}

	expectation := &InputValidatorValidateGetOrderFromCourierExpectation{
		mock:   mmValidateGetOrderFromCourier.mock,
		params: &InputValidatorValidateGetOrderFromCourierParams{orderID, clientID, date, pack, price, weight},
	}
	mmValidateGetOrderFromCourier.expectations = append(mmValidateGetOrderFromCourier.expectations, expectation)
	return expectation
}

// Then sets up InputValidator.ValidateGetOrderFromCourier return parameters for the expectation previously defined by the When method
func (e *InputValidatorValidateGetOrderFromCourierExpectation) Then(op1 *model.Order, err error) *InputValidator {
	e.results = &InputValidatorValidateGetOrderFromCourierResults{op1, err}
	return e.mock
}

// Times sets number of times InputValidator.ValidateGetOrderFromCourier should be invoked
func (mmValidateGetOrderFromCourier *mInputValidatorValidateGetOrderFromCourier) Times(n uint64) *mInputValidatorValidateGetOrderFromCourier {
	if n == 0 {
		mmValidateGetOrderFromCourier.mock.t.Fatalf("Times of InputValidator.ValidateGetOrderFromCourier mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValidateGetOrderFromCourier.expectedInvocations, n)
	return mmValidateGetOrderFromCourier
}

func (mmValidateGetOrderFromCourier *mInputValidatorValidateGetOrderFromCourier) invocationsDone() bool {
	if len(mmValidateGetOrderFromCourier.expectations) == 0 && mmValidateGetOrderFromCourier.defaultExpectation == nil && mmValidateGetOrderFromCourier.mock.funcValidateGetOrderFromCourier == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValidateGetOrderFromCourier.mock.afterValidateGetOrderFromCourierCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValidateGetOrderFromCourier.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ValidateGetOrderFromCourier implements api.InputValidator
func (mmValidateGetOrderFromCourier *InputValidator) ValidateGetOrderFromCourier(orderID string, clientID string, date string, pack string, price int, weight int) (op1 *model.Order, err error) {
	mm_atomic.AddUint64(&mmValidateGetOrderFromCourier.beforeValidateGetOrderFromCourierCounter, 1)
	defer mm_atomic.AddUint64(&mmValidateGetOrderFromCourier.afterValidateGetOrderFromCourierCounter, 1)

	if mmValidateGetOrderFromCourier.inspectFuncValidateGetOrderFromCourier != nil {
		mmValidateGetOrderFromCourier.inspectFuncValidateGetOrderFromCourier(orderID, clientID, date, pack, price, weight)
	}

	mm_params := InputValidatorValidateGetOrderFromCourierParams{orderID, clientID, date, pack, price, weight}

	// Record call args
	mmValidateGetOrderFromCourier.ValidateGetOrderFromCourierMock.mutex.Lock()
	mmValidateGetOrderFromCourier.ValidateGetOrderFromCourierMock.callArgs = append(mmValidateGetOrderFromCourier.ValidateGetOrderFromCourierMock.callArgs, &mm_params)
	mmValidateGetOrderFromCourier.ValidateGetOrderFromCourierMock.mutex.Unlock()

	for _, e := range mmValidateGetOrderFromCourier.ValidateGetOrderFromCourierMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmValidateGetOrderFromCourier.ValidateGetOrderFromCourierMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidateGetOrderFromCourier.ValidateGetOrderFromCourierMock.defaultExpectation.Counter, 1)
		mm_want := mmValidateGetOrderFromCourier.ValidateGetOrderFromCourierMock.defaultExpectation.params
		mm_want_ptrs := mmValidateGetOrderFromCourier.ValidateGetOrderFromCourierMock.defaultExpectation.paramPtrs

		mm_got := InputValidatorValidateGetOrderFromCourierParams{orderID, clientID, date, pack, price, weight}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmValidateGetOrderFromCourier.t.Errorf("InputValidator.ValidateGetOrderFromCourier got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmValidateGetOrderFromCourier.t.Errorf("InputValidator.ValidateGetOrderFromCourier got unexpected parameter clientID, want: %#v, got: %#v%s\n", *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

			if mm_want_ptrs.date != nil && !minimock.Equal(*mm_want_ptrs.date, mm_got.date) {
				mmValidateGetOrderFromCourier.t.Errorf("InputValidator.ValidateGetOrderFromCourier got unexpected parameter date, want: %#v, got: %#v%s\n", *mm_want_ptrs.date, mm_got.date, minimock.Diff(*mm_want_ptrs.date, mm_got.date))
			}

			if mm_want_ptrs.pack != nil && !minimock.Equal(*mm_want_ptrs.pack, mm_got.pack) {
				mmValidateGetOrderFromCourier.t.Errorf("InputValidator.ValidateGetOrderFromCourier got unexpected parameter pack, want: %#v, got: %#v%s\n", *mm_want_ptrs.pack, mm_got.pack, minimock.Diff(*mm_want_ptrs.pack, mm_got.pack))
			}

			if mm_want_ptrs.price != nil && !minimock.Equal(*mm_want_ptrs.price, mm_got.price) {
				mmValidateGetOrderFromCourier.t.Errorf("InputValidator.ValidateGetOrderFromCourier got unexpected parameter price, want: %#v, got: %#v%s\n", *mm_want_ptrs.price, mm_got.price, minimock.Diff(*mm_want_ptrs.price, mm_got.price))
			}

			if mm_want_ptrs.weight != nil && !minimock.Equal(*mm_want_ptrs.weight, mm_got.weight) {
				mmValidateGetOrderFromCourier.t.Errorf("InputValidator.ValidateGetOrderFromCourier got unexpected parameter weight, want: %#v, got: %#v%s\n", *mm_want_ptrs.weight, mm_got.weight, minimock.Diff(*mm_want_ptrs.weight, mm_got.weight))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidateGetOrderFromCourier.t.Errorf("InputValidator.ValidateGetOrderFromCourier got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidateGetOrderFromCourier.ValidateGetOrderFromCourierMock.defaultExpectation.results
		if mm_results == nil {
			mmValidateGetOrderFromCourier.t.Fatal("No results are set for the InputValidator.ValidateGetOrderFromCourier")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmValidateGetOrderFromCourier.funcValidateGetOrderFromCourier != nil {
		return mmValidateGetOrderFromCourier.funcValidateGetOrderFromCourier(orderID, clientID, date, pack, price, weight)
	}
	mmValidateGetOrderFromCourier.t.Fatalf("Unexpected call to InputValidator.ValidateGetOrderFromCourier. %v %v %v %v %v %v", orderID, clientID, date, pack, price, weight)
	return
}

// ValidateGetOrderFromCourierAfterCounter returns a count of finished InputValidator.ValidateGetOrderFromCourier invocations
func (mmValidateGetOrderFromCourier *InputValidator) ValidateGetOrderFromCourierAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateGetOrderFromCourier.afterValidateGetOrderFromCourierCounter)
}

// ValidateGetOrderFromCourierBeforeCounter returns a count of InputValidator.ValidateGetOrderFromCourier invocations
func (mmValidateGetOrderFromCourier *InputValidator) ValidateGetOrderFromCourierBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateGetOrderFromCourier.beforeValidateGetOrderFromCourierCounter)
}

// Calls returns a list of arguments used in each call to InputValidator.ValidateGetOrderFromCourier.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidateGetOrderFromCourier *mInputValidatorValidateGetOrderFromCourier) Calls() []*InputValidatorValidateGetOrderFromCourierParams {
	mmValidateGetOrderFromCourier.mutex.RLock()

	argCopy := make([]*InputValidatorValidateGetOrderFromCourierParams, len(mmValidateGetOrderFromCourier.callArgs))
	copy(argCopy, mmValidateGetOrderFromCourier.callArgs)

	mmValidateGetOrderFromCourier.mutex.RUnlock()

	return argCopy
}

// MinimockValidateGetOrderFromCourierDone returns true if the count of the ValidateGetOrderFromCourier invocations corresponds
// the number of defined expectations
func (m *InputValidator) MinimockValidateGetOrderFromCourierDone() bool {
	if m.ValidateGetOrderFromCourierMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValidateGetOrderFromCourierMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValidateGetOrderFromCourierMock.invocationsDone()
}

// MinimockValidateGetOrderFromCourierInspect logs each unmet expectation
func (m *InputValidator) MinimockValidateGetOrderFromCourierInspect() {
	for _, e := range m.ValidateGetOrderFromCourierMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InputValidator.ValidateGetOrderFromCourier with params: %#v", *e.params)
		}
	}

	afterValidateGetOrderFromCourierCounter := mm_atomic.LoadUint64(&m.afterValidateGetOrderFromCourierCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValidateGetOrderFromCourierMock.defaultExpectation != nil && afterValidateGetOrderFromCourierCounter < 1 {
		if m.ValidateGetOrderFromCourierMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InputValidator.ValidateGetOrderFromCourier")
		} else {
			m.t.Errorf("Expected call to InputValidator.ValidateGetOrderFromCourier with params: %#v", *m.ValidateGetOrderFromCourierMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidateGetOrderFromCourier != nil && afterValidateGetOrderFromCourierCounter < 1 {
		m.t.Error("Expected call to InputValidator.ValidateGetOrderFromCourier")
	}

	if !m.ValidateGetOrderFromCourierMock.invocationsDone() && afterValidateGetOrderFromCourierCounter > 0 {
		m.t.Errorf("Expected %d calls to InputValidator.ValidateGetOrderFromCourier but found %d calls",
			mm_atomic.LoadUint64(&m.ValidateGetOrderFromCourierMock.expectedInvocations), afterValidateGetOrderFromCourierCounter)
	}
}

type mInputValidatorValidateGiveOrder struct {
	optional           bool
	mock               *InputValidator
	defaultExpectation *InputValidatorValidateGiveOrderExpectation
	expectations       []*InputValidatorValidateGiveOrderExpectation

	callArgs []*InputValidatorValidateGiveOrderParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// InputValidatorValidateGiveOrderExpectation specifies expectation struct of the InputValidator.ValidateGiveOrder
type InputValidatorValidateGiveOrderExpectation struct {
	mock      *InputValidator
	params    *InputValidatorValidateGiveOrderParams
	paramPtrs *InputValidatorValidateGiveOrderParamPtrs
	results   *InputValidatorValidateGiveOrderResults
	Counter   uint64
}

// InputValidatorValidateGiveOrderParams contains parameters of the InputValidator.ValidateGiveOrder
type InputValidatorValidateGiveOrderParams struct {
	orders         string
	pack           string
	loadedPackages []model.Package
}

// InputValidatorValidateGiveOrderParamPtrs contains pointers to parameters of the InputValidator.ValidateGiveOrder
type InputValidatorValidateGiveOrderParamPtrs struct {
	orders         *string
	pack           *string
	loadedPackages *[]model.Package
}

// InputValidatorValidateGiveOrderResults contains results of the InputValidator.ValidateGiveOrder
type InputValidatorValidateGiveOrderResults struct {
	oa1 []model.OrderID
	pp1 *model.PackageType
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidateGiveOrder *mInputValidatorValidateGiveOrder) Optional() *mInputValidatorValidateGiveOrder {
	mmValidateGiveOrder.optional = true
	return mmValidateGiveOrder
}

// Expect sets up expected params for InputValidator.ValidateGiveOrder
func (mmValidateGiveOrder *mInputValidatorValidateGiveOrder) Expect(orders string, pack string, loadedPackages []model.Package) *mInputValidatorValidateGiveOrder {
	if mmValidateGiveOrder.mock.funcValidateGiveOrder != nil {
		mmValidateGiveOrder.mock.t.Fatalf("InputValidator.ValidateGiveOrder mock is already set by Set")
	}

	if mmValidateGiveOrder.defaultExpectation == nil {
		mmValidateGiveOrder.defaultExpectation = &InputValidatorValidateGiveOrderExpectation{}
	}

	if mmValidateGiveOrder.defaultExpectation.paramPtrs != nil {
		mmValidateGiveOrder.mock.t.Fatalf("InputValidator.ValidateGiveOrder mock is already set by ExpectParams functions")
	}

	mmValidateGiveOrder.defaultExpectation.params = &InputValidatorValidateGiveOrderParams{orders, pack, loadedPackages}
	for _, e := range mmValidateGiveOrder.expectations {
		if minimock.Equal(e.params, mmValidateGiveOrder.defaultExpectation.params) {
			mmValidateGiveOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidateGiveOrder.defaultExpectation.params)
		}
	}

	return mmValidateGiveOrder
}

// ExpectOrdersParam1 sets up expected param orders for InputValidator.ValidateGiveOrder
func (mmValidateGiveOrder *mInputValidatorValidateGiveOrder) ExpectOrdersParam1(orders string) *mInputValidatorValidateGiveOrder {
	if mmValidateGiveOrder.mock.funcValidateGiveOrder != nil {
		mmValidateGiveOrder.mock.t.Fatalf("InputValidator.ValidateGiveOrder mock is already set by Set")
	}

	if mmValidateGiveOrder.defaultExpectation == nil {
		mmValidateGiveOrder.defaultExpectation = &InputValidatorValidateGiveOrderExpectation{}
	}

	if mmValidateGiveOrder.defaultExpectation.params != nil {
		mmValidateGiveOrder.mock.t.Fatalf("InputValidator.ValidateGiveOrder mock is already set by Expect")
	}

	if mmValidateGiveOrder.defaultExpectation.paramPtrs == nil {
		mmValidateGiveOrder.defaultExpectation.paramPtrs = &InputValidatorValidateGiveOrderParamPtrs{}
	}
	mmValidateGiveOrder.defaultExpectation.paramPtrs.orders = &orders

	return mmValidateGiveOrder
}

// ExpectPackParam2 sets up expected param pack for InputValidator.ValidateGiveOrder
func (mmValidateGiveOrder *mInputValidatorValidateGiveOrder) ExpectPackParam2(pack string) *mInputValidatorValidateGiveOrder {
	if mmValidateGiveOrder.mock.funcValidateGiveOrder != nil {
		mmValidateGiveOrder.mock.t.Fatalf("InputValidator.ValidateGiveOrder mock is already set by Set")
	}

	if mmValidateGiveOrder.defaultExpectation == nil {
		mmValidateGiveOrder.defaultExpectation = &InputValidatorValidateGiveOrderExpectation{}
	}

	if mmValidateGiveOrder.defaultExpectation.params != nil {
		mmValidateGiveOrder.mock.t.Fatalf("InputValidator.ValidateGiveOrder mock is already set by Expect")
	}

	if mmValidateGiveOrder.defaultExpectation.paramPtrs == nil {
		mmValidateGiveOrder.defaultExpectation.paramPtrs = &InputValidatorValidateGiveOrderParamPtrs{}
	}
	mmValidateGiveOrder.defaultExpectation.paramPtrs.pack = &pack

	return mmValidateGiveOrder
}

// ExpectLoadedPackagesParam3 sets up expected param loadedPackages for InputValidator.ValidateGiveOrder
func (mmValidateGiveOrder *mInputValidatorValidateGiveOrder) ExpectLoadedPackagesParam3(loadedPackages []model.Package) *mInputValidatorValidateGiveOrder {
	if mmValidateGiveOrder.mock.funcValidateGiveOrder != nil {
		mmValidateGiveOrder.mock.t.Fatalf("InputValidator.ValidateGiveOrder mock is already set by Set")
	}

	if mmValidateGiveOrder.defaultExpectation == nil {
		mmValidateGiveOrder.defaultExpectation = &InputValidatorValidateGiveOrderExpectation{}
	}

	if mmValidateGiveOrder.defaultExpectation.params != nil {
		mmValidateGiveOrder.mock.t.Fatalf("InputValidator.ValidateGiveOrder mock is already set by Expect")
	}

	if mmValidateGiveOrder.defaultExpectation.paramPtrs == nil {
		mmValidateGiveOrder.defaultExpectation.paramPtrs = &InputValidatorValidateGiveOrderParamPtrs{}
	}
	mmValidateGiveOrder.defaultExpectation.paramPtrs.loadedPackages = &loadedPackages

	return mmValidateGiveOrder
}

// Inspect accepts an inspector function that has same arguments as the InputValidator.ValidateGiveOrder
func (mmValidateGiveOrder *mInputValidatorValidateGiveOrder) Inspect(f func(orders string, pack string, loadedPackages []model.Package)) *mInputValidatorValidateGiveOrder {
	if mmValidateGiveOrder.mock.inspectFuncValidateGiveOrder != nil {
		mmValidateGiveOrder.mock.t.Fatalf("Inspect function is already set for InputValidator.ValidateGiveOrder")
	}

	mmValidateGiveOrder.mock.inspectFuncValidateGiveOrder = f

	return mmValidateGiveOrder
}

// Return sets up results that will be returned by InputValidator.ValidateGiveOrder
func (mmValidateGiveOrder *mInputValidatorValidateGiveOrder) Return(oa1 []model.OrderID, pp1 *model.PackageType, err error) *InputValidator {
	if mmValidateGiveOrder.mock.funcValidateGiveOrder != nil {
		mmValidateGiveOrder.mock.t.Fatalf("InputValidator.ValidateGiveOrder mock is already set by Set")
	}

	if mmValidateGiveOrder.defaultExpectation == nil {
		mmValidateGiveOrder.defaultExpectation = &InputValidatorValidateGiveOrderExpectation{mock: mmValidateGiveOrder.mock}
	}
	mmValidateGiveOrder.defaultExpectation.results = &InputValidatorValidateGiveOrderResults{oa1, pp1, err}
	return mmValidateGiveOrder.mock
}

// Set uses given function f to mock the InputValidator.ValidateGiveOrder method
func (mmValidateGiveOrder *mInputValidatorValidateGiveOrder) Set(f func(orders string, pack string, loadedPackages []model.Package) (oa1 []model.OrderID, pp1 *model.PackageType, err error)) *InputValidator {
	if mmValidateGiveOrder.defaultExpectation != nil {
		mmValidateGiveOrder.mock.t.Fatalf("Default expectation is already set for the InputValidator.ValidateGiveOrder method")
	}

	if len(mmValidateGiveOrder.expectations) > 0 {
		mmValidateGiveOrder.mock.t.Fatalf("Some expectations are already set for the InputValidator.ValidateGiveOrder method")
	}

	mmValidateGiveOrder.mock.funcValidateGiveOrder = f
	return mmValidateGiveOrder.mock
}

// When sets expectation for the InputValidator.ValidateGiveOrder which will trigger the result defined by the following
// Then helper
func (mmValidateGiveOrder *mInputValidatorValidateGiveOrder) When(orders string, pack string, loadedPackages []model.Package) *InputValidatorValidateGiveOrderExpectation {
	if mmValidateGiveOrder.mock.funcValidateGiveOrder != nil {
		mmValidateGiveOrder.mock.t.Fatalf("InputValidator.ValidateGiveOrder mock is already set by Set")
	}

	expectation := &InputValidatorValidateGiveOrderExpectation{
		mock:   mmValidateGiveOrder.mock,
		params: &InputValidatorValidateGiveOrderParams{orders, pack, loadedPackages},
	}
	mmValidateGiveOrder.expectations = append(mmValidateGiveOrder.expectations, expectation)
	return expectation
}

// Then sets up InputValidator.ValidateGiveOrder return parameters for the expectation previously defined by the When method
func (e *InputValidatorValidateGiveOrderExpectation) Then(oa1 []model.OrderID, pp1 *model.PackageType, err error) *InputValidator {
	e.results = &InputValidatorValidateGiveOrderResults{oa1, pp1, err}
	return e.mock
}

// Times sets number of times InputValidator.ValidateGiveOrder should be invoked
func (mmValidateGiveOrder *mInputValidatorValidateGiveOrder) Times(n uint64) *mInputValidatorValidateGiveOrder {
	if n == 0 {
		mmValidateGiveOrder.mock.t.Fatalf("Times of InputValidator.ValidateGiveOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValidateGiveOrder.expectedInvocations, n)
	return mmValidateGiveOrder
}

func (mmValidateGiveOrder *mInputValidatorValidateGiveOrder) invocationsDone() bool {
	if len(mmValidateGiveOrder.expectations) == 0 && mmValidateGiveOrder.defaultExpectation == nil && mmValidateGiveOrder.mock.funcValidateGiveOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValidateGiveOrder.mock.afterValidateGiveOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValidateGiveOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ValidateGiveOrder implements api.InputValidator
func (mmValidateGiveOrder *InputValidator) ValidateGiveOrder(orders string, pack string, loadedPackages []model.Package) (oa1 []model.OrderID, pp1 *model.PackageType, err error) {
	mm_atomic.AddUint64(&mmValidateGiveOrder.beforeValidateGiveOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmValidateGiveOrder.afterValidateGiveOrderCounter, 1)

	if mmValidateGiveOrder.inspectFuncValidateGiveOrder != nil {
		mmValidateGiveOrder.inspectFuncValidateGiveOrder(orders, pack, loadedPackages)
	}

	mm_params := InputValidatorValidateGiveOrderParams{orders, pack, loadedPackages}

	// Record call args
	mmValidateGiveOrder.ValidateGiveOrderMock.mutex.Lock()
	mmValidateGiveOrder.ValidateGiveOrderMock.callArgs = append(mmValidateGiveOrder.ValidateGiveOrderMock.callArgs, &mm_params)
	mmValidateGiveOrder.ValidateGiveOrderMock.mutex.Unlock()

	for _, e := range mmValidateGiveOrder.ValidateGiveOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.pp1, e.results.err
		}
	}

	if mmValidateGiveOrder.ValidateGiveOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidateGiveOrder.ValidateGiveOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmValidateGiveOrder.ValidateGiveOrderMock.defaultExpectation.params
		mm_want_ptrs := mmValidateGiveOrder.ValidateGiveOrderMock.defaultExpectation.paramPtrs

		mm_got := InputValidatorValidateGiveOrderParams{orders, pack, loadedPackages}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.orders != nil && !minimock.Equal(*mm_want_ptrs.orders, mm_got.orders) {
				mmValidateGiveOrder.t.Errorf("InputValidator.ValidateGiveOrder got unexpected parameter orders, want: %#v, got: %#v%s\n", *mm_want_ptrs.orders, mm_got.orders, minimock.Diff(*mm_want_ptrs.orders, mm_got.orders))
			}

			if mm_want_ptrs.pack != nil && !minimock.Equal(*mm_want_ptrs.pack, mm_got.pack) {
				mmValidateGiveOrder.t.Errorf("InputValidator.ValidateGiveOrder got unexpected parameter pack, want: %#v, got: %#v%s\n", *mm_want_ptrs.pack, mm_got.pack, minimock.Diff(*mm_want_ptrs.pack, mm_got.pack))
			}

			if mm_want_ptrs.loadedPackages != nil && !minimock.Equal(*mm_want_ptrs.loadedPackages, mm_got.loadedPackages) {
				mmValidateGiveOrder.t.Errorf("InputValidator.ValidateGiveOrder got unexpected parameter loadedPackages, want: %#v, got: %#v%s\n", *mm_want_ptrs.loadedPackages, mm_got.loadedPackages, minimock.Diff(*mm_want_ptrs.loadedPackages, mm_got.loadedPackages))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidateGiveOrder.t.Errorf("InputValidator.ValidateGiveOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidateGiveOrder.ValidateGiveOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmValidateGiveOrder.t.Fatal("No results are set for the InputValidator.ValidateGiveOrder")
		}
		return (*mm_results).oa1, (*mm_results).pp1, (*mm_results).err
	}
	if mmValidateGiveOrder.funcValidateGiveOrder != nil {
		return mmValidateGiveOrder.funcValidateGiveOrder(orders, pack, loadedPackages)
	}
	mmValidateGiveOrder.t.Fatalf("Unexpected call to InputValidator.ValidateGiveOrder. %v %v %v", orders, pack, loadedPackages)
	return
}

// ValidateGiveOrderAfterCounter returns a count of finished InputValidator.ValidateGiveOrder invocations
func (mmValidateGiveOrder *InputValidator) ValidateGiveOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateGiveOrder.afterValidateGiveOrderCounter)
}

// ValidateGiveOrderBeforeCounter returns a count of InputValidator.ValidateGiveOrder invocations
func (mmValidateGiveOrder *InputValidator) ValidateGiveOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateGiveOrder.beforeValidateGiveOrderCounter)
}

// Calls returns a list of arguments used in each call to InputValidator.ValidateGiveOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidateGiveOrder *mInputValidatorValidateGiveOrder) Calls() []*InputValidatorValidateGiveOrderParams {
	mmValidateGiveOrder.mutex.RLock()

	argCopy := make([]*InputValidatorValidateGiveOrderParams, len(mmValidateGiveOrder.callArgs))
	copy(argCopy, mmValidateGiveOrder.callArgs)

	mmValidateGiveOrder.mutex.RUnlock()

	return argCopy
}

// MinimockValidateGiveOrderDone returns true if the count of the ValidateGiveOrder invocations corresponds
// the number of defined expectations
func (m *InputValidator) MinimockValidateGiveOrderDone() bool {
	if m.ValidateGiveOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValidateGiveOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValidateGiveOrderMock.invocationsDone()
}

// MinimockValidateGiveOrderInspect logs each unmet expectation
func (m *InputValidator) MinimockValidateGiveOrderInspect() {
	for _, e := range m.ValidateGiveOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InputValidator.ValidateGiveOrder with params: %#v", *e.params)
		}
	}

	afterValidateGiveOrderCounter := mm_atomic.LoadUint64(&m.afterValidateGiveOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValidateGiveOrderMock.defaultExpectation != nil && afterValidateGiveOrderCounter < 1 {
		if m.ValidateGiveOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InputValidator.ValidateGiveOrder")
		} else {
			m.t.Errorf("Expected call to InputValidator.ValidateGiveOrder with params: %#v", *m.ValidateGiveOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidateGiveOrder != nil && afterValidateGiveOrderCounter < 1 {
		m.t.Error("Expected call to InputValidator.ValidateGiveOrder")
	}

	if !m.ValidateGiveOrderMock.invocationsDone() && afterValidateGiveOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to InputValidator.ValidateGiveOrder but found %d calls",
			mm_atomic.LoadUint64(&m.ValidateGiveOrderMock.expectedInvocations), afterValidateGiveOrderCounter)
	}
}

type mInputValidatorValidateListOrders struct {
	optional           bool
	mock               *InputValidator
	defaultExpectation *InputValidatorValidateListOrdersExpectation
	expectations       []*InputValidatorValidateListOrdersExpectation

	callArgs []*InputValidatorValidateListOrdersParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// InputValidatorValidateListOrdersExpectation specifies expectation struct of the InputValidator.ValidateListOrders
type InputValidatorValidateListOrdersExpectation struct {
	mock      *InputValidator
	params    *InputValidatorValidateListOrdersParams
	paramPtrs *InputValidatorValidateListOrdersParamPtrs
	results   *InputValidatorValidateListOrdersResults
	Counter   uint64
}

// InputValidatorValidateListOrdersParams contains parameters of the InputValidator.ValidateListOrders
type InputValidatorValidateListOrdersParams struct {
	clientID string
	action   string
}

// InputValidatorValidateListOrdersParamPtrs contains pointers to parameters of the InputValidator.ValidateListOrders
type InputValidatorValidateListOrdersParamPtrs struct {
	clientID *string
	action   *string
}

// InputValidatorValidateListOrdersResults contains results of the InputValidator.ValidateListOrders
type InputValidatorValidateListOrdersResults struct {
	c1  model.ClientID
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidateListOrders *mInputValidatorValidateListOrders) Optional() *mInputValidatorValidateListOrders {
	mmValidateListOrders.optional = true
	return mmValidateListOrders
}

// Expect sets up expected params for InputValidator.ValidateListOrders
func (mmValidateListOrders *mInputValidatorValidateListOrders) Expect(clientID string, action string) *mInputValidatorValidateListOrders {
	if mmValidateListOrders.mock.funcValidateListOrders != nil {
		mmValidateListOrders.mock.t.Fatalf("InputValidator.ValidateListOrders mock is already set by Set")
	}

	if mmValidateListOrders.defaultExpectation == nil {
		mmValidateListOrders.defaultExpectation = &InputValidatorValidateListOrdersExpectation{}
	}

	if mmValidateListOrders.defaultExpectation.paramPtrs != nil {
		mmValidateListOrders.mock.t.Fatalf("InputValidator.ValidateListOrders mock is already set by ExpectParams functions")
	}

	mmValidateListOrders.defaultExpectation.params = &InputValidatorValidateListOrdersParams{clientID, action}
	for _, e := range mmValidateListOrders.expectations {
		if minimock.Equal(e.params, mmValidateListOrders.defaultExpectation.params) {
			mmValidateListOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidateListOrders.defaultExpectation.params)
		}
	}

	return mmValidateListOrders
}

// ExpectClientIDParam1 sets up expected param clientID for InputValidator.ValidateListOrders
func (mmValidateListOrders *mInputValidatorValidateListOrders) ExpectClientIDParam1(clientID string) *mInputValidatorValidateListOrders {
	if mmValidateListOrders.mock.funcValidateListOrders != nil {
		mmValidateListOrders.mock.t.Fatalf("InputValidator.ValidateListOrders mock is already set by Set")
	}

	if mmValidateListOrders.defaultExpectation == nil {
		mmValidateListOrders.defaultExpectation = &InputValidatorValidateListOrdersExpectation{}
	}

	if mmValidateListOrders.defaultExpectation.params != nil {
		mmValidateListOrders.mock.t.Fatalf("InputValidator.ValidateListOrders mock is already set by Expect")
	}

	if mmValidateListOrders.defaultExpectation.paramPtrs == nil {
		mmValidateListOrders.defaultExpectation.paramPtrs = &InputValidatorValidateListOrdersParamPtrs{}
	}
	mmValidateListOrders.defaultExpectation.paramPtrs.clientID = &clientID

	return mmValidateListOrders
}

// ExpectActionParam2 sets up expected param action for InputValidator.ValidateListOrders
func (mmValidateListOrders *mInputValidatorValidateListOrders) ExpectActionParam2(action string) *mInputValidatorValidateListOrders {
	if mmValidateListOrders.mock.funcValidateListOrders != nil {
		mmValidateListOrders.mock.t.Fatalf("InputValidator.ValidateListOrders mock is already set by Set")
	}

	if mmValidateListOrders.defaultExpectation == nil {
		mmValidateListOrders.defaultExpectation = &InputValidatorValidateListOrdersExpectation{}
	}

	if mmValidateListOrders.defaultExpectation.params != nil {
		mmValidateListOrders.mock.t.Fatalf("InputValidator.ValidateListOrders mock is already set by Expect")
	}

	if mmValidateListOrders.defaultExpectation.paramPtrs == nil {
		mmValidateListOrders.defaultExpectation.paramPtrs = &InputValidatorValidateListOrdersParamPtrs{}
	}
	mmValidateListOrders.defaultExpectation.paramPtrs.action = &action

	return mmValidateListOrders
}

// Inspect accepts an inspector function that has same arguments as the InputValidator.ValidateListOrders
func (mmValidateListOrders *mInputValidatorValidateListOrders) Inspect(f func(clientID string, action string)) *mInputValidatorValidateListOrders {
	if mmValidateListOrders.mock.inspectFuncValidateListOrders != nil {
		mmValidateListOrders.mock.t.Fatalf("Inspect function is already set for InputValidator.ValidateListOrders")
	}

	mmValidateListOrders.mock.inspectFuncValidateListOrders = f

	return mmValidateListOrders
}

// Return sets up results that will be returned by InputValidator.ValidateListOrders
func (mmValidateListOrders *mInputValidatorValidateListOrders) Return(c1 model.ClientID, err error) *InputValidator {
	if mmValidateListOrders.mock.funcValidateListOrders != nil {
		mmValidateListOrders.mock.t.Fatalf("InputValidator.ValidateListOrders mock is already set by Set")
	}

	if mmValidateListOrders.defaultExpectation == nil {
		mmValidateListOrders.defaultExpectation = &InputValidatorValidateListOrdersExpectation{mock: mmValidateListOrders.mock}
	}
	mmValidateListOrders.defaultExpectation.results = &InputValidatorValidateListOrdersResults{c1, err}
	return mmValidateListOrders.mock
}

// Set uses given function f to mock the InputValidator.ValidateListOrders method
func (mmValidateListOrders *mInputValidatorValidateListOrders) Set(f func(clientID string, action string) (c1 model.ClientID, err error)) *InputValidator {
	if mmValidateListOrders.defaultExpectation != nil {
		mmValidateListOrders.mock.t.Fatalf("Default expectation is already set for the InputValidator.ValidateListOrders method")
	}

	if len(mmValidateListOrders.expectations) > 0 {
		mmValidateListOrders.mock.t.Fatalf("Some expectations are already set for the InputValidator.ValidateListOrders method")
	}

	mmValidateListOrders.mock.funcValidateListOrders = f
	return mmValidateListOrders.mock
}

// When sets expectation for the InputValidator.ValidateListOrders which will trigger the result defined by the following
// Then helper
func (mmValidateListOrders *mInputValidatorValidateListOrders) When(clientID string, action string) *InputValidatorValidateListOrdersExpectation {
	if mmValidateListOrders.mock.funcValidateListOrders != nil {
		mmValidateListOrders.mock.t.Fatalf("InputValidator.ValidateListOrders mock is already set by Set")
	}

	expectation := &InputValidatorValidateListOrdersExpectation{
		mock:   mmValidateListOrders.mock,
		params: &InputValidatorValidateListOrdersParams{clientID, action},
	}
	mmValidateListOrders.expectations = append(mmValidateListOrders.expectations, expectation)
	return expectation
}

// Then sets up InputValidator.ValidateListOrders return parameters for the expectation previously defined by the When method
func (e *InputValidatorValidateListOrdersExpectation) Then(c1 model.ClientID, err error) *InputValidator {
	e.results = &InputValidatorValidateListOrdersResults{c1, err}
	return e.mock
}

// Times sets number of times InputValidator.ValidateListOrders should be invoked
func (mmValidateListOrders *mInputValidatorValidateListOrders) Times(n uint64) *mInputValidatorValidateListOrders {
	if n == 0 {
		mmValidateListOrders.mock.t.Fatalf("Times of InputValidator.ValidateListOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValidateListOrders.expectedInvocations, n)
	return mmValidateListOrders
}

func (mmValidateListOrders *mInputValidatorValidateListOrders) invocationsDone() bool {
	if len(mmValidateListOrders.expectations) == 0 && mmValidateListOrders.defaultExpectation == nil && mmValidateListOrders.mock.funcValidateListOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValidateListOrders.mock.afterValidateListOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValidateListOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ValidateListOrders implements api.InputValidator
func (mmValidateListOrders *InputValidator) ValidateListOrders(clientID string, action string) (c1 model.ClientID, err error) {
	mm_atomic.AddUint64(&mmValidateListOrders.beforeValidateListOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmValidateListOrders.afterValidateListOrdersCounter, 1)

	if mmValidateListOrders.inspectFuncValidateListOrders != nil {
		mmValidateListOrders.inspectFuncValidateListOrders(clientID, action)
	}

	mm_params := InputValidatorValidateListOrdersParams{clientID, action}

	// Record call args
	mmValidateListOrders.ValidateListOrdersMock.mutex.Lock()
	mmValidateListOrders.ValidateListOrdersMock.callArgs = append(mmValidateListOrders.ValidateListOrdersMock.callArgs, &mm_params)
	mmValidateListOrders.ValidateListOrdersMock.mutex.Unlock()

	for _, e := range mmValidateListOrders.ValidateListOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c1, e.results.err
		}
	}

	if mmValidateListOrders.ValidateListOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidateListOrders.ValidateListOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmValidateListOrders.ValidateListOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmValidateListOrders.ValidateListOrdersMock.defaultExpectation.paramPtrs

		mm_got := InputValidatorValidateListOrdersParams{clientID, action}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmValidateListOrders.t.Errorf("InputValidator.ValidateListOrders got unexpected parameter clientID, want: %#v, got: %#v%s\n", *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

			if mm_want_ptrs.action != nil && !minimock.Equal(*mm_want_ptrs.action, mm_got.action) {
				mmValidateListOrders.t.Errorf("InputValidator.ValidateListOrders got unexpected parameter action, want: %#v, got: %#v%s\n", *mm_want_ptrs.action, mm_got.action, minimock.Diff(*mm_want_ptrs.action, mm_got.action))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidateListOrders.t.Errorf("InputValidator.ValidateListOrders got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidateListOrders.ValidateListOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmValidateListOrders.t.Fatal("No results are set for the InputValidator.ValidateListOrders")
		}
		return (*mm_results).c1, (*mm_results).err
	}
	if mmValidateListOrders.funcValidateListOrders != nil {
		return mmValidateListOrders.funcValidateListOrders(clientID, action)
	}
	mmValidateListOrders.t.Fatalf("Unexpected call to InputValidator.ValidateListOrders. %v %v", clientID, action)
	return
}

// ValidateListOrdersAfterCounter returns a count of finished InputValidator.ValidateListOrders invocations
func (mmValidateListOrders *InputValidator) ValidateListOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateListOrders.afterValidateListOrdersCounter)
}

// ValidateListOrdersBeforeCounter returns a count of InputValidator.ValidateListOrders invocations
func (mmValidateListOrders *InputValidator) ValidateListOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateListOrders.beforeValidateListOrdersCounter)
}

// Calls returns a list of arguments used in each call to InputValidator.ValidateListOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidateListOrders *mInputValidatorValidateListOrders) Calls() []*InputValidatorValidateListOrdersParams {
	mmValidateListOrders.mutex.RLock()

	argCopy := make([]*InputValidatorValidateListOrdersParams, len(mmValidateListOrders.callArgs))
	copy(argCopy, mmValidateListOrders.callArgs)

	mmValidateListOrders.mutex.RUnlock()

	return argCopy
}

// MinimockValidateListOrdersDone returns true if the count of the ValidateListOrders invocations corresponds
// the number of defined expectations
func (m *InputValidator) MinimockValidateListOrdersDone() bool {
	if m.ValidateListOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValidateListOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValidateListOrdersMock.invocationsDone()
}

// MinimockValidateListOrdersInspect logs each unmet expectation
func (m *InputValidator) MinimockValidateListOrdersInspect() {
	for _, e := range m.ValidateListOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InputValidator.ValidateListOrders with params: %#v", *e.params)
		}
	}

	afterValidateListOrdersCounter := mm_atomic.LoadUint64(&m.afterValidateListOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValidateListOrdersMock.defaultExpectation != nil && afterValidateListOrdersCounter < 1 {
		if m.ValidateListOrdersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InputValidator.ValidateListOrders")
		} else {
			m.t.Errorf("Expected call to InputValidator.ValidateListOrders with params: %#v", *m.ValidateListOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidateListOrders != nil && afterValidateListOrdersCounter < 1 {
		m.t.Error("Expected call to InputValidator.ValidateListOrders")
	}

	if !m.ValidateListOrdersMock.invocationsDone() && afterValidateListOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to InputValidator.ValidateListOrders but found %d calls",
			mm_atomic.LoadUint64(&m.ValidateListOrdersMock.expectedInvocations), afterValidateListOrdersCounter)
	}
}

type mInputValidatorValidateListReturns struct {
	optional           bool
	mock               *InputValidator
	defaultExpectation *InputValidatorValidateListReturnsExpectation
	expectations       []*InputValidatorValidateListReturnsExpectation

	callArgs []*InputValidatorValidateListReturnsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// InputValidatorValidateListReturnsExpectation specifies expectation struct of the InputValidator.ValidateListReturns
type InputValidatorValidateListReturnsExpectation struct {
	mock      *InputValidator
	params    *InputValidatorValidateListReturnsParams
	paramPtrs *InputValidatorValidateListReturnsParamPtrs
	results   *InputValidatorValidateListReturnsResults
	Counter   uint64
}

// InputValidatorValidateListReturnsParams contains parameters of the InputValidator.ValidateListReturns
type InputValidatorValidateListReturnsParams struct {
	pageSize   int
	pageNumber int
}

// InputValidatorValidateListReturnsParamPtrs contains pointers to parameters of the InputValidator.ValidateListReturns
type InputValidatorValidateListReturnsParamPtrs struct {
	pageSize   *int
	pageNumber *int
}

// InputValidatorValidateListReturnsResults contains results of the InputValidator.ValidateListReturns
type InputValidatorValidateListReturnsResults struct {
	i1  int
	i2  int
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidateListReturns *mInputValidatorValidateListReturns) Optional() *mInputValidatorValidateListReturns {
	mmValidateListReturns.optional = true
	return mmValidateListReturns
}

// Expect sets up expected params for InputValidator.ValidateListReturns
func (mmValidateListReturns *mInputValidatorValidateListReturns) Expect(pageSize int, pageNumber int) *mInputValidatorValidateListReturns {
	if mmValidateListReturns.mock.funcValidateListReturns != nil {
		mmValidateListReturns.mock.t.Fatalf("InputValidator.ValidateListReturns mock is already set by Set")
	}

	if mmValidateListReturns.defaultExpectation == nil {
		mmValidateListReturns.defaultExpectation = &InputValidatorValidateListReturnsExpectation{}
	}

	if mmValidateListReturns.defaultExpectation.paramPtrs != nil {
		mmValidateListReturns.mock.t.Fatalf("InputValidator.ValidateListReturns mock is already set by ExpectParams functions")
	}

	mmValidateListReturns.defaultExpectation.params = &InputValidatorValidateListReturnsParams{pageSize, pageNumber}
	for _, e := range mmValidateListReturns.expectations {
		if minimock.Equal(e.params, mmValidateListReturns.defaultExpectation.params) {
			mmValidateListReturns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidateListReturns.defaultExpectation.params)
		}
	}

	return mmValidateListReturns
}

// ExpectPageSizeParam1 sets up expected param pageSize for InputValidator.ValidateListReturns
func (mmValidateListReturns *mInputValidatorValidateListReturns) ExpectPageSizeParam1(pageSize int) *mInputValidatorValidateListReturns {
	if mmValidateListReturns.mock.funcValidateListReturns != nil {
		mmValidateListReturns.mock.t.Fatalf("InputValidator.ValidateListReturns mock is already set by Set")
	}

	if mmValidateListReturns.defaultExpectation == nil {
		mmValidateListReturns.defaultExpectation = &InputValidatorValidateListReturnsExpectation{}
	}

	if mmValidateListReturns.defaultExpectation.params != nil {
		mmValidateListReturns.mock.t.Fatalf("InputValidator.ValidateListReturns mock is already set by Expect")
	}

	if mmValidateListReturns.defaultExpectation.paramPtrs == nil {
		mmValidateListReturns.defaultExpectation.paramPtrs = &InputValidatorValidateListReturnsParamPtrs{}
	}
	mmValidateListReturns.defaultExpectation.paramPtrs.pageSize = &pageSize

	return mmValidateListReturns
}

// ExpectPageNumberParam2 sets up expected param pageNumber for InputValidator.ValidateListReturns
func (mmValidateListReturns *mInputValidatorValidateListReturns) ExpectPageNumberParam2(pageNumber int) *mInputValidatorValidateListReturns {
	if mmValidateListReturns.mock.funcValidateListReturns != nil {
		mmValidateListReturns.mock.t.Fatalf("InputValidator.ValidateListReturns mock is already set by Set")
	}

	if mmValidateListReturns.defaultExpectation == nil {
		mmValidateListReturns.defaultExpectation = &InputValidatorValidateListReturnsExpectation{}
	}

	if mmValidateListReturns.defaultExpectation.params != nil {
		mmValidateListReturns.mock.t.Fatalf("InputValidator.ValidateListReturns mock is already set by Expect")
	}

	if mmValidateListReturns.defaultExpectation.paramPtrs == nil {
		mmValidateListReturns.defaultExpectation.paramPtrs = &InputValidatorValidateListReturnsParamPtrs{}
	}
	mmValidateListReturns.defaultExpectation.paramPtrs.pageNumber = &pageNumber

	return mmValidateListReturns
}

// Inspect accepts an inspector function that has same arguments as the InputValidator.ValidateListReturns
func (mmValidateListReturns *mInputValidatorValidateListReturns) Inspect(f func(pageSize int, pageNumber int)) *mInputValidatorValidateListReturns {
	if mmValidateListReturns.mock.inspectFuncValidateListReturns != nil {
		mmValidateListReturns.mock.t.Fatalf("Inspect function is already set for InputValidator.ValidateListReturns")
	}

	mmValidateListReturns.mock.inspectFuncValidateListReturns = f

	return mmValidateListReturns
}

// Return sets up results that will be returned by InputValidator.ValidateListReturns
func (mmValidateListReturns *mInputValidatorValidateListReturns) Return(i1 int, i2 int, err error) *InputValidator {
	if mmValidateListReturns.mock.funcValidateListReturns != nil {
		mmValidateListReturns.mock.t.Fatalf("InputValidator.ValidateListReturns mock is already set by Set")
	}

	if mmValidateListReturns.defaultExpectation == nil {
		mmValidateListReturns.defaultExpectation = &InputValidatorValidateListReturnsExpectation{mock: mmValidateListReturns.mock}
	}
	mmValidateListReturns.defaultExpectation.results = &InputValidatorValidateListReturnsResults{i1, i2, err}
	return mmValidateListReturns.mock
}

// Set uses given function f to mock the InputValidator.ValidateListReturns method
func (mmValidateListReturns *mInputValidatorValidateListReturns) Set(f func(pageSize int, pageNumber int) (i1 int, i2 int, err error)) *InputValidator {
	if mmValidateListReturns.defaultExpectation != nil {
		mmValidateListReturns.mock.t.Fatalf("Default expectation is already set for the InputValidator.ValidateListReturns method")
	}

	if len(mmValidateListReturns.expectations) > 0 {
		mmValidateListReturns.mock.t.Fatalf("Some expectations are already set for the InputValidator.ValidateListReturns method")
	}

	mmValidateListReturns.mock.funcValidateListReturns = f
	return mmValidateListReturns.mock
}

// When sets expectation for the InputValidator.ValidateListReturns which will trigger the result defined by the following
// Then helper
func (mmValidateListReturns *mInputValidatorValidateListReturns) When(pageSize int, pageNumber int) *InputValidatorValidateListReturnsExpectation {
	if mmValidateListReturns.mock.funcValidateListReturns != nil {
		mmValidateListReturns.mock.t.Fatalf("InputValidator.ValidateListReturns mock is already set by Set")
	}

	expectation := &InputValidatorValidateListReturnsExpectation{
		mock:   mmValidateListReturns.mock,
		params: &InputValidatorValidateListReturnsParams{pageSize, pageNumber},
	}
	mmValidateListReturns.expectations = append(mmValidateListReturns.expectations, expectation)
	return expectation
}

// Then sets up InputValidator.ValidateListReturns return parameters for the expectation previously defined by the When method
func (e *InputValidatorValidateListReturnsExpectation) Then(i1 int, i2 int, err error) *InputValidator {
	e.results = &InputValidatorValidateListReturnsResults{i1, i2, err}
	return e.mock
}

// Times sets number of times InputValidator.ValidateListReturns should be invoked
func (mmValidateListReturns *mInputValidatorValidateListReturns) Times(n uint64) *mInputValidatorValidateListReturns {
	if n == 0 {
		mmValidateListReturns.mock.t.Fatalf("Times of InputValidator.ValidateListReturns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValidateListReturns.expectedInvocations, n)
	return mmValidateListReturns
}

func (mmValidateListReturns *mInputValidatorValidateListReturns) invocationsDone() bool {
	if len(mmValidateListReturns.expectations) == 0 && mmValidateListReturns.defaultExpectation == nil && mmValidateListReturns.mock.funcValidateListReturns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValidateListReturns.mock.afterValidateListReturnsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValidateListReturns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ValidateListReturns implements api.InputValidator
func (mmValidateListReturns *InputValidator) ValidateListReturns(pageSize int, pageNumber int) (i1 int, i2 int, err error) {
	mm_atomic.AddUint64(&mmValidateListReturns.beforeValidateListReturnsCounter, 1)
	defer mm_atomic.AddUint64(&mmValidateListReturns.afterValidateListReturnsCounter, 1)

	if mmValidateListReturns.inspectFuncValidateListReturns != nil {
		mmValidateListReturns.inspectFuncValidateListReturns(pageSize, pageNumber)
	}

	mm_params := InputValidatorValidateListReturnsParams{pageSize, pageNumber}

	// Record call args
	mmValidateListReturns.ValidateListReturnsMock.mutex.Lock()
	mmValidateListReturns.ValidateListReturnsMock.callArgs = append(mmValidateListReturns.ValidateListReturnsMock.callArgs, &mm_params)
	mmValidateListReturns.ValidateListReturnsMock.mutex.Unlock()

	for _, e := range mmValidateListReturns.ValidateListReturnsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.i2, e.results.err
		}
	}

	if mmValidateListReturns.ValidateListReturnsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidateListReturns.ValidateListReturnsMock.defaultExpectation.Counter, 1)
		mm_want := mmValidateListReturns.ValidateListReturnsMock.defaultExpectation.params
		mm_want_ptrs := mmValidateListReturns.ValidateListReturnsMock.defaultExpectation.paramPtrs

		mm_got := InputValidatorValidateListReturnsParams{pageSize, pageNumber}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmValidateListReturns.t.Errorf("InputValidator.ValidateListReturns got unexpected parameter pageSize, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageNumber != nil && !minimock.Equal(*mm_want_ptrs.pageNumber, mm_got.pageNumber) {
				mmValidateListReturns.t.Errorf("InputValidator.ValidateListReturns got unexpected parameter pageNumber, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageNumber, mm_got.pageNumber, minimock.Diff(*mm_want_ptrs.pageNumber, mm_got.pageNumber))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidateListReturns.t.Errorf("InputValidator.ValidateListReturns got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidateListReturns.ValidateListReturnsMock.defaultExpectation.results
		if mm_results == nil {
			mmValidateListReturns.t.Fatal("No results are set for the InputValidator.ValidateListReturns")
		}
		return (*mm_results).i1, (*mm_results).i2, (*mm_results).err
	}
	if mmValidateListReturns.funcValidateListReturns != nil {
		return mmValidateListReturns.funcValidateListReturns(pageSize, pageNumber)
	}
	mmValidateListReturns.t.Fatalf("Unexpected call to InputValidator.ValidateListReturns. %v %v", pageSize, pageNumber)
	return
}

// ValidateListReturnsAfterCounter returns a count of finished InputValidator.ValidateListReturns invocations
func (mmValidateListReturns *InputValidator) ValidateListReturnsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateListReturns.afterValidateListReturnsCounter)
}

// ValidateListReturnsBeforeCounter returns a count of InputValidator.ValidateListReturns invocations
func (mmValidateListReturns *InputValidator) ValidateListReturnsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateListReturns.beforeValidateListReturnsCounter)
}

// Calls returns a list of arguments used in each call to InputValidator.ValidateListReturns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidateListReturns *mInputValidatorValidateListReturns) Calls() []*InputValidatorValidateListReturnsParams {
	mmValidateListReturns.mutex.RLock()

	argCopy := make([]*InputValidatorValidateListReturnsParams, len(mmValidateListReturns.callArgs))
	copy(argCopy, mmValidateListReturns.callArgs)

	mmValidateListReturns.mutex.RUnlock()

	return argCopy
}

// MinimockValidateListReturnsDone returns true if the count of the ValidateListReturns invocations corresponds
// the number of defined expectations
func (m *InputValidator) MinimockValidateListReturnsDone() bool {
	if m.ValidateListReturnsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValidateListReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValidateListReturnsMock.invocationsDone()
}

// MinimockValidateListReturnsInspect logs each unmet expectation
func (m *InputValidator) MinimockValidateListReturnsInspect() {
	for _, e := range m.ValidateListReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InputValidator.ValidateListReturns with params: %#v", *e.params)
		}
	}

	afterValidateListReturnsCounter := mm_atomic.LoadUint64(&m.afterValidateListReturnsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValidateListReturnsMock.defaultExpectation != nil && afterValidateListReturnsCounter < 1 {
		if m.ValidateListReturnsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InputValidator.ValidateListReturns")
		} else {
			m.t.Errorf("Expected call to InputValidator.ValidateListReturns with params: %#v", *m.ValidateListReturnsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidateListReturns != nil && afterValidateListReturnsCounter < 1 {
		m.t.Error("Expected call to InputValidator.ValidateListReturns")
	}

	if !m.ValidateListReturnsMock.invocationsDone() && afterValidateListReturnsCounter > 0 {
		m.t.Errorf("Expected %d calls to InputValidator.ValidateListReturns but found %d calls",
			mm_atomic.LoadUint64(&m.ValidateListReturnsMock.expectedInvocations), afterValidateListReturnsCounter)
	}
}

type mInputValidatorValidatePackage struct {
	optional           bool
	mock               *InputValidator
	defaultExpectation *InputValidatorValidatePackageExpectation
	expectations       []*InputValidatorValidatePackageExpectation

	callArgs []*InputValidatorValidatePackageParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// InputValidatorValidatePackageExpectation specifies expectation struct of the InputValidator.ValidatePackage
type InputValidatorValidatePackageExpectation struct {
	mock      *InputValidator
	params    *InputValidatorValidatePackageParams
	paramPtrs *InputValidatorValidatePackageParamPtrs
	results   *InputValidatorValidatePackageResults
	Counter   uint64
}

// InputValidatorValidatePackageParams contains parameters of the InputValidator.ValidatePackage
type InputValidatorValidatePackageParams struct {
	weight         int
	pack           model.PackageType
	loadedPackages []model.Package
}

// InputValidatorValidatePackageParamPtrs contains pointers to parameters of the InputValidator.ValidatePackage
type InputValidatorValidatePackageParamPtrs struct {
	weight         *int
	pack           *model.PackageType
	loadedPackages *[]model.Package
}

// InputValidatorValidatePackageResults contains results of the InputValidator.ValidatePackage
type InputValidatorValidatePackageResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidatePackage *mInputValidatorValidatePackage) Optional() *mInputValidatorValidatePackage {
	mmValidatePackage.optional = true
	return mmValidatePackage
}

// Expect sets up expected params for InputValidator.ValidatePackage
func (mmValidatePackage *mInputValidatorValidatePackage) Expect(weight int, pack model.PackageType, loadedPackages []model.Package) *mInputValidatorValidatePackage {
	if mmValidatePackage.mock.funcValidatePackage != nil {
		mmValidatePackage.mock.t.Fatalf("InputValidator.ValidatePackage mock is already set by Set")
	}

	if mmValidatePackage.defaultExpectation == nil {
		mmValidatePackage.defaultExpectation = &InputValidatorValidatePackageExpectation{}
	}

	if mmValidatePackage.defaultExpectation.paramPtrs != nil {
		mmValidatePackage.mock.t.Fatalf("InputValidator.ValidatePackage mock is already set by ExpectParams functions")
	}

	mmValidatePackage.defaultExpectation.params = &InputValidatorValidatePackageParams{weight, pack, loadedPackages}
	for _, e := range mmValidatePackage.expectations {
		if minimock.Equal(e.params, mmValidatePackage.defaultExpectation.params) {
			mmValidatePackage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidatePackage.defaultExpectation.params)
		}
	}

	return mmValidatePackage
}

// ExpectWeightParam1 sets up expected param weight for InputValidator.ValidatePackage
func (mmValidatePackage *mInputValidatorValidatePackage) ExpectWeightParam1(weight int) *mInputValidatorValidatePackage {
	if mmValidatePackage.mock.funcValidatePackage != nil {
		mmValidatePackage.mock.t.Fatalf("InputValidator.ValidatePackage mock is already set by Set")
	}

	if mmValidatePackage.defaultExpectation == nil {
		mmValidatePackage.defaultExpectation = &InputValidatorValidatePackageExpectation{}
	}

	if mmValidatePackage.defaultExpectation.params != nil {
		mmValidatePackage.mock.t.Fatalf("InputValidator.ValidatePackage mock is already set by Expect")
	}

	if mmValidatePackage.defaultExpectation.paramPtrs == nil {
		mmValidatePackage.defaultExpectation.paramPtrs = &InputValidatorValidatePackageParamPtrs{}
	}
	mmValidatePackage.defaultExpectation.paramPtrs.weight = &weight

	return mmValidatePackage
}

// ExpectPackParam2 sets up expected param pack for InputValidator.ValidatePackage
func (mmValidatePackage *mInputValidatorValidatePackage) ExpectPackParam2(pack model.PackageType) *mInputValidatorValidatePackage {
	if mmValidatePackage.mock.funcValidatePackage != nil {
		mmValidatePackage.mock.t.Fatalf("InputValidator.ValidatePackage mock is already set by Set")
	}

	if mmValidatePackage.defaultExpectation == nil {
		mmValidatePackage.defaultExpectation = &InputValidatorValidatePackageExpectation{}
	}

	if mmValidatePackage.defaultExpectation.params != nil {
		mmValidatePackage.mock.t.Fatalf("InputValidator.ValidatePackage mock is already set by Expect")
	}

	if mmValidatePackage.defaultExpectation.paramPtrs == nil {
		mmValidatePackage.defaultExpectation.paramPtrs = &InputValidatorValidatePackageParamPtrs{}
	}
	mmValidatePackage.defaultExpectation.paramPtrs.pack = &pack

	return mmValidatePackage
}

// ExpectLoadedPackagesParam3 sets up expected param loadedPackages for InputValidator.ValidatePackage
func (mmValidatePackage *mInputValidatorValidatePackage) ExpectLoadedPackagesParam3(loadedPackages []model.Package) *mInputValidatorValidatePackage {
	if mmValidatePackage.mock.funcValidatePackage != nil {
		mmValidatePackage.mock.t.Fatalf("InputValidator.ValidatePackage mock is already set by Set")
	}

	if mmValidatePackage.defaultExpectation == nil {
		mmValidatePackage.defaultExpectation = &InputValidatorValidatePackageExpectation{}
	}

	if mmValidatePackage.defaultExpectation.params != nil {
		mmValidatePackage.mock.t.Fatalf("InputValidator.ValidatePackage mock is already set by Expect")
	}

	if mmValidatePackage.defaultExpectation.paramPtrs == nil {
		mmValidatePackage.defaultExpectation.paramPtrs = &InputValidatorValidatePackageParamPtrs{}
	}
	mmValidatePackage.defaultExpectation.paramPtrs.loadedPackages = &loadedPackages

	return mmValidatePackage
}

// Inspect accepts an inspector function that has same arguments as the InputValidator.ValidatePackage
func (mmValidatePackage *mInputValidatorValidatePackage) Inspect(f func(weight int, pack model.PackageType, loadedPackages []model.Package)) *mInputValidatorValidatePackage {
	if mmValidatePackage.mock.inspectFuncValidatePackage != nil {
		mmValidatePackage.mock.t.Fatalf("Inspect function is already set for InputValidator.ValidatePackage")
	}

	mmValidatePackage.mock.inspectFuncValidatePackage = f

	return mmValidatePackage
}

// Return sets up results that will be returned by InputValidator.ValidatePackage
func (mmValidatePackage *mInputValidatorValidatePackage) Return(err error) *InputValidator {
	if mmValidatePackage.mock.funcValidatePackage != nil {
		mmValidatePackage.mock.t.Fatalf("InputValidator.ValidatePackage mock is already set by Set")
	}

	if mmValidatePackage.defaultExpectation == nil {
		mmValidatePackage.defaultExpectation = &InputValidatorValidatePackageExpectation{mock: mmValidatePackage.mock}
	}
	mmValidatePackage.defaultExpectation.results = &InputValidatorValidatePackageResults{err}
	return mmValidatePackage.mock
}

// Set uses given function f to mock the InputValidator.ValidatePackage method
func (mmValidatePackage *mInputValidatorValidatePackage) Set(f func(weight int, pack model.PackageType, loadedPackages []model.Package) (err error)) *InputValidator {
	if mmValidatePackage.defaultExpectation != nil {
		mmValidatePackage.mock.t.Fatalf("Default expectation is already set for the InputValidator.ValidatePackage method")
	}

	if len(mmValidatePackage.expectations) > 0 {
		mmValidatePackage.mock.t.Fatalf("Some expectations are already set for the InputValidator.ValidatePackage method")
	}

	mmValidatePackage.mock.funcValidatePackage = f
	return mmValidatePackage.mock
}

// When sets expectation for the InputValidator.ValidatePackage which will trigger the result defined by the following
// Then helper
func (mmValidatePackage *mInputValidatorValidatePackage) When(weight int, pack model.PackageType, loadedPackages []model.Package) *InputValidatorValidatePackageExpectation {
	if mmValidatePackage.mock.funcValidatePackage != nil {
		mmValidatePackage.mock.t.Fatalf("InputValidator.ValidatePackage mock is already set by Set")
	}

	expectation := &InputValidatorValidatePackageExpectation{
		mock:   mmValidatePackage.mock,
		params: &InputValidatorValidatePackageParams{weight, pack, loadedPackages},
	}
	mmValidatePackage.expectations = append(mmValidatePackage.expectations, expectation)
	return expectation
}

// Then sets up InputValidator.ValidatePackage return parameters for the expectation previously defined by the When method
func (e *InputValidatorValidatePackageExpectation) Then(err error) *InputValidator {
	e.results = &InputValidatorValidatePackageResults{err}
	return e.mock
}

// Times sets number of times InputValidator.ValidatePackage should be invoked
func (mmValidatePackage *mInputValidatorValidatePackage) Times(n uint64) *mInputValidatorValidatePackage {
	if n == 0 {
		mmValidatePackage.mock.t.Fatalf("Times of InputValidator.ValidatePackage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValidatePackage.expectedInvocations, n)
	return mmValidatePackage
}

func (mmValidatePackage *mInputValidatorValidatePackage) invocationsDone() bool {
	if len(mmValidatePackage.expectations) == 0 && mmValidatePackage.defaultExpectation == nil && mmValidatePackage.mock.funcValidatePackage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValidatePackage.mock.afterValidatePackageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValidatePackage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ValidatePackage implements api.InputValidator
func (mmValidatePackage *InputValidator) ValidatePackage(weight int, pack model.PackageType, loadedPackages []model.Package) (err error) {
	mm_atomic.AddUint64(&mmValidatePackage.beforeValidatePackageCounter, 1)
	defer mm_atomic.AddUint64(&mmValidatePackage.afterValidatePackageCounter, 1)

	if mmValidatePackage.inspectFuncValidatePackage != nil {
		mmValidatePackage.inspectFuncValidatePackage(weight, pack, loadedPackages)
	}

	mm_params := InputValidatorValidatePackageParams{weight, pack, loadedPackages}

	// Record call args
	mmValidatePackage.ValidatePackageMock.mutex.Lock()
	mmValidatePackage.ValidatePackageMock.callArgs = append(mmValidatePackage.ValidatePackageMock.callArgs, &mm_params)
	mmValidatePackage.ValidatePackageMock.mutex.Unlock()

	for _, e := range mmValidatePackage.ValidatePackageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmValidatePackage.ValidatePackageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidatePackage.ValidatePackageMock.defaultExpectation.Counter, 1)
		mm_want := mmValidatePackage.ValidatePackageMock.defaultExpectation.params
		mm_want_ptrs := mmValidatePackage.ValidatePackageMock.defaultExpectation.paramPtrs

		mm_got := InputValidatorValidatePackageParams{weight, pack, loadedPackages}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.weight != nil && !minimock.Equal(*mm_want_ptrs.weight, mm_got.weight) {
				mmValidatePackage.t.Errorf("InputValidator.ValidatePackage got unexpected parameter weight, want: %#v, got: %#v%s\n", *mm_want_ptrs.weight, mm_got.weight, minimock.Diff(*mm_want_ptrs.weight, mm_got.weight))
			}

			if mm_want_ptrs.pack != nil && !minimock.Equal(*mm_want_ptrs.pack, mm_got.pack) {
				mmValidatePackage.t.Errorf("InputValidator.ValidatePackage got unexpected parameter pack, want: %#v, got: %#v%s\n", *mm_want_ptrs.pack, mm_got.pack, minimock.Diff(*mm_want_ptrs.pack, mm_got.pack))
			}

			if mm_want_ptrs.loadedPackages != nil && !minimock.Equal(*mm_want_ptrs.loadedPackages, mm_got.loadedPackages) {
				mmValidatePackage.t.Errorf("InputValidator.ValidatePackage got unexpected parameter loadedPackages, want: %#v, got: %#v%s\n", *mm_want_ptrs.loadedPackages, mm_got.loadedPackages, minimock.Diff(*mm_want_ptrs.loadedPackages, mm_got.loadedPackages))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidatePackage.t.Errorf("InputValidator.ValidatePackage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidatePackage.ValidatePackageMock.defaultExpectation.results
		if mm_results == nil {
			mmValidatePackage.t.Fatal("No results are set for the InputValidator.ValidatePackage")
		}
		return (*mm_results).err
	}
	if mmValidatePackage.funcValidatePackage != nil {
		return mmValidatePackage.funcValidatePackage(weight, pack, loadedPackages)
	}
	mmValidatePackage.t.Fatalf("Unexpected call to InputValidator.ValidatePackage. %v %v %v", weight, pack, loadedPackages)
	return
}

// ValidatePackageAfterCounter returns a count of finished InputValidator.ValidatePackage invocations
func (mmValidatePackage *InputValidator) ValidatePackageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidatePackage.afterValidatePackageCounter)
}

// ValidatePackageBeforeCounter returns a count of InputValidator.ValidatePackage invocations
func (mmValidatePackage *InputValidator) ValidatePackageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidatePackage.beforeValidatePackageCounter)
}

// Calls returns a list of arguments used in each call to InputValidator.ValidatePackage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidatePackage *mInputValidatorValidatePackage) Calls() []*InputValidatorValidatePackageParams {
	mmValidatePackage.mutex.RLock()

	argCopy := make([]*InputValidatorValidatePackageParams, len(mmValidatePackage.callArgs))
	copy(argCopy, mmValidatePackage.callArgs)

	mmValidatePackage.mutex.RUnlock()

	return argCopy
}

// MinimockValidatePackageDone returns true if the count of the ValidatePackage invocations corresponds
// the number of defined expectations
func (m *InputValidator) MinimockValidatePackageDone() bool {
	if m.ValidatePackageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValidatePackageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValidatePackageMock.invocationsDone()
}

// MinimockValidatePackageInspect logs each unmet expectation
func (m *InputValidator) MinimockValidatePackageInspect() {
	for _, e := range m.ValidatePackageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InputValidator.ValidatePackage with params: %#v", *e.params)
		}
	}

	afterValidatePackageCounter := mm_atomic.LoadUint64(&m.afterValidatePackageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValidatePackageMock.defaultExpectation != nil && afterValidatePackageCounter < 1 {
		if m.ValidatePackageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InputValidator.ValidatePackage")
		} else {
			m.t.Errorf("Expected call to InputValidator.ValidatePackage with params: %#v", *m.ValidatePackageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidatePackage != nil && afterValidatePackageCounter < 1 {
		m.t.Error("Expected call to InputValidator.ValidatePackage")
	}

	if !m.ValidatePackageMock.invocationsDone() && afterValidatePackageCounter > 0 {
		m.t.Errorf("Expected %d calls to InputValidator.ValidatePackage but found %d calls",
			mm_atomic.LoadUint64(&m.ValidatePackageMock.expectedInvocations), afterValidatePackageCounter)
	}
}

type mInputValidatorValidateReturnFromClient struct {
	optional           bool
	mock               *InputValidator
	defaultExpectation *InputValidatorValidateReturnFromClientExpectation
	expectations       []*InputValidatorValidateReturnFromClientExpectation

	callArgs []*InputValidatorValidateReturnFromClientParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// InputValidatorValidateReturnFromClientExpectation specifies expectation struct of the InputValidator.ValidateReturnFromClient
type InputValidatorValidateReturnFromClientExpectation struct {
	mock      *InputValidator
	params    *InputValidatorValidateReturnFromClientParams
	paramPtrs *InputValidatorValidateReturnFromClientParamPtrs
	results   *InputValidatorValidateReturnFromClientResults
	Counter   uint64
}

// InputValidatorValidateReturnFromClientParams contains parameters of the InputValidator.ValidateReturnFromClient
type InputValidatorValidateReturnFromClientParams struct {
	orderID  string
	clientID string
}

// InputValidatorValidateReturnFromClientParamPtrs contains pointers to parameters of the InputValidator.ValidateReturnFromClient
type InputValidatorValidateReturnFromClientParamPtrs struct {
	orderID  *string
	clientID *string
}

// InputValidatorValidateReturnFromClientResults contains results of the InputValidator.ValidateReturnFromClient
type InputValidatorValidateReturnFromClientResults struct {
	o1  model.OrderID
	c1  model.ClientID
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidateReturnFromClient *mInputValidatorValidateReturnFromClient) Optional() *mInputValidatorValidateReturnFromClient {
	mmValidateReturnFromClient.optional = true
	return mmValidateReturnFromClient
}

// Expect sets up expected params for InputValidator.ValidateReturnFromClient
func (mmValidateReturnFromClient *mInputValidatorValidateReturnFromClient) Expect(orderID string, clientID string) *mInputValidatorValidateReturnFromClient {
	if mmValidateReturnFromClient.mock.funcValidateReturnFromClient != nil {
		mmValidateReturnFromClient.mock.t.Fatalf("InputValidator.ValidateReturnFromClient mock is already set by Set")
	}

	if mmValidateReturnFromClient.defaultExpectation == nil {
		mmValidateReturnFromClient.defaultExpectation = &InputValidatorValidateReturnFromClientExpectation{}
	}

	if mmValidateReturnFromClient.defaultExpectation.paramPtrs != nil {
		mmValidateReturnFromClient.mock.t.Fatalf("InputValidator.ValidateReturnFromClient mock is already set by ExpectParams functions")
	}

	mmValidateReturnFromClient.defaultExpectation.params = &InputValidatorValidateReturnFromClientParams{orderID, clientID}
	for _, e := range mmValidateReturnFromClient.expectations {
		if minimock.Equal(e.params, mmValidateReturnFromClient.defaultExpectation.params) {
			mmValidateReturnFromClient.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidateReturnFromClient.defaultExpectation.params)
		}
	}

	return mmValidateReturnFromClient
}

// ExpectOrderIDParam1 sets up expected param orderID for InputValidator.ValidateReturnFromClient
func (mmValidateReturnFromClient *mInputValidatorValidateReturnFromClient) ExpectOrderIDParam1(orderID string) *mInputValidatorValidateReturnFromClient {
	if mmValidateReturnFromClient.mock.funcValidateReturnFromClient != nil {
		mmValidateReturnFromClient.mock.t.Fatalf("InputValidator.ValidateReturnFromClient mock is already set by Set")
	}

	if mmValidateReturnFromClient.defaultExpectation == nil {
		mmValidateReturnFromClient.defaultExpectation = &InputValidatorValidateReturnFromClientExpectation{}
	}

	if mmValidateReturnFromClient.defaultExpectation.params != nil {
		mmValidateReturnFromClient.mock.t.Fatalf("InputValidator.ValidateReturnFromClient mock is already set by Expect")
	}

	if mmValidateReturnFromClient.defaultExpectation.paramPtrs == nil {
		mmValidateReturnFromClient.defaultExpectation.paramPtrs = &InputValidatorValidateReturnFromClientParamPtrs{}
	}
	mmValidateReturnFromClient.defaultExpectation.paramPtrs.orderID = &orderID

	return mmValidateReturnFromClient
}

// ExpectClientIDParam2 sets up expected param clientID for InputValidator.ValidateReturnFromClient
func (mmValidateReturnFromClient *mInputValidatorValidateReturnFromClient) ExpectClientIDParam2(clientID string) *mInputValidatorValidateReturnFromClient {
	if mmValidateReturnFromClient.mock.funcValidateReturnFromClient != nil {
		mmValidateReturnFromClient.mock.t.Fatalf("InputValidator.ValidateReturnFromClient mock is already set by Set")
	}

	if mmValidateReturnFromClient.defaultExpectation == nil {
		mmValidateReturnFromClient.defaultExpectation = &InputValidatorValidateReturnFromClientExpectation{}
	}

	if mmValidateReturnFromClient.defaultExpectation.params != nil {
		mmValidateReturnFromClient.mock.t.Fatalf("InputValidator.ValidateReturnFromClient mock is already set by Expect")
	}

	if mmValidateReturnFromClient.defaultExpectation.paramPtrs == nil {
		mmValidateReturnFromClient.defaultExpectation.paramPtrs = &InputValidatorValidateReturnFromClientParamPtrs{}
	}
	mmValidateReturnFromClient.defaultExpectation.paramPtrs.clientID = &clientID

	return mmValidateReturnFromClient
}

// Inspect accepts an inspector function that has same arguments as the InputValidator.ValidateReturnFromClient
func (mmValidateReturnFromClient *mInputValidatorValidateReturnFromClient) Inspect(f func(orderID string, clientID string)) *mInputValidatorValidateReturnFromClient {
	if mmValidateReturnFromClient.mock.inspectFuncValidateReturnFromClient != nil {
		mmValidateReturnFromClient.mock.t.Fatalf("Inspect function is already set for InputValidator.ValidateReturnFromClient")
	}

	mmValidateReturnFromClient.mock.inspectFuncValidateReturnFromClient = f

	return mmValidateReturnFromClient
}

// Return sets up results that will be returned by InputValidator.ValidateReturnFromClient
func (mmValidateReturnFromClient *mInputValidatorValidateReturnFromClient) Return(o1 model.OrderID, c1 model.ClientID, err error) *InputValidator {
	if mmValidateReturnFromClient.mock.funcValidateReturnFromClient != nil {
		mmValidateReturnFromClient.mock.t.Fatalf("InputValidator.ValidateReturnFromClient mock is already set by Set")
	}

	if mmValidateReturnFromClient.defaultExpectation == nil {
		mmValidateReturnFromClient.defaultExpectation = &InputValidatorValidateReturnFromClientExpectation{mock: mmValidateReturnFromClient.mock}
	}
	mmValidateReturnFromClient.defaultExpectation.results = &InputValidatorValidateReturnFromClientResults{o1, c1, err}
	return mmValidateReturnFromClient.mock
}

// Set uses given function f to mock the InputValidator.ValidateReturnFromClient method
func (mmValidateReturnFromClient *mInputValidatorValidateReturnFromClient) Set(f func(orderID string, clientID string) (o1 model.OrderID, c1 model.ClientID, err error)) *InputValidator {
	if mmValidateReturnFromClient.defaultExpectation != nil {
		mmValidateReturnFromClient.mock.t.Fatalf("Default expectation is already set for the InputValidator.ValidateReturnFromClient method")
	}

	if len(mmValidateReturnFromClient.expectations) > 0 {
		mmValidateReturnFromClient.mock.t.Fatalf("Some expectations are already set for the InputValidator.ValidateReturnFromClient method")
	}

	mmValidateReturnFromClient.mock.funcValidateReturnFromClient = f
	return mmValidateReturnFromClient.mock
}

// When sets expectation for the InputValidator.ValidateReturnFromClient which will trigger the result defined by the following
// Then helper
func (mmValidateReturnFromClient *mInputValidatorValidateReturnFromClient) When(orderID string, clientID string) *InputValidatorValidateReturnFromClientExpectation {
	if mmValidateReturnFromClient.mock.funcValidateReturnFromClient != nil {
		mmValidateReturnFromClient.mock.t.Fatalf("InputValidator.ValidateReturnFromClient mock is already set by Set")
	}

	expectation := &InputValidatorValidateReturnFromClientExpectation{
		mock:   mmValidateReturnFromClient.mock,
		params: &InputValidatorValidateReturnFromClientParams{orderID, clientID},
	}
	mmValidateReturnFromClient.expectations = append(mmValidateReturnFromClient.expectations, expectation)
	return expectation
}

// Then sets up InputValidator.ValidateReturnFromClient return parameters for the expectation previously defined by the When method
func (e *InputValidatorValidateReturnFromClientExpectation) Then(o1 model.OrderID, c1 model.ClientID, err error) *InputValidator {
	e.results = &InputValidatorValidateReturnFromClientResults{o1, c1, err}
	return e.mock
}

// Times sets number of times InputValidator.ValidateReturnFromClient should be invoked
func (mmValidateReturnFromClient *mInputValidatorValidateReturnFromClient) Times(n uint64) *mInputValidatorValidateReturnFromClient {
	if n == 0 {
		mmValidateReturnFromClient.mock.t.Fatalf("Times of InputValidator.ValidateReturnFromClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValidateReturnFromClient.expectedInvocations, n)
	return mmValidateReturnFromClient
}

func (mmValidateReturnFromClient *mInputValidatorValidateReturnFromClient) invocationsDone() bool {
	if len(mmValidateReturnFromClient.expectations) == 0 && mmValidateReturnFromClient.defaultExpectation == nil && mmValidateReturnFromClient.mock.funcValidateReturnFromClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValidateReturnFromClient.mock.afterValidateReturnFromClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValidateReturnFromClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ValidateReturnFromClient implements api.InputValidator
func (mmValidateReturnFromClient *InputValidator) ValidateReturnFromClient(orderID string, clientID string) (o1 model.OrderID, c1 model.ClientID, err error) {
	mm_atomic.AddUint64(&mmValidateReturnFromClient.beforeValidateReturnFromClientCounter, 1)
	defer mm_atomic.AddUint64(&mmValidateReturnFromClient.afterValidateReturnFromClientCounter, 1)

	if mmValidateReturnFromClient.inspectFuncValidateReturnFromClient != nil {
		mmValidateReturnFromClient.inspectFuncValidateReturnFromClient(orderID, clientID)
	}

	mm_params := InputValidatorValidateReturnFromClientParams{orderID, clientID}

	// Record call args
	mmValidateReturnFromClient.ValidateReturnFromClientMock.mutex.Lock()
	mmValidateReturnFromClient.ValidateReturnFromClientMock.callArgs = append(mmValidateReturnFromClient.ValidateReturnFromClientMock.callArgs, &mm_params)
	mmValidateReturnFromClient.ValidateReturnFromClientMock.mutex.Unlock()

	for _, e := range mmValidateReturnFromClient.ValidateReturnFromClientMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.c1, e.results.err
		}
	}

	if mmValidateReturnFromClient.ValidateReturnFromClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidateReturnFromClient.ValidateReturnFromClientMock.defaultExpectation.Counter, 1)
		mm_want := mmValidateReturnFromClient.ValidateReturnFromClientMock.defaultExpectation.params
		mm_want_ptrs := mmValidateReturnFromClient.ValidateReturnFromClientMock.defaultExpectation.paramPtrs

		mm_got := InputValidatorValidateReturnFromClientParams{orderID, clientID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmValidateReturnFromClient.t.Errorf("InputValidator.ValidateReturnFromClient got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmValidateReturnFromClient.t.Errorf("InputValidator.ValidateReturnFromClient got unexpected parameter clientID, want: %#v, got: %#v%s\n", *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidateReturnFromClient.t.Errorf("InputValidator.ValidateReturnFromClient got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidateReturnFromClient.ValidateReturnFromClientMock.defaultExpectation.results
		if mm_results == nil {
			mmValidateReturnFromClient.t.Fatal("No results are set for the InputValidator.ValidateReturnFromClient")
		}
		return (*mm_results).o1, (*mm_results).c1, (*mm_results).err
	}
	if mmValidateReturnFromClient.funcValidateReturnFromClient != nil {
		return mmValidateReturnFromClient.funcValidateReturnFromClient(orderID, clientID)
	}
	mmValidateReturnFromClient.t.Fatalf("Unexpected call to InputValidator.ValidateReturnFromClient. %v %v", orderID, clientID)
	return
}

// ValidateReturnFromClientAfterCounter returns a count of finished InputValidator.ValidateReturnFromClient invocations
func (mmValidateReturnFromClient *InputValidator) ValidateReturnFromClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateReturnFromClient.afterValidateReturnFromClientCounter)
}

// ValidateReturnFromClientBeforeCounter returns a count of InputValidator.ValidateReturnFromClient invocations
func (mmValidateReturnFromClient *InputValidator) ValidateReturnFromClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateReturnFromClient.beforeValidateReturnFromClientCounter)
}

// Calls returns a list of arguments used in each call to InputValidator.ValidateReturnFromClient.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidateReturnFromClient *mInputValidatorValidateReturnFromClient) Calls() []*InputValidatorValidateReturnFromClientParams {
	mmValidateReturnFromClient.mutex.RLock()

	argCopy := make([]*InputValidatorValidateReturnFromClientParams, len(mmValidateReturnFromClient.callArgs))
	copy(argCopy, mmValidateReturnFromClient.callArgs)

	mmValidateReturnFromClient.mutex.RUnlock()

	return argCopy
}

// MinimockValidateReturnFromClientDone returns true if the count of the ValidateReturnFromClient invocations corresponds
// the number of defined expectations
func (m *InputValidator) MinimockValidateReturnFromClientDone() bool {
	if m.ValidateReturnFromClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValidateReturnFromClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValidateReturnFromClientMock.invocationsDone()
}

// MinimockValidateReturnFromClientInspect logs each unmet expectation
func (m *InputValidator) MinimockValidateReturnFromClientInspect() {
	for _, e := range m.ValidateReturnFromClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InputValidator.ValidateReturnFromClient with params: %#v", *e.params)
		}
	}

	afterValidateReturnFromClientCounter := mm_atomic.LoadUint64(&m.afterValidateReturnFromClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValidateReturnFromClientMock.defaultExpectation != nil && afterValidateReturnFromClientCounter < 1 {
		if m.ValidateReturnFromClientMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InputValidator.ValidateReturnFromClient")
		} else {
			m.t.Errorf("Expected call to InputValidator.ValidateReturnFromClient with params: %#v", *m.ValidateReturnFromClientMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidateReturnFromClient != nil && afterValidateReturnFromClientCounter < 1 {
		m.t.Error("Expected call to InputValidator.ValidateReturnFromClient")
	}

	if !m.ValidateReturnFromClientMock.invocationsDone() && afterValidateReturnFromClientCounter > 0 {
		m.t.Errorf("Expected %d calls to InputValidator.ValidateReturnFromClient but found %d calls",
			mm_atomic.LoadUint64(&m.ValidateReturnFromClientMock.expectedInvocations), afterValidateReturnFromClientCounter)
	}
}

type mInputValidatorValidateReturnOrder struct {
	optional           bool
	mock               *InputValidator
	defaultExpectation *InputValidatorValidateReturnOrderExpectation
	expectations       []*InputValidatorValidateReturnOrderExpectation

	callArgs []*InputValidatorValidateReturnOrderParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// InputValidatorValidateReturnOrderExpectation specifies expectation struct of the InputValidator.ValidateReturnOrder
type InputValidatorValidateReturnOrderExpectation struct {
	mock      *InputValidator
	params    *InputValidatorValidateReturnOrderParams
	paramPtrs *InputValidatorValidateReturnOrderParamPtrs
	results   *InputValidatorValidateReturnOrderResults
	Counter   uint64
}

// InputValidatorValidateReturnOrderParams contains parameters of the InputValidator.ValidateReturnOrder
type InputValidatorValidateReturnOrderParams struct {
	orderID string
}

// InputValidatorValidateReturnOrderParamPtrs contains pointers to parameters of the InputValidator.ValidateReturnOrder
type InputValidatorValidateReturnOrderParamPtrs struct {
	orderID *string
}

// InputValidatorValidateReturnOrderResults contains results of the InputValidator.ValidateReturnOrder
type InputValidatorValidateReturnOrderResults struct {
	o1  model.OrderID
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmValidateReturnOrder *mInputValidatorValidateReturnOrder) Optional() *mInputValidatorValidateReturnOrder {
	mmValidateReturnOrder.optional = true
	return mmValidateReturnOrder
}

// Expect sets up expected params for InputValidator.ValidateReturnOrder
func (mmValidateReturnOrder *mInputValidatorValidateReturnOrder) Expect(orderID string) *mInputValidatorValidateReturnOrder {
	if mmValidateReturnOrder.mock.funcValidateReturnOrder != nil {
		mmValidateReturnOrder.mock.t.Fatalf("InputValidator.ValidateReturnOrder mock is already set by Set")
	}

	if mmValidateReturnOrder.defaultExpectation == nil {
		mmValidateReturnOrder.defaultExpectation = &InputValidatorValidateReturnOrderExpectation{}
	}

	if mmValidateReturnOrder.defaultExpectation.paramPtrs != nil {
		mmValidateReturnOrder.mock.t.Fatalf("InputValidator.ValidateReturnOrder mock is already set by ExpectParams functions")
	}

	mmValidateReturnOrder.defaultExpectation.params = &InputValidatorValidateReturnOrderParams{orderID}
	for _, e := range mmValidateReturnOrder.expectations {
		if minimock.Equal(e.params, mmValidateReturnOrder.defaultExpectation.params) {
			mmValidateReturnOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmValidateReturnOrder.defaultExpectation.params)
		}
	}

	return mmValidateReturnOrder
}

// ExpectOrderIDParam1 sets up expected param orderID for InputValidator.ValidateReturnOrder
func (mmValidateReturnOrder *mInputValidatorValidateReturnOrder) ExpectOrderIDParam1(orderID string) *mInputValidatorValidateReturnOrder {
	if mmValidateReturnOrder.mock.funcValidateReturnOrder != nil {
		mmValidateReturnOrder.mock.t.Fatalf("InputValidator.ValidateReturnOrder mock is already set by Set")
	}

	if mmValidateReturnOrder.defaultExpectation == nil {
		mmValidateReturnOrder.defaultExpectation = &InputValidatorValidateReturnOrderExpectation{}
	}

	if mmValidateReturnOrder.defaultExpectation.params != nil {
		mmValidateReturnOrder.mock.t.Fatalf("InputValidator.ValidateReturnOrder mock is already set by Expect")
	}

	if mmValidateReturnOrder.defaultExpectation.paramPtrs == nil {
		mmValidateReturnOrder.defaultExpectation.paramPtrs = &InputValidatorValidateReturnOrderParamPtrs{}
	}
	mmValidateReturnOrder.defaultExpectation.paramPtrs.orderID = &orderID

	return mmValidateReturnOrder
}

// Inspect accepts an inspector function that has same arguments as the InputValidator.ValidateReturnOrder
func (mmValidateReturnOrder *mInputValidatorValidateReturnOrder) Inspect(f func(orderID string)) *mInputValidatorValidateReturnOrder {
	if mmValidateReturnOrder.mock.inspectFuncValidateReturnOrder != nil {
		mmValidateReturnOrder.mock.t.Fatalf("Inspect function is already set for InputValidator.ValidateReturnOrder")
	}

	mmValidateReturnOrder.mock.inspectFuncValidateReturnOrder = f

	return mmValidateReturnOrder
}

// Return sets up results that will be returned by InputValidator.ValidateReturnOrder
func (mmValidateReturnOrder *mInputValidatorValidateReturnOrder) Return(o1 model.OrderID, err error) *InputValidator {
	if mmValidateReturnOrder.mock.funcValidateReturnOrder != nil {
		mmValidateReturnOrder.mock.t.Fatalf("InputValidator.ValidateReturnOrder mock is already set by Set")
	}

	if mmValidateReturnOrder.defaultExpectation == nil {
		mmValidateReturnOrder.defaultExpectation = &InputValidatorValidateReturnOrderExpectation{mock: mmValidateReturnOrder.mock}
	}
	mmValidateReturnOrder.defaultExpectation.results = &InputValidatorValidateReturnOrderResults{o1, err}
	return mmValidateReturnOrder.mock
}

// Set uses given function f to mock the InputValidator.ValidateReturnOrder method
func (mmValidateReturnOrder *mInputValidatorValidateReturnOrder) Set(f func(orderID string) (o1 model.OrderID, err error)) *InputValidator {
	if mmValidateReturnOrder.defaultExpectation != nil {
		mmValidateReturnOrder.mock.t.Fatalf("Default expectation is already set for the InputValidator.ValidateReturnOrder method")
	}

	if len(mmValidateReturnOrder.expectations) > 0 {
		mmValidateReturnOrder.mock.t.Fatalf("Some expectations are already set for the InputValidator.ValidateReturnOrder method")
	}

	mmValidateReturnOrder.mock.funcValidateReturnOrder = f
	return mmValidateReturnOrder.mock
}

// When sets expectation for the InputValidator.ValidateReturnOrder which will trigger the result defined by the following
// Then helper
func (mmValidateReturnOrder *mInputValidatorValidateReturnOrder) When(orderID string) *InputValidatorValidateReturnOrderExpectation {
	if mmValidateReturnOrder.mock.funcValidateReturnOrder != nil {
		mmValidateReturnOrder.mock.t.Fatalf("InputValidator.ValidateReturnOrder mock is already set by Set")
	}

	expectation := &InputValidatorValidateReturnOrderExpectation{
		mock:   mmValidateReturnOrder.mock,
		params: &InputValidatorValidateReturnOrderParams{orderID},
	}
	mmValidateReturnOrder.expectations = append(mmValidateReturnOrder.expectations, expectation)
	return expectation
}

// Then sets up InputValidator.ValidateReturnOrder return parameters for the expectation previously defined by the When method
func (e *InputValidatorValidateReturnOrderExpectation) Then(o1 model.OrderID, err error) *InputValidator {
	e.results = &InputValidatorValidateReturnOrderResults{o1, err}
	return e.mock
}

// Times sets number of times InputValidator.ValidateReturnOrder should be invoked
func (mmValidateReturnOrder *mInputValidatorValidateReturnOrder) Times(n uint64) *mInputValidatorValidateReturnOrder {
	if n == 0 {
		mmValidateReturnOrder.mock.t.Fatalf("Times of InputValidator.ValidateReturnOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmValidateReturnOrder.expectedInvocations, n)
	return mmValidateReturnOrder
}

func (mmValidateReturnOrder *mInputValidatorValidateReturnOrder) invocationsDone() bool {
	if len(mmValidateReturnOrder.expectations) == 0 && mmValidateReturnOrder.defaultExpectation == nil && mmValidateReturnOrder.mock.funcValidateReturnOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmValidateReturnOrder.mock.afterValidateReturnOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmValidateReturnOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ValidateReturnOrder implements api.InputValidator
func (mmValidateReturnOrder *InputValidator) ValidateReturnOrder(orderID string) (o1 model.OrderID, err error) {
	mm_atomic.AddUint64(&mmValidateReturnOrder.beforeValidateReturnOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmValidateReturnOrder.afterValidateReturnOrderCounter, 1)

	if mmValidateReturnOrder.inspectFuncValidateReturnOrder != nil {
		mmValidateReturnOrder.inspectFuncValidateReturnOrder(orderID)
	}

	mm_params := InputValidatorValidateReturnOrderParams{orderID}

	// Record call args
	mmValidateReturnOrder.ValidateReturnOrderMock.mutex.Lock()
	mmValidateReturnOrder.ValidateReturnOrderMock.callArgs = append(mmValidateReturnOrder.ValidateReturnOrderMock.callArgs, &mm_params)
	mmValidateReturnOrder.ValidateReturnOrderMock.mutex.Unlock()

	for _, e := range mmValidateReturnOrder.ValidateReturnOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmValidateReturnOrder.ValidateReturnOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmValidateReturnOrder.ValidateReturnOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmValidateReturnOrder.ValidateReturnOrderMock.defaultExpectation.params
		mm_want_ptrs := mmValidateReturnOrder.ValidateReturnOrderMock.defaultExpectation.paramPtrs

		mm_got := InputValidatorValidateReturnOrderParams{orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmValidateReturnOrder.t.Errorf("InputValidator.ValidateReturnOrder got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmValidateReturnOrder.t.Errorf("InputValidator.ValidateReturnOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmValidateReturnOrder.ValidateReturnOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmValidateReturnOrder.t.Fatal("No results are set for the InputValidator.ValidateReturnOrder")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmValidateReturnOrder.funcValidateReturnOrder != nil {
		return mmValidateReturnOrder.funcValidateReturnOrder(orderID)
	}
	mmValidateReturnOrder.t.Fatalf("Unexpected call to InputValidator.ValidateReturnOrder. %v", orderID)
	return
}

// ValidateReturnOrderAfterCounter returns a count of finished InputValidator.ValidateReturnOrder invocations
func (mmValidateReturnOrder *InputValidator) ValidateReturnOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateReturnOrder.afterValidateReturnOrderCounter)
}

// ValidateReturnOrderBeforeCounter returns a count of InputValidator.ValidateReturnOrder invocations
func (mmValidateReturnOrder *InputValidator) ValidateReturnOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmValidateReturnOrder.beforeValidateReturnOrderCounter)
}

// Calls returns a list of arguments used in each call to InputValidator.ValidateReturnOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmValidateReturnOrder *mInputValidatorValidateReturnOrder) Calls() []*InputValidatorValidateReturnOrderParams {
	mmValidateReturnOrder.mutex.RLock()

	argCopy := make([]*InputValidatorValidateReturnOrderParams, len(mmValidateReturnOrder.callArgs))
	copy(argCopy, mmValidateReturnOrder.callArgs)

	mmValidateReturnOrder.mutex.RUnlock()

	return argCopy
}

// MinimockValidateReturnOrderDone returns true if the count of the ValidateReturnOrder invocations corresponds
// the number of defined expectations
func (m *InputValidator) MinimockValidateReturnOrderDone() bool {
	if m.ValidateReturnOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ValidateReturnOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ValidateReturnOrderMock.invocationsDone()
}

// MinimockValidateReturnOrderInspect logs each unmet expectation
func (m *InputValidator) MinimockValidateReturnOrderInspect() {
	for _, e := range m.ValidateReturnOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InputValidator.ValidateReturnOrder with params: %#v", *e.params)
		}
	}

	afterValidateReturnOrderCounter := mm_atomic.LoadUint64(&m.afterValidateReturnOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ValidateReturnOrderMock.defaultExpectation != nil && afterValidateReturnOrderCounter < 1 {
		if m.ValidateReturnOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InputValidator.ValidateReturnOrder")
		} else {
			m.t.Errorf("Expected call to InputValidator.ValidateReturnOrder with params: %#v", *m.ValidateReturnOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcValidateReturnOrder != nil && afterValidateReturnOrderCounter < 1 {
		m.t.Error("Expected call to InputValidator.ValidateReturnOrder")
	}

	if !m.ValidateReturnOrderMock.invocationsDone() && afterValidateReturnOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to InputValidator.ValidateReturnOrder but found %d calls",
			mm_atomic.LoadUint64(&m.ValidateReturnOrderMock.expectedInvocations), afterValidateReturnOrderCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *InputValidator) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockValidateGetOrderFromCourierInspect()

			m.MinimockValidateGiveOrderInspect()

			m.MinimockValidateListOrdersInspect()

			m.MinimockValidateListReturnsInspect()

			m.MinimockValidatePackageInspect()

			m.MinimockValidateReturnFromClientInspect()

			m.MinimockValidateReturnOrderInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *InputValidator) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *InputValidator) minimockDone() bool {
	done := true
	return done &&
		m.MinimockValidateGetOrderFromCourierDone() &&
		m.MinimockValidateGiveOrderDone() &&
		m.MinimockValidateListOrdersDone() &&
		m.MinimockValidateListReturnsDone() &&
		m.MinimockValidatePackageDone() &&
		m.MinimockValidateReturnFromClientDone() &&
		m.MinimockValidateReturnOrderDone()
}
