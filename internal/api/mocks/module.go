// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package mocks

//go:generate minimock -i HomeWork_1/internal/api.OrderModule -o module.go -n Module -p mocks

import (
	"HomeWork_1/internal/model"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// Module implements api.OrderModule
type Module struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetOrderFromCourier          func(ctx context.Context, order *model.Order) (err error)
	inspectFuncGetOrderFromCourier   func(ctx context.Context, order *model.Order)
	afterGetOrderFromCourierCounter  uint64
	beforeGetOrderFromCourierCounter uint64
	GetOrderFromCourierMock          mModuleGetOrderFromCourier

	funcGiveOrder          func(ctx context.Context, orders []model.OrderID) (i1 int, err error)
	inspectFuncGiveOrder   func(ctx context.Context, orders []model.OrderID)
	afterGiveOrderCounter  uint64
	beforeGiveOrderCounter uint64
	GiveOrderMock          mModuleGiveOrder

	funcGiveOrderWithNewPackage          func(ctx context.Context, orders []model.OrderID, pack model.PackageType) (i1 int, err error)
	inspectFuncGiveOrderWithNewPackage   func(ctx context.Context, orders []model.OrderID, pack model.PackageType)
	afterGiveOrderWithNewPackageCounter  uint64
	beforeGiveOrderWithNewPackageCounter uint64
	GiveOrderWithNewPackageMock          mModuleGiveOrderWithNewPackage

	funcListOrders          func(ctx context.Context, clientID model.ClientID, action int) (oa1 []model.Order, m1 map[model.PackageType]model.Package, err error)
	inspectFuncListOrders   func(ctx context.Context, clientID model.ClientID, action int)
	afterListOrdersCounter  uint64
	beforeListOrdersCounter uint64
	ListOrdersMock          mModuleListOrders

	funcListReturns          func(ctx context.Context) (oa1 []model.Order, m1 map[model.PackageType]model.Package, err error)
	inspectFuncListReturns   func(ctx context.Context)
	afterListReturnsCounter  uint64
	beforeListReturnsCounter uint64
	ListReturnsMock          mModuleListReturns

	funcLoadPackagesToCheck          func(ctx context.Context) (pa1 []model.Package, err error)
	inspectFuncLoadPackagesToCheck   func(ctx context.Context)
	afterLoadPackagesToCheckCounter  uint64
	beforeLoadPackagesToCheckCounter uint64
	LoadPackagesToCheckMock          mModuleLoadPackagesToCheck

	funcReturnFromClient          func(ctx context.Context, orderID model.OrderID, clientID model.ClientID) (err error)
	inspectFuncReturnFromClient   func(ctx context.Context, orderID model.OrderID, clientID model.ClientID)
	afterReturnFromClientCounter  uint64
	beforeReturnFromClientCounter uint64
	ReturnFromClientMock          mModuleReturnFromClient

	funcReturnOrder          func(ctx context.Context, orderID model.OrderID) (err error)
	inspectFuncReturnOrder   func(ctx context.Context, orderID model.OrderID)
	afterReturnOrderCounter  uint64
	beforeReturnOrderCounter uint64
	ReturnOrderMock          mModuleReturnOrder
}

// NewModule returns a mock for api.OrderModule
func NewModule(t minimock.Tester) *Module {
	m := &Module{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetOrderFromCourierMock = mModuleGetOrderFromCourier{mock: m}
	m.GetOrderFromCourierMock.callArgs = []*ModuleGetOrderFromCourierParams{}

	m.GiveOrderMock = mModuleGiveOrder{mock: m}
	m.GiveOrderMock.callArgs = []*ModuleGiveOrderParams{}

	m.GiveOrderWithNewPackageMock = mModuleGiveOrderWithNewPackage{mock: m}
	m.GiveOrderWithNewPackageMock.callArgs = []*ModuleGiveOrderWithNewPackageParams{}

	m.ListOrdersMock = mModuleListOrders{mock: m}
	m.ListOrdersMock.callArgs = []*ModuleListOrdersParams{}

	m.ListReturnsMock = mModuleListReturns{mock: m}
	m.ListReturnsMock.callArgs = []*ModuleListReturnsParams{}

	m.LoadPackagesToCheckMock = mModuleLoadPackagesToCheck{mock: m}
	m.LoadPackagesToCheckMock.callArgs = []*ModuleLoadPackagesToCheckParams{}

	m.ReturnFromClientMock = mModuleReturnFromClient{mock: m}
	m.ReturnFromClientMock.callArgs = []*ModuleReturnFromClientParams{}

	m.ReturnOrderMock = mModuleReturnOrder{mock: m}
	m.ReturnOrderMock.callArgs = []*ModuleReturnOrderParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mModuleGetOrderFromCourier struct {
	optional           bool
	mock               *Module
	defaultExpectation *ModuleGetOrderFromCourierExpectation
	expectations       []*ModuleGetOrderFromCourierExpectation

	callArgs []*ModuleGetOrderFromCourierParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ModuleGetOrderFromCourierExpectation specifies expectation struct of the OrderModule.GetOrderFromCourier
type ModuleGetOrderFromCourierExpectation struct {
	mock      *Module
	params    *ModuleGetOrderFromCourierParams
	paramPtrs *ModuleGetOrderFromCourierParamPtrs
	results   *ModuleGetOrderFromCourierResults
	Counter   uint64
}

// ModuleGetOrderFromCourierParams contains parameters of the OrderModule.GetOrderFromCourier
type ModuleGetOrderFromCourierParams struct {
	ctx   context.Context
	order *model.Order
}

// ModuleGetOrderFromCourierParamPtrs contains pointers to parameters of the OrderModule.GetOrderFromCourier
type ModuleGetOrderFromCourierParamPtrs struct {
	ctx   *context.Context
	order **model.Order
}

// ModuleGetOrderFromCourierResults contains results of the OrderModule.GetOrderFromCourier
type ModuleGetOrderFromCourierResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrderFromCourier *mModuleGetOrderFromCourier) Optional() *mModuleGetOrderFromCourier {
	mmGetOrderFromCourier.optional = true
	return mmGetOrderFromCourier
}

// Expect sets up expected params for OrderModule.GetOrderFromCourier
func (mmGetOrderFromCourier *mModuleGetOrderFromCourier) Expect(ctx context.Context, order *model.Order) *mModuleGetOrderFromCourier {
	if mmGetOrderFromCourier.mock.funcGetOrderFromCourier != nil {
		mmGetOrderFromCourier.mock.t.Fatalf("Module.GetOrderFromCourier mock is already set by Set")
	}

	if mmGetOrderFromCourier.defaultExpectation == nil {
		mmGetOrderFromCourier.defaultExpectation = &ModuleGetOrderFromCourierExpectation{}
	}

	if mmGetOrderFromCourier.defaultExpectation.paramPtrs != nil {
		mmGetOrderFromCourier.mock.t.Fatalf("Module.GetOrderFromCourier mock is already set by ExpectParams functions")
	}

	mmGetOrderFromCourier.defaultExpectation.params = &ModuleGetOrderFromCourierParams{ctx, order}
	for _, e := range mmGetOrderFromCourier.expectations {
		if minimock.Equal(e.params, mmGetOrderFromCourier.defaultExpectation.params) {
			mmGetOrderFromCourier.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrderFromCourier.defaultExpectation.params)
		}
	}

	return mmGetOrderFromCourier
}

// ExpectCtxParam1 sets up expected param ctx for OrderModule.GetOrderFromCourier
func (mmGetOrderFromCourier *mModuleGetOrderFromCourier) ExpectCtxParam1(ctx context.Context) *mModuleGetOrderFromCourier {
	if mmGetOrderFromCourier.mock.funcGetOrderFromCourier != nil {
		mmGetOrderFromCourier.mock.t.Fatalf("Module.GetOrderFromCourier mock is already set by Set")
	}

	if mmGetOrderFromCourier.defaultExpectation == nil {
		mmGetOrderFromCourier.defaultExpectation = &ModuleGetOrderFromCourierExpectation{}
	}

	if mmGetOrderFromCourier.defaultExpectation.params != nil {
		mmGetOrderFromCourier.mock.t.Fatalf("Module.GetOrderFromCourier mock is already set by Expect")
	}

	if mmGetOrderFromCourier.defaultExpectation.paramPtrs == nil {
		mmGetOrderFromCourier.defaultExpectation.paramPtrs = &ModuleGetOrderFromCourierParamPtrs{}
	}
	mmGetOrderFromCourier.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetOrderFromCourier
}

// ExpectOrderParam2 sets up expected param order for OrderModule.GetOrderFromCourier
func (mmGetOrderFromCourier *mModuleGetOrderFromCourier) ExpectOrderParam2(order *model.Order) *mModuleGetOrderFromCourier {
	if mmGetOrderFromCourier.mock.funcGetOrderFromCourier != nil {
		mmGetOrderFromCourier.mock.t.Fatalf("Module.GetOrderFromCourier mock is already set by Set")
	}

	if mmGetOrderFromCourier.defaultExpectation == nil {
		mmGetOrderFromCourier.defaultExpectation = &ModuleGetOrderFromCourierExpectation{}
	}

	if mmGetOrderFromCourier.defaultExpectation.params != nil {
		mmGetOrderFromCourier.mock.t.Fatalf("Module.GetOrderFromCourier mock is already set by Expect")
	}

	if mmGetOrderFromCourier.defaultExpectation.paramPtrs == nil {
		mmGetOrderFromCourier.defaultExpectation.paramPtrs = &ModuleGetOrderFromCourierParamPtrs{}
	}
	mmGetOrderFromCourier.defaultExpectation.paramPtrs.order = &order

	return mmGetOrderFromCourier
}

// Inspect accepts an inspector function that has same arguments as the OrderModule.GetOrderFromCourier
func (mmGetOrderFromCourier *mModuleGetOrderFromCourier) Inspect(f func(ctx context.Context, order *model.Order)) *mModuleGetOrderFromCourier {
	if mmGetOrderFromCourier.mock.inspectFuncGetOrderFromCourier != nil {
		mmGetOrderFromCourier.mock.t.Fatalf("Inspect function is already set for Module.GetOrderFromCourier")
	}

	mmGetOrderFromCourier.mock.inspectFuncGetOrderFromCourier = f

	return mmGetOrderFromCourier
}

// Return sets up results that will be returned by OrderModule.GetOrderFromCourier
func (mmGetOrderFromCourier *mModuleGetOrderFromCourier) Return(err error) *Module {
	if mmGetOrderFromCourier.mock.funcGetOrderFromCourier != nil {
		mmGetOrderFromCourier.mock.t.Fatalf("Module.GetOrderFromCourier mock is already set by Set")
	}

	if mmGetOrderFromCourier.defaultExpectation == nil {
		mmGetOrderFromCourier.defaultExpectation = &ModuleGetOrderFromCourierExpectation{mock: mmGetOrderFromCourier.mock}
	}
	mmGetOrderFromCourier.defaultExpectation.results = &ModuleGetOrderFromCourierResults{err}
	return mmGetOrderFromCourier.mock
}

// Set uses given function f to mock the OrderModule.GetOrderFromCourier method
func (mmGetOrderFromCourier *mModuleGetOrderFromCourier) Set(f func(ctx context.Context, order *model.Order) (err error)) *Module {
	if mmGetOrderFromCourier.defaultExpectation != nil {
		mmGetOrderFromCourier.mock.t.Fatalf("Default expectation is already set for the OrderModule.GetOrderFromCourier method")
	}

	if len(mmGetOrderFromCourier.expectations) > 0 {
		mmGetOrderFromCourier.mock.t.Fatalf("Some expectations are already set for the OrderModule.GetOrderFromCourier method")
	}

	mmGetOrderFromCourier.mock.funcGetOrderFromCourier = f
	return mmGetOrderFromCourier.mock
}

// When sets expectation for the OrderModule.GetOrderFromCourier which will trigger the result defined by the following
// Then helper
func (mmGetOrderFromCourier *mModuleGetOrderFromCourier) When(ctx context.Context, order *model.Order) *ModuleGetOrderFromCourierExpectation {
	if mmGetOrderFromCourier.mock.funcGetOrderFromCourier != nil {
		mmGetOrderFromCourier.mock.t.Fatalf("Module.GetOrderFromCourier mock is already set by Set")
	}

	expectation := &ModuleGetOrderFromCourierExpectation{
		mock:   mmGetOrderFromCourier.mock,
		params: &ModuleGetOrderFromCourierParams{ctx, order},
	}
	mmGetOrderFromCourier.expectations = append(mmGetOrderFromCourier.expectations, expectation)
	return expectation
}

// Then sets up OrderModule.GetOrderFromCourier return parameters for the expectation previously defined by the When method
func (e *ModuleGetOrderFromCourierExpectation) Then(err error) *Module {
	e.results = &ModuleGetOrderFromCourierResults{err}
	return e.mock
}

// Times sets number of times OrderModule.GetOrderFromCourier should be invoked
func (mmGetOrderFromCourier *mModuleGetOrderFromCourier) Times(n uint64) *mModuleGetOrderFromCourier {
	if n == 0 {
		mmGetOrderFromCourier.mock.t.Fatalf("Times of Module.GetOrderFromCourier mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrderFromCourier.expectedInvocations, n)
	return mmGetOrderFromCourier
}

func (mmGetOrderFromCourier *mModuleGetOrderFromCourier) invocationsDone() bool {
	if len(mmGetOrderFromCourier.expectations) == 0 && mmGetOrderFromCourier.defaultExpectation == nil && mmGetOrderFromCourier.mock.funcGetOrderFromCourier == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrderFromCourier.mock.afterGetOrderFromCourierCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrderFromCourier.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrderFromCourier implements api.OrderModule
func (mmGetOrderFromCourier *Module) GetOrderFromCourier(ctx context.Context, order *model.Order) (err error) {
	mm_atomic.AddUint64(&mmGetOrderFromCourier.beforeGetOrderFromCourierCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrderFromCourier.afterGetOrderFromCourierCounter, 1)

	if mmGetOrderFromCourier.inspectFuncGetOrderFromCourier != nil {
		mmGetOrderFromCourier.inspectFuncGetOrderFromCourier(ctx, order)
	}

	mm_params := ModuleGetOrderFromCourierParams{ctx, order}

	// Record call args
	mmGetOrderFromCourier.GetOrderFromCourierMock.mutex.Lock()
	mmGetOrderFromCourier.GetOrderFromCourierMock.callArgs = append(mmGetOrderFromCourier.GetOrderFromCourierMock.callArgs, &mm_params)
	mmGetOrderFromCourier.GetOrderFromCourierMock.mutex.Unlock()

	for _, e := range mmGetOrderFromCourier.GetOrderFromCourierMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmGetOrderFromCourier.GetOrderFromCourierMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrderFromCourier.GetOrderFromCourierMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrderFromCourier.GetOrderFromCourierMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrderFromCourier.GetOrderFromCourierMock.defaultExpectation.paramPtrs

		mm_got := ModuleGetOrderFromCourierParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrderFromCourier.t.Errorf("Module.GetOrderFromCourier got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmGetOrderFromCourier.t.Errorf("Module.GetOrderFromCourier got unexpected parameter order, want: %#v, got: %#v%s\n", *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrderFromCourier.t.Errorf("Module.GetOrderFromCourier got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrderFromCourier.GetOrderFromCourierMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrderFromCourier.t.Fatal("No results are set for the Module.GetOrderFromCourier")
		}
		return (*mm_results).err
	}
	if mmGetOrderFromCourier.funcGetOrderFromCourier != nil {
		return mmGetOrderFromCourier.funcGetOrderFromCourier(ctx, order)
	}
	mmGetOrderFromCourier.t.Fatalf("Unexpected call to Module.GetOrderFromCourier. %v %v", ctx, order)
	return
}

// GetOrderFromCourierAfterCounter returns a count of finished Module.GetOrderFromCourier invocations
func (mmGetOrderFromCourier *Module) GetOrderFromCourierAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderFromCourier.afterGetOrderFromCourierCounter)
}

// GetOrderFromCourierBeforeCounter returns a count of Module.GetOrderFromCourier invocations
func (mmGetOrderFromCourier *Module) GetOrderFromCourierBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderFromCourier.beforeGetOrderFromCourierCounter)
}

// Calls returns a list of arguments used in each call to Module.GetOrderFromCourier.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrderFromCourier *mModuleGetOrderFromCourier) Calls() []*ModuleGetOrderFromCourierParams {
	mmGetOrderFromCourier.mutex.RLock()

	argCopy := make([]*ModuleGetOrderFromCourierParams, len(mmGetOrderFromCourier.callArgs))
	copy(argCopy, mmGetOrderFromCourier.callArgs)

	mmGetOrderFromCourier.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderFromCourierDone returns true if the count of the GetOrderFromCourier invocations corresponds
// the number of defined expectations
func (m *Module) MinimockGetOrderFromCourierDone() bool {
	if m.GetOrderFromCourierMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderFromCourierMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderFromCourierMock.invocationsDone()
}

// MinimockGetOrderFromCourierInspect logs each unmet expectation
func (m *Module) MinimockGetOrderFromCourierInspect() {
	for _, e := range m.GetOrderFromCourierMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Module.GetOrderFromCourier with params: %#v", *e.params)
		}
	}

	afterGetOrderFromCourierCounter := mm_atomic.LoadUint64(&m.afterGetOrderFromCourierCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderFromCourierMock.defaultExpectation != nil && afterGetOrderFromCourierCounter < 1 {
		if m.GetOrderFromCourierMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Module.GetOrderFromCourier")
		} else {
			m.t.Errorf("Expected call to Module.GetOrderFromCourier with params: %#v", *m.GetOrderFromCourierMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderFromCourier != nil && afterGetOrderFromCourierCounter < 1 {
		m.t.Error("Expected call to Module.GetOrderFromCourier")
	}

	if !m.GetOrderFromCourierMock.invocationsDone() && afterGetOrderFromCourierCounter > 0 {
		m.t.Errorf("Expected %d calls to Module.GetOrderFromCourier but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderFromCourierMock.expectedInvocations), afterGetOrderFromCourierCounter)
	}
}

type mModuleGiveOrder struct {
	optional           bool
	mock               *Module
	defaultExpectation *ModuleGiveOrderExpectation
	expectations       []*ModuleGiveOrderExpectation

	callArgs []*ModuleGiveOrderParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ModuleGiveOrderExpectation specifies expectation struct of the OrderModule.GiveOrder
type ModuleGiveOrderExpectation struct {
	mock      *Module
	params    *ModuleGiveOrderParams
	paramPtrs *ModuleGiveOrderParamPtrs
	results   *ModuleGiveOrderResults
	Counter   uint64
}

// ModuleGiveOrderParams contains parameters of the OrderModule.GiveOrder
type ModuleGiveOrderParams struct {
	ctx    context.Context
	orders []model.OrderID
}

// ModuleGiveOrderParamPtrs contains pointers to parameters of the OrderModule.GiveOrder
type ModuleGiveOrderParamPtrs struct {
	ctx    *context.Context
	orders *[]model.OrderID
}

// ModuleGiveOrderResults contains results of the OrderModule.GiveOrder
type ModuleGiveOrderResults struct {
	i1  int
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGiveOrder *mModuleGiveOrder) Optional() *mModuleGiveOrder {
	mmGiveOrder.optional = true
	return mmGiveOrder
}

// Expect sets up expected params for OrderModule.GiveOrder
func (mmGiveOrder *mModuleGiveOrder) Expect(ctx context.Context, orders []model.OrderID) *mModuleGiveOrder {
	if mmGiveOrder.mock.funcGiveOrder != nil {
		mmGiveOrder.mock.t.Fatalf("Module.GiveOrder mock is already set by Set")
	}

	if mmGiveOrder.defaultExpectation == nil {
		mmGiveOrder.defaultExpectation = &ModuleGiveOrderExpectation{}
	}

	if mmGiveOrder.defaultExpectation.paramPtrs != nil {
		mmGiveOrder.mock.t.Fatalf("Module.GiveOrder mock is already set by ExpectParams functions")
	}

	mmGiveOrder.defaultExpectation.params = &ModuleGiveOrderParams{ctx, orders}
	for _, e := range mmGiveOrder.expectations {
		if minimock.Equal(e.params, mmGiveOrder.defaultExpectation.params) {
			mmGiveOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGiveOrder.defaultExpectation.params)
		}
	}

	return mmGiveOrder
}

// ExpectCtxParam1 sets up expected param ctx for OrderModule.GiveOrder
func (mmGiveOrder *mModuleGiveOrder) ExpectCtxParam1(ctx context.Context) *mModuleGiveOrder {
	if mmGiveOrder.mock.funcGiveOrder != nil {
		mmGiveOrder.mock.t.Fatalf("Module.GiveOrder mock is already set by Set")
	}

	if mmGiveOrder.defaultExpectation == nil {
		mmGiveOrder.defaultExpectation = &ModuleGiveOrderExpectation{}
	}

	if mmGiveOrder.defaultExpectation.params != nil {
		mmGiveOrder.mock.t.Fatalf("Module.GiveOrder mock is already set by Expect")
	}

	if mmGiveOrder.defaultExpectation.paramPtrs == nil {
		mmGiveOrder.defaultExpectation.paramPtrs = &ModuleGiveOrderParamPtrs{}
	}
	mmGiveOrder.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGiveOrder
}

// ExpectOrdersParam2 sets up expected param orders for OrderModule.GiveOrder
func (mmGiveOrder *mModuleGiveOrder) ExpectOrdersParam2(orders []model.OrderID) *mModuleGiveOrder {
	if mmGiveOrder.mock.funcGiveOrder != nil {
		mmGiveOrder.mock.t.Fatalf("Module.GiveOrder mock is already set by Set")
	}

	if mmGiveOrder.defaultExpectation == nil {
		mmGiveOrder.defaultExpectation = &ModuleGiveOrderExpectation{}
	}

	if mmGiveOrder.defaultExpectation.params != nil {
		mmGiveOrder.mock.t.Fatalf("Module.GiveOrder mock is already set by Expect")
	}

	if mmGiveOrder.defaultExpectation.paramPtrs == nil {
		mmGiveOrder.defaultExpectation.paramPtrs = &ModuleGiveOrderParamPtrs{}
	}
	mmGiveOrder.defaultExpectation.paramPtrs.orders = &orders

	return mmGiveOrder
}

// Inspect accepts an inspector function that has same arguments as the OrderModule.GiveOrder
func (mmGiveOrder *mModuleGiveOrder) Inspect(f func(ctx context.Context, orders []model.OrderID)) *mModuleGiveOrder {
	if mmGiveOrder.mock.inspectFuncGiveOrder != nil {
		mmGiveOrder.mock.t.Fatalf("Inspect function is already set for Module.GiveOrder")
	}

	mmGiveOrder.mock.inspectFuncGiveOrder = f

	return mmGiveOrder
}

// Return sets up results that will be returned by OrderModule.GiveOrder
func (mmGiveOrder *mModuleGiveOrder) Return(i1 int, err error) *Module {
	if mmGiveOrder.mock.funcGiveOrder != nil {
		mmGiveOrder.mock.t.Fatalf("Module.GiveOrder mock is already set by Set")
	}

	if mmGiveOrder.defaultExpectation == nil {
		mmGiveOrder.defaultExpectation = &ModuleGiveOrderExpectation{mock: mmGiveOrder.mock}
	}
	mmGiveOrder.defaultExpectation.results = &ModuleGiveOrderResults{i1, err}
	return mmGiveOrder.mock
}

// Set uses given function f to mock the OrderModule.GiveOrder method
func (mmGiveOrder *mModuleGiveOrder) Set(f func(ctx context.Context, orders []model.OrderID) (i1 int, err error)) *Module {
	if mmGiveOrder.defaultExpectation != nil {
		mmGiveOrder.mock.t.Fatalf("Default expectation is already set for the OrderModule.GiveOrder method")
	}

	if len(mmGiveOrder.expectations) > 0 {
		mmGiveOrder.mock.t.Fatalf("Some expectations are already set for the OrderModule.GiveOrder method")
	}

	mmGiveOrder.mock.funcGiveOrder = f
	return mmGiveOrder.mock
}

// When sets expectation for the OrderModule.GiveOrder which will trigger the result defined by the following
// Then helper
func (mmGiveOrder *mModuleGiveOrder) When(ctx context.Context, orders []model.OrderID) *ModuleGiveOrderExpectation {
	if mmGiveOrder.mock.funcGiveOrder != nil {
		mmGiveOrder.mock.t.Fatalf("Module.GiveOrder mock is already set by Set")
	}

	expectation := &ModuleGiveOrderExpectation{
		mock:   mmGiveOrder.mock,
		params: &ModuleGiveOrderParams{ctx, orders},
	}
	mmGiveOrder.expectations = append(mmGiveOrder.expectations, expectation)
	return expectation
}

// Then sets up OrderModule.GiveOrder return parameters for the expectation previously defined by the When method
func (e *ModuleGiveOrderExpectation) Then(i1 int, err error) *Module {
	e.results = &ModuleGiveOrderResults{i1, err}
	return e.mock
}

// Times sets number of times OrderModule.GiveOrder should be invoked
func (mmGiveOrder *mModuleGiveOrder) Times(n uint64) *mModuleGiveOrder {
	if n == 0 {
		mmGiveOrder.mock.t.Fatalf("Times of Module.GiveOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGiveOrder.expectedInvocations, n)
	return mmGiveOrder
}

func (mmGiveOrder *mModuleGiveOrder) invocationsDone() bool {
	if len(mmGiveOrder.expectations) == 0 && mmGiveOrder.defaultExpectation == nil && mmGiveOrder.mock.funcGiveOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGiveOrder.mock.afterGiveOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGiveOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GiveOrder implements api.OrderModule
func (mmGiveOrder *Module) GiveOrder(ctx context.Context, orders []model.OrderID) (i1 int, err error) {
	mm_atomic.AddUint64(&mmGiveOrder.beforeGiveOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmGiveOrder.afterGiveOrderCounter, 1)

	if mmGiveOrder.inspectFuncGiveOrder != nil {
		mmGiveOrder.inspectFuncGiveOrder(ctx, orders)
	}

	mm_params := ModuleGiveOrderParams{ctx, orders}

	// Record call args
	mmGiveOrder.GiveOrderMock.mutex.Lock()
	mmGiveOrder.GiveOrderMock.callArgs = append(mmGiveOrder.GiveOrderMock.callArgs, &mm_params)
	mmGiveOrder.GiveOrderMock.mutex.Unlock()

	for _, e := range mmGiveOrder.GiveOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGiveOrder.GiveOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGiveOrder.GiveOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmGiveOrder.GiveOrderMock.defaultExpectation.params
		mm_want_ptrs := mmGiveOrder.GiveOrderMock.defaultExpectation.paramPtrs

		mm_got := ModuleGiveOrderParams{ctx, orders}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGiveOrder.t.Errorf("Module.GiveOrder got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orders != nil && !minimock.Equal(*mm_want_ptrs.orders, mm_got.orders) {
				mmGiveOrder.t.Errorf("Module.GiveOrder got unexpected parameter orders, want: %#v, got: %#v%s\n", *mm_want_ptrs.orders, mm_got.orders, minimock.Diff(*mm_want_ptrs.orders, mm_got.orders))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGiveOrder.t.Errorf("Module.GiveOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGiveOrder.GiveOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmGiveOrder.t.Fatal("No results are set for the Module.GiveOrder")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGiveOrder.funcGiveOrder != nil {
		return mmGiveOrder.funcGiveOrder(ctx, orders)
	}
	mmGiveOrder.t.Fatalf("Unexpected call to Module.GiveOrder. %v %v", ctx, orders)
	return
}

// GiveOrderAfterCounter returns a count of finished Module.GiveOrder invocations
func (mmGiveOrder *Module) GiveOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGiveOrder.afterGiveOrderCounter)
}

// GiveOrderBeforeCounter returns a count of Module.GiveOrder invocations
func (mmGiveOrder *Module) GiveOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGiveOrder.beforeGiveOrderCounter)
}

// Calls returns a list of arguments used in each call to Module.GiveOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGiveOrder *mModuleGiveOrder) Calls() []*ModuleGiveOrderParams {
	mmGiveOrder.mutex.RLock()

	argCopy := make([]*ModuleGiveOrderParams, len(mmGiveOrder.callArgs))
	copy(argCopy, mmGiveOrder.callArgs)

	mmGiveOrder.mutex.RUnlock()

	return argCopy
}

// MinimockGiveOrderDone returns true if the count of the GiveOrder invocations corresponds
// the number of defined expectations
func (m *Module) MinimockGiveOrderDone() bool {
	if m.GiveOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GiveOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GiveOrderMock.invocationsDone()
}

// MinimockGiveOrderInspect logs each unmet expectation
func (m *Module) MinimockGiveOrderInspect() {
	for _, e := range m.GiveOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Module.GiveOrder with params: %#v", *e.params)
		}
	}

	afterGiveOrderCounter := mm_atomic.LoadUint64(&m.afterGiveOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GiveOrderMock.defaultExpectation != nil && afterGiveOrderCounter < 1 {
		if m.GiveOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Module.GiveOrder")
		} else {
			m.t.Errorf("Expected call to Module.GiveOrder with params: %#v", *m.GiveOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGiveOrder != nil && afterGiveOrderCounter < 1 {
		m.t.Error("Expected call to Module.GiveOrder")
	}

	if !m.GiveOrderMock.invocationsDone() && afterGiveOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to Module.GiveOrder but found %d calls",
			mm_atomic.LoadUint64(&m.GiveOrderMock.expectedInvocations), afterGiveOrderCounter)
	}
}

type mModuleGiveOrderWithNewPackage struct {
	optional           bool
	mock               *Module
	defaultExpectation *ModuleGiveOrderWithNewPackageExpectation
	expectations       []*ModuleGiveOrderWithNewPackageExpectation

	callArgs []*ModuleGiveOrderWithNewPackageParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ModuleGiveOrderWithNewPackageExpectation specifies expectation struct of the OrderModule.GiveOrderWithNewPackage
type ModuleGiveOrderWithNewPackageExpectation struct {
	mock      *Module
	params    *ModuleGiveOrderWithNewPackageParams
	paramPtrs *ModuleGiveOrderWithNewPackageParamPtrs
	results   *ModuleGiveOrderWithNewPackageResults
	Counter   uint64
}

// ModuleGiveOrderWithNewPackageParams contains parameters of the OrderModule.GiveOrderWithNewPackage
type ModuleGiveOrderWithNewPackageParams struct {
	ctx    context.Context
	orders []model.OrderID
	pack   model.PackageType
}

// ModuleGiveOrderWithNewPackageParamPtrs contains pointers to parameters of the OrderModule.GiveOrderWithNewPackage
type ModuleGiveOrderWithNewPackageParamPtrs struct {
	ctx    *context.Context
	orders *[]model.OrderID
	pack   *model.PackageType
}

// ModuleGiveOrderWithNewPackageResults contains results of the OrderModule.GiveOrderWithNewPackage
type ModuleGiveOrderWithNewPackageResults struct {
	i1  int
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGiveOrderWithNewPackage *mModuleGiveOrderWithNewPackage) Optional() *mModuleGiveOrderWithNewPackage {
	mmGiveOrderWithNewPackage.optional = true
	return mmGiveOrderWithNewPackage
}

// Expect sets up expected params for OrderModule.GiveOrderWithNewPackage
func (mmGiveOrderWithNewPackage *mModuleGiveOrderWithNewPackage) Expect(ctx context.Context, orders []model.OrderID, pack model.PackageType) *mModuleGiveOrderWithNewPackage {
	if mmGiveOrderWithNewPackage.mock.funcGiveOrderWithNewPackage != nil {
		mmGiveOrderWithNewPackage.mock.t.Fatalf("Module.GiveOrderWithNewPackage mock is already set by Set")
	}

	if mmGiveOrderWithNewPackage.defaultExpectation == nil {
		mmGiveOrderWithNewPackage.defaultExpectation = &ModuleGiveOrderWithNewPackageExpectation{}
	}

	if mmGiveOrderWithNewPackage.defaultExpectation.paramPtrs != nil {
		mmGiveOrderWithNewPackage.mock.t.Fatalf("Module.GiveOrderWithNewPackage mock is already set by ExpectParams functions")
	}

	mmGiveOrderWithNewPackage.defaultExpectation.params = &ModuleGiveOrderWithNewPackageParams{ctx, orders, pack}
	for _, e := range mmGiveOrderWithNewPackage.expectations {
		if minimock.Equal(e.params, mmGiveOrderWithNewPackage.defaultExpectation.params) {
			mmGiveOrderWithNewPackage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGiveOrderWithNewPackage.defaultExpectation.params)
		}
	}

	return mmGiveOrderWithNewPackage
}

// ExpectCtxParam1 sets up expected param ctx for OrderModule.GiveOrderWithNewPackage
func (mmGiveOrderWithNewPackage *mModuleGiveOrderWithNewPackage) ExpectCtxParam1(ctx context.Context) *mModuleGiveOrderWithNewPackage {
	if mmGiveOrderWithNewPackage.mock.funcGiveOrderWithNewPackage != nil {
		mmGiveOrderWithNewPackage.mock.t.Fatalf("Module.GiveOrderWithNewPackage mock is already set by Set")
	}

	if mmGiveOrderWithNewPackage.defaultExpectation == nil {
		mmGiveOrderWithNewPackage.defaultExpectation = &ModuleGiveOrderWithNewPackageExpectation{}
	}

	if mmGiveOrderWithNewPackage.defaultExpectation.params != nil {
		mmGiveOrderWithNewPackage.mock.t.Fatalf("Module.GiveOrderWithNewPackage mock is already set by Expect")
	}

	if mmGiveOrderWithNewPackage.defaultExpectation.paramPtrs == nil {
		mmGiveOrderWithNewPackage.defaultExpectation.paramPtrs = &ModuleGiveOrderWithNewPackageParamPtrs{}
	}
	mmGiveOrderWithNewPackage.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGiveOrderWithNewPackage
}

// ExpectOrdersParam2 sets up expected param orders for OrderModule.GiveOrderWithNewPackage
func (mmGiveOrderWithNewPackage *mModuleGiveOrderWithNewPackage) ExpectOrdersParam2(orders []model.OrderID) *mModuleGiveOrderWithNewPackage {
	if mmGiveOrderWithNewPackage.mock.funcGiveOrderWithNewPackage != nil {
		mmGiveOrderWithNewPackage.mock.t.Fatalf("Module.GiveOrderWithNewPackage mock is already set by Set")
	}

	if mmGiveOrderWithNewPackage.defaultExpectation == nil {
		mmGiveOrderWithNewPackage.defaultExpectation = &ModuleGiveOrderWithNewPackageExpectation{}
	}

	if mmGiveOrderWithNewPackage.defaultExpectation.params != nil {
		mmGiveOrderWithNewPackage.mock.t.Fatalf("Module.GiveOrderWithNewPackage mock is already set by Expect")
	}

	if mmGiveOrderWithNewPackage.defaultExpectation.paramPtrs == nil {
		mmGiveOrderWithNewPackage.defaultExpectation.paramPtrs = &ModuleGiveOrderWithNewPackageParamPtrs{}
	}
	mmGiveOrderWithNewPackage.defaultExpectation.paramPtrs.orders = &orders

	return mmGiveOrderWithNewPackage
}

// ExpectPackParam3 sets up expected param pack for OrderModule.GiveOrderWithNewPackage
func (mmGiveOrderWithNewPackage *mModuleGiveOrderWithNewPackage) ExpectPackParam3(pack model.PackageType) *mModuleGiveOrderWithNewPackage {
	if mmGiveOrderWithNewPackage.mock.funcGiveOrderWithNewPackage != nil {
		mmGiveOrderWithNewPackage.mock.t.Fatalf("Module.GiveOrderWithNewPackage mock is already set by Set")
	}

	if mmGiveOrderWithNewPackage.defaultExpectation == nil {
		mmGiveOrderWithNewPackage.defaultExpectation = &ModuleGiveOrderWithNewPackageExpectation{}
	}

	if mmGiveOrderWithNewPackage.defaultExpectation.params != nil {
		mmGiveOrderWithNewPackage.mock.t.Fatalf("Module.GiveOrderWithNewPackage mock is already set by Expect")
	}

	if mmGiveOrderWithNewPackage.defaultExpectation.paramPtrs == nil {
		mmGiveOrderWithNewPackage.defaultExpectation.paramPtrs = &ModuleGiveOrderWithNewPackageParamPtrs{}
	}
	mmGiveOrderWithNewPackage.defaultExpectation.paramPtrs.pack = &pack

	return mmGiveOrderWithNewPackage
}

// Inspect accepts an inspector function that has same arguments as the OrderModule.GiveOrderWithNewPackage
func (mmGiveOrderWithNewPackage *mModuleGiveOrderWithNewPackage) Inspect(f func(ctx context.Context, orders []model.OrderID, pack model.PackageType)) *mModuleGiveOrderWithNewPackage {
	if mmGiveOrderWithNewPackage.mock.inspectFuncGiveOrderWithNewPackage != nil {
		mmGiveOrderWithNewPackage.mock.t.Fatalf("Inspect function is already set for Module.GiveOrderWithNewPackage")
	}

	mmGiveOrderWithNewPackage.mock.inspectFuncGiveOrderWithNewPackage = f

	return mmGiveOrderWithNewPackage
}

// Return sets up results that will be returned by OrderModule.GiveOrderWithNewPackage
func (mmGiveOrderWithNewPackage *mModuleGiveOrderWithNewPackage) Return(i1 int, err error) *Module {
	if mmGiveOrderWithNewPackage.mock.funcGiveOrderWithNewPackage != nil {
		mmGiveOrderWithNewPackage.mock.t.Fatalf("Module.GiveOrderWithNewPackage mock is already set by Set")
	}

	if mmGiveOrderWithNewPackage.defaultExpectation == nil {
		mmGiveOrderWithNewPackage.defaultExpectation = &ModuleGiveOrderWithNewPackageExpectation{mock: mmGiveOrderWithNewPackage.mock}
	}
	mmGiveOrderWithNewPackage.defaultExpectation.results = &ModuleGiveOrderWithNewPackageResults{i1, err}
	return mmGiveOrderWithNewPackage.mock
}

// Set uses given function f to mock the OrderModule.GiveOrderWithNewPackage method
func (mmGiveOrderWithNewPackage *mModuleGiveOrderWithNewPackage) Set(f func(ctx context.Context, orders []model.OrderID, pack model.PackageType) (i1 int, err error)) *Module {
	if mmGiveOrderWithNewPackage.defaultExpectation != nil {
		mmGiveOrderWithNewPackage.mock.t.Fatalf("Default expectation is already set for the OrderModule.GiveOrderWithNewPackage method")
	}

	if len(mmGiveOrderWithNewPackage.expectations) > 0 {
		mmGiveOrderWithNewPackage.mock.t.Fatalf("Some expectations are already set for the OrderModule.GiveOrderWithNewPackage method")
	}

	mmGiveOrderWithNewPackage.mock.funcGiveOrderWithNewPackage = f
	return mmGiveOrderWithNewPackage.mock
}

// When sets expectation for the OrderModule.GiveOrderWithNewPackage which will trigger the result defined by the following
// Then helper
func (mmGiveOrderWithNewPackage *mModuleGiveOrderWithNewPackage) When(ctx context.Context, orders []model.OrderID, pack model.PackageType) *ModuleGiveOrderWithNewPackageExpectation {
	if mmGiveOrderWithNewPackage.mock.funcGiveOrderWithNewPackage != nil {
		mmGiveOrderWithNewPackage.mock.t.Fatalf("Module.GiveOrderWithNewPackage mock is already set by Set")
	}

	expectation := &ModuleGiveOrderWithNewPackageExpectation{
		mock:   mmGiveOrderWithNewPackage.mock,
		params: &ModuleGiveOrderWithNewPackageParams{ctx, orders, pack},
	}
	mmGiveOrderWithNewPackage.expectations = append(mmGiveOrderWithNewPackage.expectations, expectation)
	return expectation
}

// Then sets up OrderModule.GiveOrderWithNewPackage return parameters for the expectation previously defined by the When method
func (e *ModuleGiveOrderWithNewPackageExpectation) Then(i1 int, err error) *Module {
	e.results = &ModuleGiveOrderWithNewPackageResults{i1, err}
	return e.mock
}

// Times sets number of times OrderModule.GiveOrderWithNewPackage should be invoked
func (mmGiveOrderWithNewPackage *mModuleGiveOrderWithNewPackage) Times(n uint64) *mModuleGiveOrderWithNewPackage {
	if n == 0 {
		mmGiveOrderWithNewPackage.mock.t.Fatalf("Times of Module.GiveOrderWithNewPackage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGiveOrderWithNewPackage.expectedInvocations, n)
	return mmGiveOrderWithNewPackage
}

func (mmGiveOrderWithNewPackage *mModuleGiveOrderWithNewPackage) invocationsDone() bool {
	if len(mmGiveOrderWithNewPackage.expectations) == 0 && mmGiveOrderWithNewPackage.defaultExpectation == nil && mmGiveOrderWithNewPackage.mock.funcGiveOrderWithNewPackage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGiveOrderWithNewPackage.mock.afterGiveOrderWithNewPackageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGiveOrderWithNewPackage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GiveOrderWithNewPackage implements api.OrderModule
func (mmGiveOrderWithNewPackage *Module) GiveOrderWithNewPackage(ctx context.Context, orders []model.OrderID, pack model.PackageType) (i1 int, err error) {
	mm_atomic.AddUint64(&mmGiveOrderWithNewPackage.beforeGiveOrderWithNewPackageCounter, 1)
	defer mm_atomic.AddUint64(&mmGiveOrderWithNewPackage.afterGiveOrderWithNewPackageCounter, 1)

	if mmGiveOrderWithNewPackage.inspectFuncGiveOrderWithNewPackage != nil {
		mmGiveOrderWithNewPackage.inspectFuncGiveOrderWithNewPackage(ctx, orders, pack)
	}

	mm_params := ModuleGiveOrderWithNewPackageParams{ctx, orders, pack}

	// Record call args
	mmGiveOrderWithNewPackage.GiveOrderWithNewPackageMock.mutex.Lock()
	mmGiveOrderWithNewPackage.GiveOrderWithNewPackageMock.callArgs = append(mmGiveOrderWithNewPackage.GiveOrderWithNewPackageMock.callArgs, &mm_params)
	mmGiveOrderWithNewPackage.GiveOrderWithNewPackageMock.mutex.Unlock()

	for _, e := range mmGiveOrderWithNewPackage.GiveOrderWithNewPackageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGiveOrderWithNewPackage.GiveOrderWithNewPackageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGiveOrderWithNewPackage.GiveOrderWithNewPackageMock.defaultExpectation.Counter, 1)
		mm_want := mmGiveOrderWithNewPackage.GiveOrderWithNewPackageMock.defaultExpectation.params
		mm_want_ptrs := mmGiveOrderWithNewPackage.GiveOrderWithNewPackageMock.defaultExpectation.paramPtrs

		mm_got := ModuleGiveOrderWithNewPackageParams{ctx, orders, pack}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGiveOrderWithNewPackage.t.Errorf("Module.GiveOrderWithNewPackage got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orders != nil && !minimock.Equal(*mm_want_ptrs.orders, mm_got.orders) {
				mmGiveOrderWithNewPackage.t.Errorf("Module.GiveOrderWithNewPackage got unexpected parameter orders, want: %#v, got: %#v%s\n", *mm_want_ptrs.orders, mm_got.orders, minimock.Diff(*mm_want_ptrs.orders, mm_got.orders))
			}

			if mm_want_ptrs.pack != nil && !minimock.Equal(*mm_want_ptrs.pack, mm_got.pack) {
				mmGiveOrderWithNewPackage.t.Errorf("Module.GiveOrderWithNewPackage got unexpected parameter pack, want: %#v, got: %#v%s\n", *mm_want_ptrs.pack, mm_got.pack, minimock.Diff(*mm_want_ptrs.pack, mm_got.pack))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGiveOrderWithNewPackage.t.Errorf("Module.GiveOrderWithNewPackage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGiveOrderWithNewPackage.GiveOrderWithNewPackageMock.defaultExpectation.results
		if mm_results == nil {
			mmGiveOrderWithNewPackage.t.Fatal("No results are set for the Module.GiveOrderWithNewPackage")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGiveOrderWithNewPackage.funcGiveOrderWithNewPackage != nil {
		return mmGiveOrderWithNewPackage.funcGiveOrderWithNewPackage(ctx, orders, pack)
	}
	mmGiveOrderWithNewPackage.t.Fatalf("Unexpected call to Module.GiveOrderWithNewPackage. %v %v %v", ctx, orders, pack)
	return
}

// GiveOrderWithNewPackageAfterCounter returns a count of finished Module.GiveOrderWithNewPackage invocations
func (mmGiveOrderWithNewPackage *Module) GiveOrderWithNewPackageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGiveOrderWithNewPackage.afterGiveOrderWithNewPackageCounter)
}

// GiveOrderWithNewPackageBeforeCounter returns a count of Module.GiveOrderWithNewPackage invocations
func (mmGiveOrderWithNewPackage *Module) GiveOrderWithNewPackageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGiveOrderWithNewPackage.beforeGiveOrderWithNewPackageCounter)
}

// Calls returns a list of arguments used in each call to Module.GiveOrderWithNewPackage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGiveOrderWithNewPackage *mModuleGiveOrderWithNewPackage) Calls() []*ModuleGiveOrderWithNewPackageParams {
	mmGiveOrderWithNewPackage.mutex.RLock()

	argCopy := make([]*ModuleGiveOrderWithNewPackageParams, len(mmGiveOrderWithNewPackage.callArgs))
	copy(argCopy, mmGiveOrderWithNewPackage.callArgs)

	mmGiveOrderWithNewPackage.mutex.RUnlock()

	return argCopy
}

// MinimockGiveOrderWithNewPackageDone returns true if the count of the GiveOrderWithNewPackage invocations corresponds
// the number of defined expectations
func (m *Module) MinimockGiveOrderWithNewPackageDone() bool {
	if m.GiveOrderWithNewPackageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GiveOrderWithNewPackageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GiveOrderWithNewPackageMock.invocationsDone()
}

// MinimockGiveOrderWithNewPackageInspect logs each unmet expectation
func (m *Module) MinimockGiveOrderWithNewPackageInspect() {
	for _, e := range m.GiveOrderWithNewPackageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Module.GiveOrderWithNewPackage with params: %#v", *e.params)
		}
	}

	afterGiveOrderWithNewPackageCounter := mm_atomic.LoadUint64(&m.afterGiveOrderWithNewPackageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GiveOrderWithNewPackageMock.defaultExpectation != nil && afterGiveOrderWithNewPackageCounter < 1 {
		if m.GiveOrderWithNewPackageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Module.GiveOrderWithNewPackage")
		} else {
			m.t.Errorf("Expected call to Module.GiveOrderWithNewPackage with params: %#v", *m.GiveOrderWithNewPackageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGiveOrderWithNewPackage != nil && afterGiveOrderWithNewPackageCounter < 1 {
		m.t.Error("Expected call to Module.GiveOrderWithNewPackage")
	}

	if !m.GiveOrderWithNewPackageMock.invocationsDone() && afterGiveOrderWithNewPackageCounter > 0 {
		m.t.Errorf("Expected %d calls to Module.GiveOrderWithNewPackage but found %d calls",
			mm_atomic.LoadUint64(&m.GiveOrderWithNewPackageMock.expectedInvocations), afterGiveOrderWithNewPackageCounter)
	}
}

type mModuleListOrders struct {
	optional           bool
	mock               *Module
	defaultExpectation *ModuleListOrdersExpectation
	expectations       []*ModuleListOrdersExpectation

	callArgs []*ModuleListOrdersParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ModuleListOrdersExpectation specifies expectation struct of the OrderModule.ListOrders
type ModuleListOrdersExpectation struct {
	mock      *Module
	params    *ModuleListOrdersParams
	paramPtrs *ModuleListOrdersParamPtrs
	results   *ModuleListOrdersResults
	Counter   uint64
}

// ModuleListOrdersParams contains parameters of the OrderModule.ListOrders
type ModuleListOrdersParams struct {
	ctx      context.Context
	clientID model.ClientID
	action   int
}

// ModuleListOrdersParamPtrs contains pointers to parameters of the OrderModule.ListOrders
type ModuleListOrdersParamPtrs struct {
	ctx      *context.Context
	clientID *model.ClientID
	action   *int
}

// ModuleListOrdersResults contains results of the OrderModule.ListOrders
type ModuleListOrdersResults struct {
	oa1 []model.Order
	m1  map[model.PackageType]model.Package
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListOrders *mModuleListOrders) Optional() *mModuleListOrders {
	mmListOrders.optional = true
	return mmListOrders
}

// Expect sets up expected params for OrderModule.ListOrders
func (mmListOrders *mModuleListOrders) Expect(ctx context.Context, clientID model.ClientID, action int) *mModuleListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("Module.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &ModuleListOrdersExpectation{}
	}

	if mmListOrders.defaultExpectation.paramPtrs != nil {
		mmListOrders.mock.t.Fatalf("Module.ListOrders mock is already set by ExpectParams functions")
	}

	mmListOrders.defaultExpectation.params = &ModuleListOrdersParams{ctx, clientID, action}
	for _, e := range mmListOrders.expectations {
		if minimock.Equal(e.params, mmListOrders.defaultExpectation.params) {
			mmListOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListOrders.defaultExpectation.params)
		}
	}

	return mmListOrders
}

// ExpectCtxParam1 sets up expected param ctx for OrderModule.ListOrders
func (mmListOrders *mModuleListOrders) ExpectCtxParam1(ctx context.Context) *mModuleListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("Module.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &ModuleListOrdersExpectation{}
	}

	if mmListOrders.defaultExpectation.params != nil {
		mmListOrders.mock.t.Fatalf("Module.ListOrders mock is already set by Expect")
	}

	if mmListOrders.defaultExpectation.paramPtrs == nil {
		mmListOrders.defaultExpectation.paramPtrs = &ModuleListOrdersParamPtrs{}
	}
	mmListOrders.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListOrders
}

// ExpectClientIDParam2 sets up expected param clientID for OrderModule.ListOrders
func (mmListOrders *mModuleListOrders) ExpectClientIDParam2(clientID model.ClientID) *mModuleListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("Module.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &ModuleListOrdersExpectation{}
	}

	if mmListOrders.defaultExpectation.params != nil {
		mmListOrders.mock.t.Fatalf("Module.ListOrders mock is already set by Expect")
	}

	if mmListOrders.defaultExpectation.paramPtrs == nil {
		mmListOrders.defaultExpectation.paramPtrs = &ModuleListOrdersParamPtrs{}
	}
	mmListOrders.defaultExpectation.paramPtrs.clientID = &clientID

	return mmListOrders
}

// ExpectActionParam3 sets up expected param action for OrderModule.ListOrders
func (mmListOrders *mModuleListOrders) ExpectActionParam3(action int) *mModuleListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("Module.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &ModuleListOrdersExpectation{}
	}

	if mmListOrders.defaultExpectation.params != nil {
		mmListOrders.mock.t.Fatalf("Module.ListOrders mock is already set by Expect")
	}

	if mmListOrders.defaultExpectation.paramPtrs == nil {
		mmListOrders.defaultExpectation.paramPtrs = &ModuleListOrdersParamPtrs{}
	}
	mmListOrders.defaultExpectation.paramPtrs.action = &action

	return mmListOrders
}

// Inspect accepts an inspector function that has same arguments as the OrderModule.ListOrders
func (mmListOrders *mModuleListOrders) Inspect(f func(ctx context.Context, clientID model.ClientID, action int)) *mModuleListOrders {
	if mmListOrders.mock.inspectFuncListOrders != nil {
		mmListOrders.mock.t.Fatalf("Inspect function is already set for Module.ListOrders")
	}

	mmListOrders.mock.inspectFuncListOrders = f

	return mmListOrders
}

// Return sets up results that will be returned by OrderModule.ListOrders
func (mmListOrders *mModuleListOrders) Return(oa1 []model.Order, m1 map[model.PackageType]model.Package, err error) *Module {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("Module.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &ModuleListOrdersExpectation{mock: mmListOrders.mock}
	}
	mmListOrders.defaultExpectation.results = &ModuleListOrdersResults{oa1, m1, err}
	return mmListOrders.mock
}

// Set uses given function f to mock the OrderModule.ListOrders method
func (mmListOrders *mModuleListOrders) Set(f func(ctx context.Context, clientID model.ClientID, action int) (oa1 []model.Order, m1 map[model.PackageType]model.Package, err error)) *Module {
	if mmListOrders.defaultExpectation != nil {
		mmListOrders.mock.t.Fatalf("Default expectation is already set for the OrderModule.ListOrders method")
	}

	if len(mmListOrders.expectations) > 0 {
		mmListOrders.mock.t.Fatalf("Some expectations are already set for the OrderModule.ListOrders method")
	}

	mmListOrders.mock.funcListOrders = f
	return mmListOrders.mock
}

// When sets expectation for the OrderModule.ListOrders which will trigger the result defined by the following
// Then helper
func (mmListOrders *mModuleListOrders) When(ctx context.Context, clientID model.ClientID, action int) *ModuleListOrdersExpectation {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("Module.ListOrders mock is already set by Set")
	}

	expectation := &ModuleListOrdersExpectation{
		mock:   mmListOrders.mock,
		params: &ModuleListOrdersParams{ctx, clientID, action},
	}
	mmListOrders.expectations = append(mmListOrders.expectations, expectation)
	return expectation
}

// Then sets up OrderModule.ListOrders return parameters for the expectation previously defined by the When method
func (e *ModuleListOrdersExpectation) Then(oa1 []model.Order, m1 map[model.PackageType]model.Package, err error) *Module {
	e.results = &ModuleListOrdersResults{oa1, m1, err}
	return e.mock
}

// Times sets number of times OrderModule.ListOrders should be invoked
func (mmListOrders *mModuleListOrders) Times(n uint64) *mModuleListOrders {
	if n == 0 {
		mmListOrders.mock.t.Fatalf("Times of Module.ListOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListOrders.expectedInvocations, n)
	return mmListOrders
}

func (mmListOrders *mModuleListOrders) invocationsDone() bool {
	if len(mmListOrders.expectations) == 0 && mmListOrders.defaultExpectation == nil && mmListOrders.mock.funcListOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListOrders.mock.afterListOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListOrders implements api.OrderModule
func (mmListOrders *Module) ListOrders(ctx context.Context, clientID model.ClientID, action int) (oa1 []model.Order, m1 map[model.PackageType]model.Package, err error) {
	mm_atomic.AddUint64(&mmListOrders.beforeListOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmListOrders.afterListOrdersCounter, 1)

	if mmListOrders.inspectFuncListOrders != nil {
		mmListOrders.inspectFuncListOrders(ctx, clientID, action)
	}

	mm_params := ModuleListOrdersParams{ctx, clientID, action}

	// Record call args
	mmListOrders.ListOrdersMock.mutex.Lock()
	mmListOrders.ListOrdersMock.callArgs = append(mmListOrders.ListOrdersMock.callArgs, &mm_params)
	mmListOrders.ListOrdersMock.mutex.Unlock()

	for _, e := range mmListOrders.ListOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.m1, e.results.err
		}
	}

	if mmListOrders.ListOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListOrders.ListOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmListOrders.ListOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmListOrders.ListOrdersMock.defaultExpectation.paramPtrs

		mm_got := ModuleListOrdersParams{ctx, clientID, action}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListOrders.t.Errorf("Module.ListOrders got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmListOrders.t.Errorf("Module.ListOrders got unexpected parameter clientID, want: %#v, got: %#v%s\n", *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

			if mm_want_ptrs.action != nil && !minimock.Equal(*mm_want_ptrs.action, mm_got.action) {
				mmListOrders.t.Errorf("Module.ListOrders got unexpected parameter action, want: %#v, got: %#v%s\n", *mm_want_ptrs.action, mm_got.action, minimock.Diff(*mm_want_ptrs.action, mm_got.action))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListOrders.t.Errorf("Module.ListOrders got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListOrders.ListOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmListOrders.t.Fatal("No results are set for the Module.ListOrders")
		}
		return (*mm_results).oa1, (*mm_results).m1, (*mm_results).err
	}
	if mmListOrders.funcListOrders != nil {
		return mmListOrders.funcListOrders(ctx, clientID, action)
	}
	mmListOrders.t.Fatalf("Unexpected call to Module.ListOrders. %v %v %v", ctx, clientID, action)
	return
}

// ListOrdersAfterCounter returns a count of finished Module.ListOrders invocations
func (mmListOrders *Module) ListOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrders.afterListOrdersCounter)
}

// ListOrdersBeforeCounter returns a count of Module.ListOrders invocations
func (mmListOrders *Module) ListOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrders.beforeListOrdersCounter)
}

// Calls returns a list of arguments used in each call to Module.ListOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListOrders *mModuleListOrders) Calls() []*ModuleListOrdersParams {
	mmListOrders.mutex.RLock()

	argCopy := make([]*ModuleListOrdersParams, len(mmListOrders.callArgs))
	copy(argCopy, mmListOrders.callArgs)

	mmListOrders.mutex.RUnlock()

	return argCopy
}

// MinimockListOrdersDone returns true if the count of the ListOrders invocations corresponds
// the number of defined expectations
func (m *Module) MinimockListOrdersDone() bool {
	if m.ListOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListOrdersMock.invocationsDone()
}

// MinimockListOrdersInspect logs each unmet expectation
func (m *Module) MinimockListOrdersInspect() {
	for _, e := range m.ListOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Module.ListOrders with params: %#v", *e.params)
		}
	}

	afterListOrdersCounter := mm_atomic.LoadUint64(&m.afterListOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrdersMock.defaultExpectation != nil && afterListOrdersCounter < 1 {
		if m.ListOrdersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Module.ListOrders")
		} else {
			m.t.Errorf("Expected call to Module.ListOrders with params: %#v", *m.ListOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrders != nil && afterListOrdersCounter < 1 {
		m.t.Error("Expected call to Module.ListOrders")
	}

	if !m.ListOrdersMock.invocationsDone() && afterListOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to Module.ListOrders but found %d calls",
			mm_atomic.LoadUint64(&m.ListOrdersMock.expectedInvocations), afterListOrdersCounter)
	}
}

type mModuleListReturns struct {
	optional           bool
	mock               *Module
	defaultExpectation *ModuleListReturnsExpectation
	expectations       []*ModuleListReturnsExpectation

	callArgs []*ModuleListReturnsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ModuleListReturnsExpectation specifies expectation struct of the OrderModule.ListReturns
type ModuleListReturnsExpectation struct {
	mock      *Module
	params    *ModuleListReturnsParams
	paramPtrs *ModuleListReturnsParamPtrs
	results   *ModuleListReturnsResults
	Counter   uint64
}

// ModuleListReturnsParams contains parameters of the OrderModule.ListReturns
type ModuleListReturnsParams struct {
	ctx context.Context
}

// ModuleListReturnsParamPtrs contains pointers to parameters of the OrderModule.ListReturns
type ModuleListReturnsParamPtrs struct {
	ctx *context.Context
}

// ModuleListReturnsResults contains results of the OrderModule.ListReturns
type ModuleListReturnsResults struct {
	oa1 []model.Order
	m1  map[model.PackageType]model.Package
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListReturns *mModuleListReturns) Optional() *mModuleListReturns {
	mmListReturns.optional = true
	return mmListReturns
}

// Expect sets up expected params for OrderModule.ListReturns
func (mmListReturns *mModuleListReturns) Expect(ctx context.Context) *mModuleListReturns {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("Module.ListReturns mock is already set by Set")
	}

	if mmListReturns.defaultExpectation == nil {
		mmListReturns.defaultExpectation = &ModuleListReturnsExpectation{}
	}

	if mmListReturns.defaultExpectation.paramPtrs != nil {
		mmListReturns.mock.t.Fatalf("Module.ListReturns mock is already set by ExpectParams functions")
	}

	mmListReturns.defaultExpectation.params = &ModuleListReturnsParams{ctx}
	for _, e := range mmListReturns.expectations {
		if minimock.Equal(e.params, mmListReturns.defaultExpectation.params) {
			mmListReturns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListReturns.defaultExpectation.params)
		}
	}

	return mmListReturns
}

// ExpectCtxParam1 sets up expected param ctx for OrderModule.ListReturns
func (mmListReturns *mModuleListReturns) ExpectCtxParam1(ctx context.Context) *mModuleListReturns {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("Module.ListReturns mock is already set by Set")
	}

	if mmListReturns.defaultExpectation == nil {
		mmListReturns.defaultExpectation = &ModuleListReturnsExpectation{}
	}

	if mmListReturns.defaultExpectation.params != nil {
		mmListReturns.mock.t.Fatalf("Module.ListReturns mock is already set by Expect")
	}

	if mmListReturns.defaultExpectation.paramPtrs == nil {
		mmListReturns.defaultExpectation.paramPtrs = &ModuleListReturnsParamPtrs{}
	}
	mmListReturns.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListReturns
}

// Inspect accepts an inspector function that has same arguments as the OrderModule.ListReturns
func (mmListReturns *mModuleListReturns) Inspect(f func(ctx context.Context)) *mModuleListReturns {
	if mmListReturns.mock.inspectFuncListReturns != nil {
		mmListReturns.mock.t.Fatalf("Inspect function is already set for Module.ListReturns")
	}

	mmListReturns.mock.inspectFuncListReturns = f

	return mmListReturns
}

// Return sets up results that will be returned by OrderModule.ListReturns
func (mmListReturns *mModuleListReturns) Return(oa1 []model.Order, m1 map[model.PackageType]model.Package, err error) *Module {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("Module.ListReturns mock is already set by Set")
	}

	if mmListReturns.defaultExpectation == nil {
		mmListReturns.defaultExpectation = &ModuleListReturnsExpectation{mock: mmListReturns.mock}
	}
	mmListReturns.defaultExpectation.results = &ModuleListReturnsResults{oa1, m1, err}
	return mmListReturns.mock
}

// Set uses given function f to mock the OrderModule.ListReturns method
func (mmListReturns *mModuleListReturns) Set(f func(ctx context.Context) (oa1 []model.Order, m1 map[model.PackageType]model.Package, err error)) *Module {
	if mmListReturns.defaultExpectation != nil {
		mmListReturns.mock.t.Fatalf("Default expectation is already set for the OrderModule.ListReturns method")
	}

	if len(mmListReturns.expectations) > 0 {
		mmListReturns.mock.t.Fatalf("Some expectations are already set for the OrderModule.ListReturns method")
	}

	mmListReturns.mock.funcListReturns = f
	return mmListReturns.mock
}

// When sets expectation for the OrderModule.ListReturns which will trigger the result defined by the following
// Then helper
func (mmListReturns *mModuleListReturns) When(ctx context.Context) *ModuleListReturnsExpectation {
	if mmListReturns.mock.funcListReturns != nil {
		mmListReturns.mock.t.Fatalf("Module.ListReturns mock is already set by Set")
	}

	expectation := &ModuleListReturnsExpectation{
		mock:   mmListReturns.mock,
		params: &ModuleListReturnsParams{ctx},
	}
	mmListReturns.expectations = append(mmListReturns.expectations, expectation)
	return expectation
}

// Then sets up OrderModule.ListReturns return parameters for the expectation previously defined by the When method
func (e *ModuleListReturnsExpectation) Then(oa1 []model.Order, m1 map[model.PackageType]model.Package, err error) *Module {
	e.results = &ModuleListReturnsResults{oa1, m1, err}
	return e.mock
}

// Times sets number of times OrderModule.ListReturns should be invoked
func (mmListReturns *mModuleListReturns) Times(n uint64) *mModuleListReturns {
	if n == 0 {
		mmListReturns.mock.t.Fatalf("Times of Module.ListReturns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListReturns.expectedInvocations, n)
	return mmListReturns
}

func (mmListReturns *mModuleListReturns) invocationsDone() bool {
	if len(mmListReturns.expectations) == 0 && mmListReturns.defaultExpectation == nil && mmListReturns.mock.funcListReturns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListReturns.mock.afterListReturnsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListReturns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListReturns implements api.OrderModule
func (mmListReturns *Module) ListReturns(ctx context.Context) (oa1 []model.Order, m1 map[model.PackageType]model.Package, err error) {
	mm_atomic.AddUint64(&mmListReturns.beforeListReturnsCounter, 1)
	defer mm_atomic.AddUint64(&mmListReturns.afterListReturnsCounter, 1)

	if mmListReturns.inspectFuncListReturns != nil {
		mmListReturns.inspectFuncListReturns(ctx)
	}

	mm_params := ModuleListReturnsParams{ctx}

	// Record call args
	mmListReturns.ListReturnsMock.mutex.Lock()
	mmListReturns.ListReturnsMock.callArgs = append(mmListReturns.ListReturnsMock.callArgs, &mm_params)
	mmListReturns.ListReturnsMock.mutex.Unlock()

	for _, e := range mmListReturns.ListReturnsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.m1, e.results.err
		}
	}

	if mmListReturns.ListReturnsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListReturns.ListReturnsMock.defaultExpectation.Counter, 1)
		mm_want := mmListReturns.ListReturnsMock.defaultExpectation.params
		mm_want_ptrs := mmListReturns.ListReturnsMock.defaultExpectation.paramPtrs

		mm_got := ModuleListReturnsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListReturns.t.Errorf("Module.ListReturns got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListReturns.t.Errorf("Module.ListReturns got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListReturns.ListReturnsMock.defaultExpectation.results
		if mm_results == nil {
			mmListReturns.t.Fatal("No results are set for the Module.ListReturns")
		}
		return (*mm_results).oa1, (*mm_results).m1, (*mm_results).err
	}
	if mmListReturns.funcListReturns != nil {
		return mmListReturns.funcListReturns(ctx)
	}
	mmListReturns.t.Fatalf("Unexpected call to Module.ListReturns. %v", ctx)
	return
}

// ListReturnsAfterCounter returns a count of finished Module.ListReturns invocations
func (mmListReturns *Module) ListReturnsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListReturns.afterListReturnsCounter)
}

// ListReturnsBeforeCounter returns a count of Module.ListReturns invocations
func (mmListReturns *Module) ListReturnsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListReturns.beforeListReturnsCounter)
}

// Calls returns a list of arguments used in each call to Module.ListReturns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListReturns *mModuleListReturns) Calls() []*ModuleListReturnsParams {
	mmListReturns.mutex.RLock()

	argCopy := make([]*ModuleListReturnsParams, len(mmListReturns.callArgs))
	copy(argCopy, mmListReturns.callArgs)

	mmListReturns.mutex.RUnlock()

	return argCopy
}

// MinimockListReturnsDone returns true if the count of the ListReturns invocations corresponds
// the number of defined expectations
func (m *Module) MinimockListReturnsDone() bool {
	if m.ListReturnsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListReturnsMock.invocationsDone()
}

// MinimockListReturnsInspect logs each unmet expectation
func (m *Module) MinimockListReturnsInspect() {
	for _, e := range m.ListReturnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Module.ListReturns with params: %#v", *e.params)
		}
	}

	afterListReturnsCounter := mm_atomic.LoadUint64(&m.afterListReturnsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListReturnsMock.defaultExpectation != nil && afterListReturnsCounter < 1 {
		if m.ListReturnsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Module.ListReturns")
		} else {
			m.t.Errorf("Expected call to Module.ListReturns with params: %#v", *m.ListReturnsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListReturns != nil && afterListReturnsCounter < 1 {
		m.t.Error("Expected call to Module.ListReturns")
	}

	if !m.ListReturnsMock.invocationsDone() && afterListReturnsCounter > 0 {
		m.t.Errorf("Expected %d calls to Module.ListReturns but found %d calls",
			mm_atomic.LoadUint64(&m.ListReturnsMock.expectedInvocations), afterListReturnsCounter)
	}
}

type mModuleLoadPackagesToCheck struct {
	optional           bool
	mock               *Module
	defaultExpectation *ModuleLoadPackagesToCheckExpectation
	expectations       []*ModuleLoadPackagesToCheckExpectation

	callArgs []*ModuleLoadPackagesToCheckParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ModuleLoadPackagesToCheckExpectation specifies expectation struct of the OrderModule.LoadPackagesToCheck
type ModuleLoadPackagesToCheckExpectation struct {
	mock      *Module
	params    *ModuleLoadPackagesToCheckParams
	paramPtrs *ModuleLoadPackagesToCheckParamPtrs
	results   *ModuleLoadPackagesToCheckResults
	Counter   uint64
}

// ModuleLoadPackagesToCheckParams contains parameters of the OrderModule.LoadPackagesToCheck
type ModuleLoadPackagesToCheckParams struct {
	ctx context.Context
}

// ModuleLoadPackagesToCheckParamPtrs contains pointers to parameters of the OrderModule.LoadPackagesToCheck
type ModuleLoadPackagesToCheckParamPtrs struct {
	ctx *context.Context
}

// ModuleLoadPackagesToCheckResults contains results of the OrderModule.LoadPackagesToCheck
type ModuleLoadPackagesToCheckResults struct {
	pa1 []model.Package
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLoadPackagesToCheck *mModuleLoadPackagesToCheck) Optional() *mModuleLoadPackagesToCheck {
	mmLoadPackagesToCheck.optional = true
	return mmLoadPackagesToCheck
}

// Expect sets up expected params for OrderModule.LoadPackagesToCheck
func (mmLoadPackagesToCheck *mModuleLoadPackagesToCheck) Expect(ctx context.Context) *mModuleLoadPackagesToCheck {
	if mmLoadPackagesToCheck.mock.funcLoadPackagesToCheck != nil {
		mmLoadPackagesToCheck.mock.t.Fatalf("Module.LoadPackagesToCheck mock is already set by Set")
	}

	if mmLoadPackagesToCheck.defaultExpectation == nil {
		mmLoadPackagesToCheck.defaultExpectation = &ModuleLoadPackagesToCheckExpectation{}
	}

	if mmLoadPackagesToCheck.defaultExpectation.paramPtrs != nil {
		mmLoadPackagesToCheck.mock.t.Fatalf("Module.LoadPackagesToCheck mock is already set by ExpectParams functions")
	}

	mmLoadPackagesToCheck.defaultExpectation.params = &ModuleLoadPackagesToCheckParams{ctx}
	for _, e := range mmLoadPackagesToCheck.expectations {
		if minimock.Equal(e.params, mmLoadPackagesToCheck.defaultExpectation.params) {
			mmLoadPackagesToCheck.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLoadPackagesToCheck.defaultExpectation.params)
		}
	}

	return mmLoadPackagesToCheck
}

// ExpectCtxParam1 sets up expected param ctx for OrderModule.LoadPackagesToCheck
func (mmLoadPackagesToCheck *mModuleLoadPackagesToCheck) ExpectCtxParam1(ctx context.Context) *mModuleLoadPackagesToCheck {
	if mmLoadPackagesToCheck.mock.funcLoadPackagesToCheck != nil {
		mmLoadPackagesToCheck.mock.t.Fatalf("Module.LoadPackagesToCheck mock is already set by Set")
	}

	if mmLoadPackagesToCheck.defaultExpectation == nil {
		mmLoadPackagesToCheck.defaultExpectation = &ModuleLoadPackagesToCheckExpectation{}
	}

	if mmLoadPackagesToCheck.defaultExpectation.params != nil {
		mmLoadPackagesToCheck.mock.t.Fatalf("Module.LoadPackagesToCheck mock is already set by Expect")
	}

	if mmLoadPackagesToCheck.defaultExpectation.paramPtrs == nil {
		mmLoadPackagesToCheck.defaultExpectation.paramPtrs = &ModuleLoadPackagesToCheckParamPtrs{}
	}
	mmLoadPackagesToCheck.defaultExpectation.paramPtrs.ctx = &ctx

	return mmLoadPackagesToCheck
}

// Inspect accepts an inspector function that has same arguments as the OrderModule.LoadPackagesToCheck
func (mmLoadPackagesToCheck *mModuleLoadPackagesToCheck) Inspect(f func(ctx context.Context)) *mModuleLoadPackagesToCheck {
	if mmLoadPackagesToCheck.mock.inspectFuncLoadPackagesToCheck != nil {
		mmLoadPackagesToCheck.mock.t.Fatalf("Inspect function is already set for Module.LoadPackagesToCheck")
	}

	mmLoadPackagesToCheck.mock.inspectFuncLoadPackagesToCheck = f

	return mmLoadPackagesToCheck
}

// Return sets up results that will be returned by OrderModule.LoadPackagesToCheck
func (mmLoadPackagesToCheck *mModuleLoadPackagesToCheck) Return(pa1 []model.Package, err error) *Module {
	if mmLoadPackagesToCheck.mock.funcLoadPackagesToCheck != nil {
		mmLoadPackagesToCheck.mock.t.Fatalf("Module.LoadPackagesToCheck mock is already set by Set")
	}

	if mmLoadPackagesToCheck.defaultExpectation == nil {
		mmLoadPackagesToCheck.defaultExpectation = &ModuleLoadPackagesToCheckExpectation{mock: mmLoadPackagesToCheck.mock}
	}
	mmLoadPackagesToCheck.defaultExpectation.results = &ModuleLoadPackagesToCheckResults{pa1, err}
	return mmLoadPackagesToCheck.mock
}

// Set uses given function f to mock the OrderModule.LoadPackagesToCheck method
func (mmLoadPackagesToCheck *mModuleLoadPackagesToCheck) Set(f func(ctx context.Context) (pa1 []model.Package, err error)) *Module {
	if mmLoadPackagesToCheck.defaultExpectation != nil {
		mmLoadPackagesToCheck.mock.t.Fatalf("Default expectation is already set for the OrderModule.LoadPackagesToCheck method")
	}

	if len(mmLoadPackagesToCheck.expectations) > 0 {
		mmLoadPackagesToCheck.mock.t.Fatalf("Some expectations are already set for the OrderModule.LoadPackagesToCheck method")
	}

	mmLoadPackagesToCheck.mock.funcLoadPackagesToCheck = f
	return mmLoadPackagesToCheck.mock
}

// When sets expectation for the OrderModule.LoadPackagesToCheck which will trigger the result defined by the following
// Then helper
func (mmLoadPackagesToCheck *mModuleLoadPackagesToCheck) When(ctx context.Context) *ModuleLoadPackagesToCheckExpectation {
	if mmLoadPackagesToCheck.mock.funcLoadPackagesToCheck != nil {
		mmLoadPackagesToCheck.mock.t.Fatalf("Module.LoadPackagesToCheck mock is already set by Set")
	}

	expectation := &ModuleLoadPackagesToCheckExpectation{
		mock:   mmLoadPackagesToCheck.mock,
		params: &ModuleLoadPackagesToCheckParams{ctx},
	}
	mmLoadPackagesToCheck.expectations = append(mmLoadPackagesToCheck.expectations, expectation)
	return expectation
}

// Then sets up OrderModule.LoadPackagesToCheck return parameters for the expectation previously defined by the When method
func (e *ModuleLoadPackagesToCheckExpectation) Then(pa1 []model.Package, err error) *Module {
	e.results = &ModuleLoadPackagesToCheckResults{pa1, err}
	return e.mock
}

// Times sets number of times OrderModule.LoadPackagesToCheck should be invoked
func (mmLoadPackagesToCheck *mModuleLoadPackagesToCheck) Times(n uint64) *mModuleLoadPackagesToCheck {
	if n == 0 {
		mmLoadPackagesToCheck.mock.t.Fatalf("Times of Module.LoadPackagesToCheck mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLoadPackagesToCheck.expectedInvocations, n)
	return mmLoadPackagesToCheck
}

func (mmLoadPackagesToCheck *mModuleLoadPackagesToCheck) invocationsDone() bool {
	if len(mmLoadPackagesToCheck.expectations) == 0 && mmLoadPackagesToCheck.defaultExpectation == nil && mmLoadPackagesToCheck.mock.funcLoadPackagesToCheck == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLoadPackagesToCheck.mock.afterLoadPackagesToCheckCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLoadPackagesToCheck.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LoadPackagesToCheck implements api.OrderModule
func (mmLoadPackagesToCheck *Module) LoadPackagesToCheck(ctx context.Context) (pa1 []model.Package, err error) {
	mm_atomic.AddUint64(&mmLoadPackagesToCheck.beforeLoadPackagesToCheckCounter, 1)
	defer mm_atomic.AddUint64(&mmLoadPackagesToCheck.afterLoadPackagesToCheckCounter, 1)

	if mmLoadPackagesToCheck.inspectFuncLoadPackagesToCheck != nil {
		mmLoadPackagesToCheck.inspectFuncLoadPackagesToCheck(ctx)
	}

	mm_params := ModuleLoadPackagesToCheckParams{ctx}

	// Record call args
	mmLoadPackagesToCheck.LoadPackagesToCheckMock.mutex.Lock()
	mmLoadPackagesToCheck.LoadPackagesToCheckMock.callArgs = append(mmLoadPackagesToCheck.LoadPackagesToCheckMock.callArgs, &mm_params)
	mmLoadPackagesToCheck.LoadPackagesToCheckMock.mutex.Unlock()

	for _, e := range mmLoadPackagesToCheck.LoadPackagesToCheckMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmLoadPackagesToCheck.LoadPackagesToCheckMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLoadPackagesToCheck.LoadPackagesToCheckMock.defaultExpectation.Counter, 1)
		mm_want := mmLoadPackagesToCheck.LoadPackagesToCheckMock.defaultExpectation.params
		mm_want_ptrs := mmLoadPackagesToCheck.LoadPackagesToCheckMock.defaultExpectation.paramPtrs

		mm_got := ModuleLoadPackagesToCheckParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLoadPackagesToCheck.t.Errorf("Module.LoadPackagesToCheck got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLoadPackagesToCheck.t.Errorf("Module.LoadPackagesToCheck got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLoadPackagesToCheck.LoadPackagesToCheckMock.defaultExpectation.results
		if mm_results == nil {
			mmLoadPackagesToCheck.t.Fatal("No results are set for the Module.LoadPackagesToCheck")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmLoadPackagesToCheck.funcLoadPackagesToCheck != nil {
		return mmLoadPackagesToCheck.funcLoadPackagesToCheck(ctx)
	}
	mmLoadPackagesToCheck.t.Fatalf("Unexpected call to Module.LoadPackagesToCheck. %v", ctx)
	return
}

// LoadPackagesToCheckAfterCounter returns a count of finished Module.LoadPackagesToCheck invocations
func (mmLoadPackagesToCheck *Module) LoadPackagesToCheckAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoadPackagesToCheck.afterLoadPackagesToCheckCounter)
}

// LoadPackagesToCheckBeforeCounter returns a count of Module.LoadPackagesToCheck invocations
func (mmLoadPackagesToCheck *Module) LoadPackagesToCheckBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoadPackagesToCheck.beforeLoadPackagesToCheckCounter)
}

// Calls returns a list of arguments used in each call to Module.LoadPackagesToCheck.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLoadPackagesToCheck *mModuleLoadPackagesToCheck) Calls() []*ModuleLoadPackagesToCheckParams {
	mmLoadPackagesToCheck.mutex.RLock()

	argCopy := make([]*ModuleLoadPackagesToCheckParams, len(mmLoadPackagesToCheck.callArgs))
	copy(argCopy, mmLoadPackagesToCheck.callArgs)

	mmLoadPackagesToCheck.mutex.RUnlock()

	return argCopy
}

// MinimockLoadPackagesToCheckDone returns true if the count of the LoadPackagesToCheck invocations corresponds
// the number of defined expectations
func (m *Module) MinimockLoadPackagesToCheckDone() bool {
	if m.LoadPackagesToCheckMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoadPackagesToCheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoadPackagesToCheckMock.invocationsDone()
}

// MinimockLoadPackagesToCheckInspect logs each unmet expectation
func (m *Module) MinimockLoadPackagesToCheckInspect() {
	for _, e := range m.LoadPackagesToCheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Module.LoadPackagesToCheck with params: %#v", *e.params)
		}
	}

	afterLoadPackagesToCheckCounter := mm_atomic.LoadUint64(&m.afterLoadPackagesToCheckCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoadPackagesToCheckMock.defaultExpectation != nil && afterLoadPackagesToCheckCounter < 1 {
		if m.LoadPackagesToCheckMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Module.LoadPackagesToCheck")
		} else {
			m.t.Errorf("Expected call to Module.LoadPackagesToCheck with params: %#v", *m.LoadPackagesToCheckMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLoadPackagesToCheck != nil && afterLoadPackagesToCheckCounter < 1 {
		m.t.Error("Expected call to Module.LoadPackagesToCheck")
	}

	if !m.LoadPackagesToCheckMock.invocationsDone() && afterLoadPackagesToCheckCounter > 0 {
		m.t.Errorf("Expected %d calls to Module.LoadPackagesToCheck but found %d calls",
			mm_atomic.LoadUint64(&m.LoadPackagesToCheckMock.expectedInvocations), afterLoadPackagesToCheckCounter)
	}
}

type mModuleReturnFromClient struct {
	optional           bool
	mock               *Module
	defaultExpectation *ModuleReturnFromClientExpectation
	expectations       []*ModuleReturnFromClientExpectation

	callArgs []*ModuleReturnFromClientParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ModuleReturnFromClientExpectation specifies expectation struct of the OrderModule.ReturnFromClient
type ModuleReturnFromClientExpectation struct {
	mock      *Module
	params    *ModuleReturnFromClientParams
	paramPtrs *ModuleReturnFromClientParamPtrs
	results   *ModuleReturnFromClientResults
	Counter   uint64
}

// ModuleReturnFromClientParams contains parameters of the OrderModule.ReturnFromClient
type ModuleReturnFromClientParams struct {
	ctx      context.Context
	orderID  model.OrderID
	clientID model.ClientID
}

// ModuleReturnFromClientParamPtrs contains pointers to parameters of the OrderModule.ReturnFromClient
type ModuleReturnFromClientParamPtrs struct {
	ctx      *context.Context
	orderID  *model.OrderID
	clientID *model.ClientID
}

// ModuleReturnFromClientResults contains results of the OrderModule.ReturnFromClient
type ModuleReturnFromClientResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReturnFromClient *mModuleReturnFromClient) Optional() *mModuleReturnFromClient {
	mmReturnFromClient.optional = true
	return mmReturnFromClient
}

// Expect sets up expected params for OrderModule.ReturnFromClient
func (mmReturnFromClient *mModuleReturnFromClient) Expect(ctx context.Context, orderID model.OrderID, clientID model.ClientID) *mModuleReturnFromClient {
	if mmReturnFromClient.mock.funcReturnFromClient != nil {
		mmReturnFromClient.mock.t.Fatalf("Module.ReturnFromClient mock is already set by Set")
	}

	if mmReturnFromClient.defaultExpectation == nil {
		mmReturnFromClient.defaultExpectation = &ModuleReturnFromClientExpectation{}
	}

	if mmReturnFromClient.defaultExpectation.paramPtrs != nil {
		mmReturnFromClient.mock.t.Fatalf("Module.ReturnFromClient mock is already set by ExpectParams functions")
	}

	mmReturnFromClient.defaultExpectation.params = &ModuleReturnFromClientParams{ctx, orderID, clientID}
	for _, e := range mmReturnFromClient.expectations {
		if minimock.Equal(e.params, mmReturnFromClient.defaultExpectation.params) {
			mmReturnFromClient.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReturnFromClient.defaultExpectation.params)
		}
	}

	return mmReturnFromClient
}

// ExpectCtxParam1 sets up expected param ctx for OrderModule.ReturnFromClient
func (mmReturnFromClient *mModuleReturnFromClient) ExpectCtxParam1(ctx context.Context) *mModuleReturnFromClient {
	if mmReturnFromClient.mock.funcReturnFromClient != nil {
		mmReturnFromClient.mock.t.Fatalf("Module.ReturnFromClient mock is already set by Set")
	}

	if mmReturnFromClient.defaultExpectation == nil {
		mmReturnFromClient.defaultExpectation = &ModuleReturnFromClientExpectation{}
	}

	if mmReturnFromClient.defaultExpectation.params != nil {
		mmReturnFromClient.mock.t.Fatalf("Module.ReturnFromClient mock is already set by Expect")
	}

	if mmReturnFromClient.defaultExpectation.paramPtrs == nil {
		mmReturnFromClient.defaultExpectation.paramPtrs = &ModuleReturnFromClientParamPtrs{}
	}
	mmReturnFromClient.defaultExpectation.paramPtrs.ctx = &ctx

	return mmReturnFromClient
}

// ExpectOrderIDParam2 sets up expected param orderID for OrderModule.ReturnFromClient
func (mmReturnFromClient *mModuleReturnFromClient) ExpectOrderIDParam2(orderID model.OrderID) *mModuleReturnFromClient {
	if mmReturnFromClient.mock.funcReturnFromClient != nil {
		mmReturnFromClient.mock.t.Fatalf("Module.ReturnFromClient mock is already set by Set")
	}

	if mmReturnFromClient.defaultExpectation == nil {
		mmReturnFromClient.defaultExpectation = &ModuleReturnFromClientExpectation{}
	}

	if mmReturnFromClient.defaultExpectation.params != nil {
		mmReturnFromClient.mock.t.Fatalf("Module.ReturnFromClient mock is already set by Expect")
	}

	if mmReturnFromClient.defaultExpectation.paramPtrs == nil {
		mmReturnFromClient.defaultExpectation.paramPtrs = &ModuleReturnFromClientParamPtrs{}
	}
	mmReturnFromClient.defaultExpectation.paramPtrs.orderID = &orderID

	return mmReturnFromClient
}

// ExpectClientIDParam3 sets up expected param clientID for OrderModule.ReturnFromClient
func (mmReturnFromClient *mModuleReturnFromClient) ExpectClientIDParam3(clientID model.ClientID) *mModuleReturnFromClient {
	if mmReturnFromClient.mock.funcReturnFromClient != nil {
		mmReturnFromClient.mock.t.Fatalf("Module.ReturnFromClient mock is already set by Set")
	}

	if mmReturnFromClient.defaultExpectation == nil {
		mmReturnFromClient.defaultExpectation = &ModuleReturnFromClientExpectation{}
	}

	if mmReturnFromClient.defaultExpectation.params != nil {
		mmReturnFromClient.mock.t.Fatalf("Module.ReturnFromClient mock is already set by Expect")
	}

	if mmReturnFromClient.defaultExpectation.paramPtrs == nil {
		mmReturnFromClient.defaultExpectation.paramPtrs = &ModuleReturnFromClientParamPtrs{}
	}
	mmReturnFromClient.defaultExpectation.paramPtrs.clientID = &clientID

	return mmReturnFromClient
}

// Inspect accepts an inspector function that has same arguments as the OrderModule.ReturnFromClient
func (mmReturnFromClient *mModuleReturnFromClient) Inspect(f func(ctx context.Context, orderID model.OrderID, clientID model.ClientID)) *mModuleReturnFromClient {
	if mmReturnFromClient.mock.inspectFuncReturnFromClient != nil {
		mmReturnFromClient.mock.t.Fatalf("Inspect function is already set for Module.ReturnFromClient")
	}

	mmReturnFromClient.mock.inspectFuncReturnFromClient = f

	return mmReturnFromClient
}

// Return sets up results that will be returned by OrderModule.ReturnFromClient
func (mmReturnFromClient *mModuleReturnFromClient) Return(err error) *Module {
	if mmReturnFromClient.mock.funcReturnFromClient != nil {
		mmReturnFromClient.mock.t.Fatalf("Module.ReturnFromClient mock is already set by Set")
	}

	if mmReturnFromClient.defaultExpectation == nil {
		mmReturnFromClient.defaultExpectation = &ModuleReturnFromClientExpectation{mock: mmReturnFromClient.mock}
	}
	mmReturnFromClient.defaultExpectation.results = &ModuleReturnFromClientResults{err}
	return mmReturnFromClient.mock
}

// Set uses given function f to mock the OrderModule.ReturnFromClient method
func (mmReturnFromClient *mModuleReturnFromClient) Set(f func(ctx context.Context, orderID model.OrderID, clientID model.ClientID) (err error)) *Module {
	if mmReturnFromClient.defaultExpectation != nil {
		mmReturnFromClient.mock.t.Fatalf("Default expectation is already set for the OrderModule.ReturnFromClient method")
	}

	if len(mmReturnFromClient.expectations) > 0 {
		mmReturnFromClient.mock.t.Fatalf("Some expectations are already set for the OrderModule.ReturnFromClient method")
	}

	mmReturnFromClient.mock.funcReturnFromClient = f
	return mmReturnFromClient.mock
}

// When sets expectation for the OrderModule.ReturnFromClient which will trigger the result defined by the following
// Then helper
func (mmReturnFromClient *mModuleReturnFromClient) When(ctx context.Context, orderID model.OrderID, clientID model.ClientID) *ModuleReturnFromClientExpectation {
	if mmReturnFromClient.mock.funcReturnFromClient != nil {
		mmReturnFromClient.mock.t.Fatalf("Module.ReturnFromClient mock is already set by Set")
	}

	expectation := &ModuleReturnFromClientExpectation{
		mock:   mmReturnFromClient.mock,
		params: &ModuleReturnFromClientParams{ctx, orderID, clientID},
	}
	mmReturnFromClient.expectations = append(mmReturnFromClient.expectations, expectation)
	return expectation
}

// Then sets up OrderModule.ReturnFromClient return parameters for the expectation previously defined by the When method
func (e *ModuleReturnFromClientExpectation) Then(err error) *Module {
	e.results = &ModuleReturnFromClientResults{err}
	return e.mock
}

// Times sets number of times OrderModule.ReturnFromClient should be invoked
func (mmReturnFromClient *mModuleReturnFromClient) Times(n uint64) *mModuleReturnFromClient {
	if n == 0 {
		mmReturnFromClient.mock.t.Fatalf("Times of Module.ReturnFromClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReturnFromClient.expectedInvocations, n)
	return mmReturnFromClient
}

func (mmReturnFromClient *mModuleReturnFromClient) invocationsDone() bool {
	if len(mmReturnFromClient.expectations) == 0 && mmReturnFromClient.defaultExpectation == nil && mmReturnFromClient.mock.funcReturnFromClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReturnFromClient.mock.afterReturnFromClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReturnFromClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReturnFromClient implements api.OrderModule
func (mmReturnFromClient *Module) ReturnFromClient(ctx context.Context, orderID model.OrderID, clientID model.ClientID) (err error) {
	mm_atomic.AddUint64(&mmReturnFromClient.beforeReturnFromClientCounter, 1)
	defer mm_atomic.AddUint64(&mmReturnFromClient.afterReturnFromClientCounter, 1)

	if mmReturnFromClient.inspectFuncReturnFromClient != nil {
		mmReturnFromClient.inspectFuncReturnFromClient(ctx, orderID, clientID)
	}

	mm_params := ModuleReturnFromClientParams{ctx, orderID, clientID}

	// Record call args
	mmReturnFromClient.ReturnFromClientMock.mutex.Lock()
	mmReturnFromClient.ReturnFromClientMock.callArgs = append(mmReturnFromClient.ReturnFromClientMock.callArgs, &mm_params)
	mmReturnFromClient.ReturnFromClientMock.mutex.Unlock()

	for _, e := range mmReturnFromClient.ReturnFromClientMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReturnFromClient.ReturnFromClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReturnFromClient.ReturnFromClientMock.defaultExpectation.Counter, 1)
		mm_want := mmReturnFromClient.ReturnFromClientMock.defaultExpectation.params
		mm_want_ptrs := mmReturnFromClient.ReturnFromClientMock.defaultExpectation.paramPtrs

		mm_got := ModuleReturnFromClientParams{ctx, orderID, clientID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReturnFromClient.t.Errorf("Module.ReturnFromClient got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmReturnFromClient.t.Errorf("Module.ReturnFromClient got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmReturnFromClient.t.Errorf("Module.ReturnFromClient got unexpected parameter clientID, want: %#v, got: %#v%s\n", *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReturnFromClient.t.Errorf("Module.ReturnFromClient got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReturnFromClient.ReturnFromClientMock.defaultExpectation.results
		if mm_results == nil {
			mmReturnFromClient.t.Fatal("No results are set for the Module.ReturnFromClient")
		}
		return (*mm_results).err
	}
	if mmReturnFromClient.funcReturnFromClient != nil {
		return mmReturnFromClient.funcReturnFromClient(ctx, orderID, clientID)
	}
	mmReturnFromClient.t.Fatalf("Unexpected call to Module.ReturnFromClient. %v %v %v", ctx, orderID, clientID)
	return
}

// ReturnFromClientAfterCounter returns a count of finished Module.ReturnFromClient invocations
func (mmReturnFromClient *Module) ReturnFromClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReturnFromClient.afterReturnFromClientCounter)
}

// ReturnFromClientBeforeCounter returns a count of Module.ReturnFromClient invocations
func (mmReturnFromClient *Module) ReturnFromClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReturnFromClient.beforeReturnFromClientCounter)
}

// Calls returns a list of arguments used in each call to Module.ReturnFromClient.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReturnFromClient *mModuleReturnFromClient) Calls() []*ModuleReturnFromClientParams {
	mmReturnFromClient.mutex.RLock()

	argCopy := make([]*ModuleReturnFromClientParams, len(mmReturnFromClient.callArgs))
	copy(argCopy, mmReturnFromClient.callArgs)

	mmReturnFromClient.mutex.RUnlock()

	return argCopy
}

// MinimockReturnFromClientDone returns true if the count of the ReturnFromClient invocations corresponds
// the number of defined expectations
func (m *Module) MinimockReturnFromClientDone() bool {
	if m.ReturnFromClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReturnFromClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReturnFromClientMock.invocationsDone()
}

// MinimockReturnFromClientInspect logs each unmet expectation
func (m *Module) MinimockReturnFromClientInspect() {
	for _, e := range m.ReturnFromClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Module.ReturnFromClient with params: %#v", *e.params)
		}
	}

	afterReturnFromClientCounter := mm_atomic.LoadUint64(&m.afterReturnFromClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReturnFromClientMock.defaultExpectation != nil && afterReturnFromClientCounter < 1 {
		if m.ReturnFromClientMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Module.ReturnFromClient")
		} else {
			m.t.Errorf("Expected call to Module.ReturnFromClient with params: %#v", *m.ReturnFromClientMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReturnFromClient != nil && afterReturnFromClientCounter < 1 {
		m.t.Error("Expected call to Module.ReturnFromClient")
	}

	if !m.ReturnFromClientMock.invocationsDone() && afterReturnFromClientCounter > 0 {
		m.t.Errorf("Expected %d calls to Module.ReturnFromClient but found %d calls",
			mm_atomic.LoadUint64(&m.ReturnFromClientMock.expectedInvocations), afterReturnFromClientCounter)
	}
}

type mModuleReturnOrder struct {
	optional           bool
	mock               *Module
	defaultExpectation *ModuleReturnOrderExpectation
	expectations       []*ModuleReturnOrderExpectation

	callArgs []*ModuleReturnOrderParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ModuleReturnOrderExpectation specifies expectation struct of the OrderModule.ReturnOrder
type ModuleReturnOrderExpectation struct {
	mock      *Module
	params    *ModuleReturnOrderParams
	paramPtrs *ModuleReturnOrderParamPtrs
	results   *ModuleReturnOrderResults
	Counter   uint64
}

// ModuleReturnOrderParams contains parameters of the OrderModule.ReturnOrder
type ModuleReturnOrderParams struct {
	ctx     context.Context
	orderID model.OrderID
}

// ModuleReturnOrderParamPtrs contains pointers to parameters of the OrderModule.ReturnOrder
type ModuleReturnOrderParamPtrs struct {
	ctx     *context.Context
	orderID *model.OrderID
}

// ModuleReturnOrderResults contains results of the OrderModule.ReturnOrder
type ModuleReturnOrderResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReturnOrder *mModuleReturnOrder) Optional() *mModuleReturnOrder {
	mmReturnOrder.optional = true
	return mmReturnOrder
}

// Expect sets up expected params for OrderModule.ReturnOrder
func (mmReturnOrder *mModuleReturnOrder) Expect(ctx context.Context, orderID model.OrderID) *mModuleReturnOrder {
	if mmReturnOrder.mock.funcReturnOrder != nil {
		mmReturnOrder.mock.t.Fatalf("Module.ReturnOrder mock is already set by Set")
	}

	if mmReturnOrder.defaultExpectation == nil {
		mmReturnOrder.defaultExpectation = &ModuleReturnOrderExpectation{}
	}

	if mmReturnOrder.defaultExpectation.paramPtrs != nil {
		mmReturnOrder.mock.t.Fatalf("Module.ReturnOrder mock is already set by ExpectParams functions")
	}

	mmReturnOrder.defaultExpectation.params = &ModuleReturnOrderParams{ctx, orderID}
	for _, e := range mmReturnOrder.expectations {
		if minimock.Equal(e.params, mmReturnOrder.defaultExpectation.params) {
			mmReturnOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReturnOrder.defaultExpectation.params)
		}
	}

	return mmReturnOrder
}

// ExpectCtxParam1 sets up expected param ctx for OrderModule.ReturnOrder
func (mmReturnOrder *mModuleReturnOrder) ExpectCtxParam1(ctx context.Context) *mModuleReturnOrder {
	if mmReturnOrder.mock.funcReturnOrder != nil {
		mmReturnOrder.mock.t.Fatalf("Module.ReturnOrder mock is already set by Set")
	}

	if mmReturnOrder.defaultExpectation == nil {
		mmReturnOrder.defaultExpectation = &ModuleReturnOrderExpectation{}
	}

	if mmReturnOrder.defaultExpectation.params != nil {
		mmReturnOrder.mock.t.Fatalf("Module.ReturnOrder mock is already set by Expect")
	}

	if mmReturnOrder.defaultExpectation.paramPtrs == nil {
		mmReturnOrder.defaultExpectation.paramPtrs = &ModuleReturnOrderParamPtrs{}
	}
	mmReturnOrder.defaultExpectation.paramPtrs.ctx = &ctx

	return mmReturnOrder
}

// ExpectOrderIDParam2 sets up expected param orderID for OrderModule.ReturnOrder
func (mmReturnOrder *mModuleReturnOrder) ExpectOrderIDParam2(orderID model.OrderID) *mModuleReturnOrder {
	if mmReturnOrder.mock.funcReturnOrder != nil {
		mmReturnOrder.mock.t.Fatalf("Module.ReturnOrder mock is already set by Set")
	}

	if mmReturnOrder.defaultExpectation == nil {
		mmReturnOrder.defaultExpectation = &ModuleReturnOrderExpectation{}
	}

	if mmReturnOrder.defaultExpectation.params != nil {
		mmReturnOrder.mock.t.Fatalf("Module.ReturnOrder mock is already set by Expect")
	}

	if mmReturnOrder.defaultExpectation.paramPtrs == nil {
		mmReturnOrder.defaultExpectation.paramPtrs = &ModuleReturnOrderParamPtrs{}
	}
	mmReturnOrder.defaultExpectation.paramPtrs.orderID = &orderID

	return mmReturnOrder
}

// Inspect accepts an inspector function that has same arguments as the OrderModule.ReturnOrder
func (mmReturnOrder *mModuleReturnOrder) Inspect(f func(ctx context.Context, orderID model.OrderID)) *mModuleReturnOrder {
	if mmReturnOrder.mock.inspectFuncReturnOrder != nil {
		mmReturnOrder.mock.t.Fatalf("Inspect function is already set for Module.ReturnOrder")
	}

	mmReturnOrder.mock.inspectFuncReturnOrder = f

	return mmReturnOrder
}

// Return sets up results that will be returned by OrderModule.ReturnOrder
func (mmReturnOrder *mModuleReturnOrder) Return(err error) *Module {
	if mmReturnOrder.mock.funcReturnOrder != nil {
		mmReturnOrder.mock.t.Fatalf("Module.ReturnOrder mock is already set by Set")
	}

	if mmReturnOrder.defaultExpectation == nil {
		mmReturnOrder.defaultExpectation = &ModuleReturnOrderExpectation{mock: mmReturnOrder.mock}
	}
	mmReturnOrder.defaultExpectation.results = &ModuleReturnOrderResults{err}
	return mmReturnOrder.mock
}

// Set uses given function f to mock the OrderModule.ReturnOrder method
func (mmReturnOrder *mModuleReturnOrder) Set(f func(ctx context.Context, orderID model.OrderID) (err error)) *Module {
	if mmReturnOrder.defaultExpectation != nil {
		mmReturnOrder.mock.t.Fatalf("Default expectation is already set for the OrderModule.ReturnOrder method")
	}

	if len(mmReturnOrder.expectations) > 0 {
		mmReturnOrder.mock.t.Fatalf("Some expectations are already set for the OrderModule.ReturnOrder method")
	}

	mmReturnOrder.mock.funcReturnOrder = f
	return mmReturnOrder.mock
}

// When sets expectation for the OrderModule.ReturnOrder which will trigger the result defined by the following
// Then helper
func (mmReturnOrder *mModuleReturnOrder) When(ctx context.Context, orderID model.OrderID) *ModuleReturnOrderExpectation {
	if mmReturnOrder.mock.funcReturnOrder != nil {
		mmReturnOrder.mock.t.Fatalf("Module.ReturnOrder mock is already set by Set")
	}

	expectation := &ModuleReturnOrderExpectation{
		mock:   mmReturnOrder.mock,
		params: &ModuleReturnOrderParams{ctx, orderID},
	}
	mmReturnOrder.expectations = append(mmReturnOrder.expectations, expectation)
	return expectation
}

// Then sets up OrderModule.ReturnOrder return parameters for the expectation previously defined by the When method
func (e *ModuleReturnOrderExpectation) Then(err error) *Module {
	e.results = &ModuleReturnOrderResults{err}
	return e.mock
}

// Times sets number of times OrderModule.ReturnOrder should be invoked
func (mmReturnOrder *mModuleReturnOrder) Times(n uint64) *mModuleReturnOrder {
	if n == 0 {
		mmReturnOrder.mock.t.Fatalf("Times of Module.ReturnOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReturnOrder.expectedInvocations, n)
	return mmReturnOrder
}

func (mmReturnOrder *mModuleReturnOrder) invocationsDone() bool {
	if len(mmReturnOrder.expectations) == 0 && mmReturnOrder.defaultExpectation == nil && mmReturnOrder.mock.funcReturnOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReturnOrder.mock.afterReturnOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReturnOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReturnOrder implements api.OrderModule
func (mmReturnOrder *Module) ReturnOrder(ctx context.Context, orderID model.OrderID) (err error) {
	mm_atomic.AddUint64(&mmReturnOrder.beforeReturnOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmReturnOrder.afterReturnOrderCounter, 1)

	if mmReturnOrder.inspectFuncReturnOrder != nil {
		mmReturnOrder.inspectFuncReturnOrder(ctx, orderID)
	}

	mm_params := ModuleReturnOrderParams{ctx, orderID}

	// Record call args
	mmReturnOrder.ReturnOrderMock.mutex.Lock()
	mmReturnOrder.ReturnOrderMock.callArgs = append(mmReturnOrder.ReturnOrderMock.callArgs, &mm_params)
	mmReturnOrder.ReturnOrderMock.mutex.Unlock()

	for _, e := range mmReturnOrder.ReturnOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReturnOrder.ReturnOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReturnOrder.ReturnOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmReturnOrder.ReturnOrderMock.defaultExpectation.params
		mm_want_ptrs := mmReturnOrder.ReturnOrderMock.defaultExpectation.paramPtrs

		mm_got := ModuleReturnOrderParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReturnOrder.t.Errorf("Module.ReturnOrder got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmReturnOrder.t.Errorf("Module.ReturnOrder got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReturnOrder.t.Errorf("Module.ReturnOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReturnOrder.ReturnOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmReturnOrder.t.Fatal("No results are set for the Module.ReturnOrder")
		}
		return (*mm_results).err
	}
	if mmReturnOrder.funcReturnOrder != nil {
		return mmReturnOrder.funcReturnOrder(ctx, orderID)
	}
	mmReturnOrder.t.Fatalf("Unexpected call to Module.ReturnOrder. %v %v", ctx, orderID)
	return
}

// ReturnOrderAfterCounter returns a count of finished Module.ReturnOrder invocations
func (mmReturnOrder *Module) ReturnOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReturnOrder.afterReturnOrderCounter)
}

// ReturnOrderBeforeCounter returns a count of Module.ReturnOrder invocations
func (mmReturnOrder *Module) ReturnOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReturnOrder.beforeReturnOrderCounter)
}

// Calls returns a list of arguments used in each call to Module.ReturnOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReturnOrder *mModuleReturnOrder) Calls() []*ModuleReturnOrderParams {
	mmReturnOrder.mutex.RLock()

	argCopy := make([]*ModuleReturnOrderParams, len(mmReturnOrder.callArgs))
	copy(argCopy, mmReturnOrder.callArgs)

	mmReturnOrder.mutex.RUnlock()

	return argCopy
}

// MinimockReturnOrderDone returns true if the count of the ReturnOrder invocations corresponds
// the number of defined expectations
func (m *Module) MinimockReturnOrderDone() bool {
	if m.ReturnOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReturnOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReturnOrderMock.invocationsDone()
}

// MinimockReturnOrderInspect logs each unmet expectation
func (m *Module) MinimockReturnOrderInspect() {
	for _, e := range m.ReturnOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Module.ReturnOrder with params: %#v", *e.params)
		}
	}

	afterReturnOrderCounter := mm_atomic.LoadUint64(&m.afterReturnOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReturnOrderMock.defaultExpectation != nil && afterReturnOrderCounter < 1 {
		if m.ReturnOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Module.ReturnOrder")
		} else {
			m.t.Errorf("Expected call to Module.ReturnOrder with params: %#v", *m.ReturnOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReturnOrder != nil && afterReturnOrderCounter < 1 {
		m.t.Error("Expected call to Module.ReturnOrder")
	}

	if !m.ReturnOrderMock.invocationsDone() && afterReturnOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to Module.ReturnOrder but found %d calls",
			mm_atomic.LoadUint64(&m.ReturnOrderMock.expectedInvocations), afterReturnOrderCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *Module) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetOrderFromCourierInspect()

			m.MinimockGiveOrderInspect()

			m.MinimockGiveOrderWithNewPackageInspect()

			m.MinimockListOrdersInspect()

			m.MinimockListReturnsInspect()

			m.MinimockLoadPackagesToCheckInspect()

			m.MinimockReturnFromClientInspect()

			m.MinimockReturnOrderInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *Module) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *Module) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetOrderFromCourierDone() &&
		m.MinimockGiveOrderDone() &&
		m.MinimockGiveOrderWithNewPackageDone() &&
		m.MinimockListOrdersDone() &&
		m.MinimockListReturnsDone() &&
		m.MinimockLoadPackagesToCheckDone() &&
		m.MinimockReturnFromClientDone() &&
		m.MinimockReturnOrderDone()
}
