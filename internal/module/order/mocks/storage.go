// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package mocks

//go:generate minimock -i HomeWork_1/internal/module.Storage -o storage.go -n Storage -p mocks

import (
	"HomeWork_1/internal/model"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// Storage implements module.Storage
type Storage struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAppendOrder          func(ctx context.Context, order model.Order, hash string) (err error)
	inspectFuncAppendOrder   func(ctx context.Context, order model.Order, hash string)
	afterAppendOrderCounter  uint64
	beforeAppendOrderCounter uint64
	AppendOrderMock          mStorageAppendOrder

	funcDeleteOrder          func(ctx context.Context, orderID model.OrderID, hash string) (err error)
	inspectFuncDeleteOrder   func(ctx context.Context, orderID model.OrderID, hash string)
	afterDeleteOrderCounter  uint64
	beforeDeleteOrderCounter uint64
	DeleteOrderMock          mStorageDeleteOrder

	funcLoadOrders          func(ctx context.Context, hash string) (oa1 []model.Order, err error)
	inspectFuncLoadOrders   func(ctx context.Context, hash string)
	afterLoadOrdersCounter  uint64
	beforeLoadOrdersCounter uint64
	LoadOrdersMock          mStorageLoadOrders

	funcLoadPackByType          func(ctx context.Context, packageType model.PackageType) (pp1 *model.Package, err error)
	inspectFuncLoadPackByType   func(ctx context.Context, packageType model.PackageType)
	afterLoadPackByTypeCounter  uint64
	beforeLoadPackByTypeCounter uint64
	LoadPackByTypeMock          mStorageLoadPackByType

	funcLoadPackages          func(ctx context.Context) (pa1 []model.Package, err error)
	inspectFuncLoadPackages   func(ctx context.Context)
	afterLoadPackagesCounter  uint64
	beforeLoadPackagesCounter uint64
	LoadPackagesMock          mStorageLoadPackages

	funcOrderByClientIDOrderID          func(orderID model.OrderID, clientID model.ClientID, c1 context.Context, hash string) (op1 *model.Order, err error)
	inspectFuncOrderByClientIDOrderID   func(orderID model.OrderID, clientID model.ClientID, c1 context.Context, hash string)
	afterOrderByClientIDOrderIDCounter  uint64
	beforeOrderByClientIDOrderIDCounter uint64
	OrderByClientIDOrderIDMock          mStorageOrderByClientIDOrderID

	funcOrderByID          func(ctx context.Context, orderID model.OrderID, hash string) (op1 *model.Order, err error)
	inspectFuncOrderByID   func(ctx context.Context, orderID model.OrderID, hash string)
	afterOrderByIDCounter  uint64
	beforeOrderByIDCounter uint64
	OrderByIDMock          mStorageOrderByID

	funcOrdersByGivenOrderIDList          func(orderIDs []model.OrderID, ctx context.Context, hash string) (oa1 []model.Order, err error)
	inspectFuncOrdersByGivenOrderIDList   func(orderIDs []model.OrderID, ctx context.Context, hash string)
	afterOrdersByGivenOrderIDListCounter  uint64
	beforeOrdersByGivenOrderIDListCounter uint64
	OrdersByGivenOrderIDListMock          mStorageOrdersByGivenOrderIDList

	funcOrdersWithGivenClientID          func(clientID model.ClientID, c1 context.Context, hash string) (oa1 []model.Order, err error)
	inspectFuncOrdersWithGivenClientID   func(clientID model.ClientID, c1 context.Context, hash string)
	afterOrdersWithGivenClientIDCounter  uint64
	beforeOrdersWithGivenClientIDCounter uint64
	OrdersWithGivenClientIDMock          mStorageOrdersWithGivenClientID

	funcOrdersWithGivenClientIDAndAcceptedCondition          func(clientID model.ClientID, c1 context.Context, hash string) (oa1 []model.Order, err error)
	inspectFuncOrdersWithGivenClientIDAndAcceptedCondition   func(clientID model.ClientID, c1 context.Context, hash string)
	afterOrdersWithGivenClientIDAndAcceptedConditionCounter  uint64
	beforeOrdersWithGivenClientIDAndAcceptedConditionCounter uint64
	OrdersWithGivenClientIDAndAcceptedConditionMock          mStorageOrdersWithGivenClientIDAndAcceptedCondition

	funcOrdersWithRefundCondition          func(ctx context.Context, hash string) (oa1 []model.Order, err error)
	inspectFuncOrdersWithRefundCondition   func(ctx context.Context, hash string)
	afterOrdersWithRefundConditionCounter  uint64
	beforeOrdersWithRefundConditionCounter uint64
	OrdersWithRefundConditionMock          mStorageOrdersWithRefundCondition

	funcUpdateOrders          func(ctx context.Context, orders []model.Order, hash string) (err error)
	inspectFuncUpdateOrders   func(ctx context.Context, orders []model.Order, hash string)
	afterUpdateOrdersCounter  uint64
	beforeUpdateOrdersCounter uint64
	UpdateOrdersMock          mStorageUpdateOrders
}

// NewStorage returns a mock for module.Storage
func NewStorage(t minimock.Tester) *Storage {
	m := &Storage{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AppendOrderMock = mStorageAppendOrder{mock: m}
	m.AppendOrderMock.callArgs = []*StorageAppendOrderParams{}

	m.DeleteOrderMock = mStorageDeleteOrder{mock: m}
	m.DeleteOrderMock.callArgs = []*StorageDeleteOrderParams{}

	m.LoadOrdersMock = mStorageLoadOrders{mock: m}
	m.LoadOrdersMock.callArgs = []*StorageLoadOrdersParams{}

	m.LoadPackByTypeMock = mStorageLoadPackByType{mock: m}
	m.LoadPackByTypeMock.callArgs = []*StorageLoadPackByTypeParams{}

	m.LoadPackagesMock = mStorageLoadPackages{mock: m}
	m.LoadPackagesMock.callArgs = []*StorageLoadPackagesParams{}

	m.OrderByClientIDOrderIDMock = mStorageOrderByClientIDOrderID{mock: m}
	m.OrderByClientIDOrderIDMock.callArgs = []*StorageOrderByClientIDOrderIDParams{}

	m.OrderByIDMock = mStorageOrderByID{mock: m}
	m.OrderByIDMock.callArgs = []*StorageOrderByIDParams{}

	m.OrdersByGivenOrderIDListMock = mStorageOrdersByGivenOrderIDList{mock: m}
	m.OrdersByGivenOrderIDListMock.callArgs = []*StorageOrdersByGivenOrderIDListParams{}

	m.OrdersWithGivenClientIDMock = mStorageOrdersWithGivenClientID{mock: m}
	m.OrdersWithGivenClientIDMock.callArgs = []*StorageOrdersWithGivenClientIDParams{}

	m.OrdersWithGivenClientIDAndAcceptedConditionMock = mStorageOrdersWithGivenClientIDAndAcceptedCondition{mock: m}
	m.OrdersWithGivenClientIDAndAcceptedConditionMock.callArgs = []*StorageOrdersWithGivenClientIDAndAcceptedConditionParams{}

	m.OrdersWithRefundConditionMock = mStorageOrdersWithRefundCondition{mock: m}
	m.OrdersWithRefundConditionMock.callArgs = []*StorageOrdersWithRefundConditionParams{}

	m.UpdateOrdersMock = mStorageUpdateOrders{mock: m}
	m.UpdateOrdersMock.callArgs = []*StorageUpdateOrdersParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStorageAppendOrder struct {
	optional           bool
	mock               *Storage
	defaultExpectation *StorageAppendOrderExpectation
	expectations       []*StorageAppendOrderExpectation

	callArgs []*StorageAppendOrderParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StorageAppendOrderExpectation specifies expectation struct of the Storage.AppendOrder
type StorageAppendOrderExpectation struct {
	mock      *Storage
	params    *StorageAppendOrderParams
	paramPtrs *StorageAppendOrderParamPtrs
	results   *StorageAppendOrderResults
	Counter   uint64
}

// StorageAppendOrderParams contains parameters of the Storage.AppendOrder
type StorageAppendOrderParams struct {
	ctx   context.Context
	order model.Order
	hash  string
}

// StorageAppendOrderParamPtrs contains pointers to parameters of the Storage.AppendOrder
type StorageAppendOrderParamPtrs struct {
	ctx   *context.Context
	order *model.Order
	hash  *string
}

// StorageAppendOrderResults contains results of the Storage.AppendOrder
type StorageAppendOrderResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAppendOrder *mStorageAppendOrder) Optional() *mStorageAppendOrder {
	mmAppendOrder.optional = true
	return mmAppendOrder
}

// Expect sets up expected params for Storage.AppendOrder
func (mmAppendOrder *mStorageAppendOrder) Expect(ctx context.Context, order model.Order, hash string) *mStorageAppendOrder {
	if mmAppendOrder.mock.funcAppendOrder != nil {
		mmAppendOrder.mock.t.Fatalf("Storage.AppendOrder mock is already set by Set")
	}

	if mmAppendOrder.defaultExpectation == nil {
		mmAppendOrder.defaultExpectation = &StorageAppendOrderExpectation{}
	}

	if mmAppendOrder.defaultExpectation.paramPtrs != nil {
		mmAppendOrder.mock.t.Fatalf("Storage.AppendOrder mock is already set by ExpectParams functions")
	}

	mmAppendOrder.defaultExpectation.params = &StorageAppendOrderParams{ctx, order, hash}
	for _, e := range mmAppendOrder.expectations {
		if minimock.Equal(e.params, mmAppendOrder.defaultExpectation.params) {
			mmAppendOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAppendOrder.defaultExpectation.params)
		}
	}

	return mmAppendOrder
}

// ExpectCtxParam1 sets up expected param ctx for Storage.AppendOrder
func (mmAppendOrder *mStorageAppendOrder) ExpectCtxParam1(ctx context.Context) *mStorageAppendOrder {
	if mmAppendOrder.mock.funcAppendOrder != nil {
		mmAppendOrder.mock.t.Fatalf("Storage.AppendOrder mock is already set by Set")
	}

	if mmAppendOrder.defaultExpectation == nil {
		mmAppendOrder.defaultExpectation = &StorageAppendOrderExpectation{}
	}

	if mmAppendOrder.defaultExpectation.params != nil {
		mmAppendOrder.mock.t.Fatalf("Storage.AppendOrder mock is already set by Expect")
	}

	if mmAppendOrder.defaultExpectation.paramPtrs == nil {
		mmAppendOrder.defaultExpectation.paramPtrs = &StorageAppendOrderParamPtrs{}
	}
	mmAppendOrder.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAppendOrder
}

// ExpectOrderParam2 sets up expected param order for Storage.AppendOrder
func (mmAppendOrder *mStorageAppendOrder) ExpectOrderParam2(order model.Order) *mStorageAppendOrder {
	if mmAppendOrder.mock.funcAppendOrder != nil {
		mmAppendOrder.mock.t.Fatalf("Storage.AppendOrder mock is already set by Set")
	}

	if mmAppendOrder.defaultExpectation == nil {
		mmAppendOrder.defaultExpectation = &StorageAppendOrderExpectation{}
	}

	if mmAppendOrder.defaultExpectation.params != nil {
		mmAppendOrder.mock.t.Fatalf("Storage.AppendOrder mock is already set by Expect")
	}

	if mmAppendOrder.defaultExpectation.paramPtrs == nil {
		mmAppendOrder.defaultExpectation.paramPtrs = &StorageAppendOrderParamPtrs{}
	}
	mmAppendOrder.defaultExpectation.paramPtrs.order = &order

	return mmAppendOrder
}

// ExpectHashParam3 sets up expected param hash for Storage.AppendOrder
func (mmAppendOrder *mStorageAppendOrder) ExpectHashParam3(hash string) *mStorageAppendOrder {
	if mmAppendOrder.mock.funcAppendOrder != nil {
		mmAppendOrder.mock.t.Fatalf("Storage.AppendOrder mock is already set by Set")
	}

	if mmAppendOrder.defaultExpectation == nil {
		mmAppendOrder.defaultExpectation = &StorageAppendOrderExpectation{}
	}

	if mmAppendOrder.defaultExpectation.params != nil {
		mmAppendOrder.mock.t.Fatalf("Storage.AppendOrder mock is already set by Expect")
	}

	if mmAppendOrder.defaultExpectation.paramPtrs == nil {
		mmAppendOrder.defaultExpectation.paramPtrs = &StorageAppendOrderParamPtrs{}
	}
	mmAppendOrder.defaultExpectation.paramPtrs.hash = &hash

	return mmAppendOrder
}

// Inspect accepts an inspector function that has same arguments as the Storage.AppendOrder
func (mmAppendOrder *mStorageAppendOrder) Inspect(f func(ctx context.Context, order model.Order, hash string)) *mStorageAppendOrder {
	if mmAppendOrder.mock.inspectFuncAppendOrder != nil {
		mmAppendOrder.mock.t.Fatalf("Inspect function is already set for Storage.AppendOrder")
	}

	mmAppendOrder.mock.inspectFuncAppendOrder = f

	return mmAppendOrder
}

// Return sets up results that will be returned by Storage.AppendOrder
func (mmAppendOrder *mStorageAppendOrder) Return(err error) *Storage {
	if mmAppendOrder.mock.funcAppendOrder != nil {
		mmAppendOrder.mock.t.Fatalf("Storage.AppendOrder mock is already set by Set")
	}

	if mmAppendOrder.defaultExpectation == nil {
		mmAppendOrder.defaultExpectation = &StorageAppendOrderExpectation{mock: mmAppendOrder.mock}
	}
	mmAppendOrder.defaultExpectation.results = &StorageAppendOrderResults{err}
	return mmAppendOrder.mock
}

// Set uses given function f to mock the Storage.AppendOrder method
func (mmAppendOrder *mStorageAppendOrder) Set(f func(ctx context.Context, order model.Order, hash string) (err error)) *Storage {
	if mmAppendOrder.defaultExpectation != nil {
		mmAppendOrder.mock.t.Fatalf("Default expectation is already set for the Storage.AppendOrder method")
	}

	if len(mmAppendOrder.expectations) > 0 {
		mmAppendOrder.mock.t.Fatalf("Some expectations are already set for the Storage.AppendOrder method")
	}

	mmAppendOrder.mock.funcAppendOrder = f
	return mmAppendOrder.mock
}

// When sets expectation for the Storage.AppendOrder which will trigger the result defined by the following
// Then helper
func (mmAppendOrder *mStorageAppendOrder) When(ctx context.Context, order model.Order, hash string) *StorageAppendOrderExpectation {
	if mmAppendOrder.mock.funcAppendOrder != nil {
		mmAppendOrder.mock.t.Fatalf("Storage.AppendOrder mock is already set by Set")
	}

	expectation := &StorageAppendOrderExpectation{
		mock:   mmAppendOrder.mock,
		params: &StorageAppendOrderParams{ctx, order, hash},
	}
	mmAppendOrder.expectations = append(mmAppendOrder.expectations, expectation)
	return expectation
}

// Then sets up Storage.AppendOrder return parameters for the expectation previously defined by the When method
func (e *StorageAppendOrderExpectation) Then(err error) *Storage {
	e.results = &StorageAppendOrderResults{err}
	return e.mock
}

// Times sets number of times Storage.AppendOrder should be invoked
func (mmAppendOrder *mStorageAppendOrder) Times(n uint64) *mStorageAppendOrder {
	if n == 0 {
		mmAppendOrder.mock.t.Fatalf("Times of Storage.AppendOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAppendOrder.expectedInvocations, n)
	return mmAppendOrder
}

func (mmAppendOrder *mStorageAppendOrder) invocationsDone() bool {
	if len(mmAppendOrder.expectations) == 0 && mmAppendOrder.defaultExpectation == nil && mmAppendOrder.mock.funcAppendOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAppendOrder.mock.afterAppendOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAppendOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AppendOrder implements module.Storage
func (mmAppendOrder *Storage) AppendOrder(ctx context.Context, order model.Order, hash string) (err error) {
	mm_atomic.AddUint64(&mmAppendOrder.beforeAppendOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmAppendOrder.afterAppendOrderCounter, 1)

	if mmAppendOrder.inspectFuncAppendOrder != nil {
		mmAppendOrder.inspectFuncAppendOrder(ctx, order, hash)
	}

	mm_params := StorageAppendOrderParams{ctx, order, hash}

	// Record call args
	mmAppendOrder.AppendOrderMock.mutex.Lock()
	mmAppendOrder.AppendOrderMock.callArgs = append(mmAppendOrder.AppendOrderMock.callArgs, &mm_params)
	mmAppendOrder.AppendOrderMock.mutex.Unlock()

	for _, e := range mmAppendOrder.AppendOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAppendOrder.AppendOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAppendOrder.AppendOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmAppendOrder.AppendOrderMock.defaultExpectation.params
		mm_want_ptrs := mmAppendOrder.AppendOrderMock.defaultExpectation.paramPtrs

		mm_got := StorageAppendOrderParams{ctx, order, hash}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAppendOrder.t.Errorf("Storage.AppendOrder got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmAppendOrder.t.Errorf("Storage.AppendOrder got unexpected parameter order, want: %#v, got: %#v%s\n", *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

			if mm_want_ptrs.hash != nil && !minimock.Equal(*mm_want_ptrs.hash, mm_got.hash) {
				mmAppendOrder.t.Errorf("Storage.AppendOrder got unexpected parameter hash, want: %#v, got: %#v%s\n", *mm_want_ptrs.hash, mm_got.hash, minimock.Diff(*mm_want_ptrs.hash, mm_got.hash))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAppendOrder.t.Errorf("Storage.AppendOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAppendOrder.AppendOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmAppendOrder.t.Fatal("No results are set for the Storage.AppendOrder")
		}
		return (*mm_results).err
	}
	if mmAppendOrder.funcAppendOrder != nil {
		return mmAppendOrder.funcAppendOrder(ctx, order, hash)
	}
	mmAppendOrder.t.Fatalf("Unexpected call to Storage.AppendOrder. %v %v %v", ctx, order, hash)
	return
}

// AppendOrderAfterCounter returns a count of finished Storage.AppendOrder invocations
func (mmAppendOrder *Storage) AppendOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAppendOrder.afterAppendOrderCounter)
}

// AppendOrderBeforeCounter returns a count of Storage.AppendOrder invocations
func (mmAppendOrder *Storage) AppendOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAppendOrder.beforeAppendOrderCounter)
}

// Calls returns a list of arguments used in each call to Storage.AppendOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAppendOrder *mStorageAppendOrder) Calls() []*StorageAppendOrderParams {
	mmAppendOrder.mutex.RLock()

	argCopy := make([]*StorageAppendOrderParams, len(mmAppendOrder.callArgs))
	copy(argCopy, mmAppendOrder.callArgs)

	mmAppendOrder.mutex.RUnlock()

	return argCopy
}

// MinimockAppendOrderDone returns true if the count of the AppendOrder invocations corresponds
// the number of defined expectations
func (m *Storage) MinimockAppendOrderDone() bool {
	if m.AppendOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AppendOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AppendOrderMock.invocationsDone()
}

// MinimockAppendOrderInspect logs each unmet expectation
func (m *Storage) MinimockAppendOrderInspect() {
	for _, e := range m.AppendOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Storage.AppendOrder with params: %#v", *e.params)
		}
	}

	afterAppendOrderCounter := mm_atomic.LoadUint64(&m.afterAppendOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AppendOrderMock.defaultExpectation != nil && afterAppendOrderCounter < 1 {
		if m.AppendOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Storage.AppendOrder")
		} else {
			m.t.Errorf("Expected call to Storage.AppendOrder with params: %#v", *m.AppendOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAppendOrder != nil && afterAppendOrderCounter < 1 {
		m.t.Error("Expected call to Storage.AppendOrder")
	}

	if !m.AppendOrderMock.invocationsDone() && afterAppendOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to Storage.AppendOrder but found %d calls",
			mm_atomic.LoadUint64(&m.AppendOrderMock.expectedInvocations), afterAppendOrderCounter)
	}
}

type mStorageDeleteOrder struct {
	optional           bool
	mock               *Storage
	defaultExpectation *StorageDeleteOrderExpectation
	expectations       []*StorageDeleteOrderExpectation

	callArgs []*StorageDeleteOrderParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StorageDeleteOrderExpectation specifies expectation struct of the Storage.DeleteOrder
type StorageDeleteOrderExpectation struct {
	mock      *Storage
	params    *StorageDeleteOrderParams
	paramPtrs *StorageDeleteOrderParamPtrs
	results   *StorageDeleteOrderResults
	Counter   uint64
}

// StorageDeleteOrderParams contains parameters of the Storage.DeleteOrder
type StorageDeleteOrderParams struct {
	ctx     context.Context
	orderID model.OrderID
	hash    string
}

// StorageDeleteOrderParamPtrs contains pointers to parameters of the Storage.DeleteOrder
type StorageDeleteOrderParamPtrs struct {
	ctx     *context.Context
	orderID *model.OrderID
	hash    *string
}

// StorageDeleteOrderResults contains results of the Storage.DeleteOrder
type StorageDeleteOrderResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteOrder *mStorageDeleteOrder) Optional() *mStorageDeleteOrder {
	mmDeleteOrder.optional = true
	return mmDeleteOrder
}

// Expect sets up expected params for Storage.DeleteOrder
func (mmDeleteOrder *mStorageDeleteOrder) Expect(ctx context.Context, orderID model.OrderID, hash string) *mStorageDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("Storage.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &StorageDeleteOrderExpectation{}
	}

	if mmDeleteOrder.defaultExpectation.paramPtrs != nil {
		mmDeleteOrder.mock.t.Fatalf("Storage.DeleteOrder mock is already set by ExpectParams functions")
	}

	mmDeleteOrder.defaultExpectation.params = &StorageDeleteOrderParams{ctx, orderID, hash}
	for _, e := range mmDeleteOrder.expectations {
		if minimock.Equal(e.params, mmDeleteOrder.defaultExpectation.params) {
			mmDeleteOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteOrder.defaultExpectation.params)
		}
	}

	return mmDeleteOrder
}

// ExpectCtxParam1 sets up expected param ctx for Storage.DeleteOrder
func (mmDeleteOrder *mStorageDeleteOrder) ExpectCtxParam1(ctx context.Context) *mStorageDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("Storage.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &StorageDeleteOrderExpectation{}
	}

	if mmDeleteOrder.defaultExpectation.params != nil {
		mmDeleteOrder.mock.t.Fatalf("Storage.DeleteOrder mock is already set by Expect")
	}

	if mmDeleteOrder.defaultExpectation.paramPtrs == nil {
		mmDeleteOrder.defaultExpectation.paramPtrs = &StorageDeleteOrderParamPtrs{}
	}
	mmDeleteOrder.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteOrder
}

// ExpectOrderIDParam2 sets up expected param orderID for Storage.DeleteOrder
func (mmDeleteOrder *mStorageDeleteOrder) ExpectOrderIDParam2(orderID model.OrderID) *mStorageDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("Storage.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &StorageDeleteOrderExpectation{}
	}

	if mmDeleteOrder.defaultExpectation.params != nil {
		mmDeleteOrder.mock.t.Fatalf("Storage.DeleteOrder mock is already set by Expect")
	}

	if mmDeleteOrder.defaultExpectation.paramPtrs == nil {
		mmDeleteOrder.defaultExpectation.paramPtrs = &StorageDeleteOrderParamPtrs{}
	}
	mmDeleteOrder.defaultExpectation.paramPtrs.orderID = &orderID

	return mmDeleteOrder
}

// ExpectHashParam3 sets up expected param hash for Storage.DeleteOrder
func (mmDeleteOrder *mStorageDeleteOrder) ExpectHashParam3(hash string) *mStorageDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("Storage.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &StorageDeleteOrderExpectation{}
	}

	if mmDeleteOrder.defaultExpectation.params != nil {
		mmDeleteOrder.mock.t.Fatalf("Storage.DeleteOrder mock is already set by Expect")
	}

	if mmDeleteOrder.defaultExpectation.paramPtrs == nil {
		mmDeleteOrder.defaultExpectation.paramPtrs = &StorageDeleteOrderParamPtrs{}
	}
	mmDeleteOrder.defaultExpectation.paramPtrs.hash = &hash

	return mmDeleteOrder
}

// Inspect accepts an inspector function that has same arguments as the Storage.DeleteOrder
func (mmDeleteOrder *mStorageDeleteOrder) Inspect(f func(ctx context.Context, orderID model.OrderID, hash string)) *mStorageDeleteOrder {
	if mmDeleteOrder.mock.inspectFuncDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("Inspect function is already set for Storage.DeleteOrder")
	}

	mmDeleteOrder.mock.inspectFuncDeleteOrder = f

	return mmDeleteOrder
}

// Return sets up results that will be returned by Storage.DeleteOrder
func (mmDeleteOrder *mStorageDeleteOrder) Return(err error) *Storage {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("Storage.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &StorageDeleteOrderExpectation{mock: mmDeleteOrder.mock}
	}
	mmDeleteOrder.defaultExpectation.results = &StorageDeleteOrderResults{err}
	return mmDeleteOrder.mock
}

// Set uses given function f to mock the Storage.DeleteOrder method
func (mmDeleteOrder *mStorageDeleteOrder) Set(f func(ctx context.Context, orderID model.OrderID, hash string) (err error)) *Storage {
	if mmDeleteOrder.defaultExpectation != nil {
		mmDeleteOrder.mock.t.Fatalf("Default expectation is already set for the Storage.DeleteOrder method")
	}

	if len(mmDeleteOrder.expectations) > 0 {
		mmDeleteOrder.mock.t.Fatalf("Some expectations are already set for the Storage.DeleteOrder method")
	}

	mmDeleteOrder.mock.funcDeleteOrder = f
	return mmDeleteOrder.mock
}

// When sets expectation for the Storage.DeleteOrder which will trigger the result defined by the following
// Then helper
func (mmDeleteOrder *mStorageDeleteOrder) When(ctx context.Context, orderID model.OrderID, hash string) *StorageDeleteOrderExpectation {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("Storage.DeleteOrder mock is already set by Set")
	}

	expectation := &StorageDeleteOrderExpectation{
		mock:   mmDeleteOrder.mock,
		params: &StorageDeleteOrderParams{ctx, orderID, hash},
	}
	mmDeleteOrder.expectations = append(mmDeleteOrder.expectations, expectation)
	return expectation
}

// Then sets up Storage.DeleteOrder return parameters for the expectation previously defined by the When method
func (e *StorageDeleteOrderExpectation) Then(err error) *Storage {
	e.results = &StorageDeleteOrderResults{err}
	return e.mock
}

// Times sets number of times Storage.DeleteOrder should be invoked
func (mmDeleteOrder *mStorageDeleteOrder) Times(n uint64) *mStorageDeleteOrder {
	if n == 0 {
		mmDeleteOrder.mock.t.Fatalf("Times of Storage.DeleteOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteOrder.expectedInvocations, n)
	return mmDeleteOrder
}

func (mmDeleteOrder *mStorageDeleteOrder) invocationsDone() bool {
	if len(mmDeleteOrder.expectations) == 0 && mmDeleteOrder.defaultExpectation == nil && mmDeleteOrder.mock.funcDeleteOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteOrder.mock.afterDeleteOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteOrder implements module.Storage
func (mmDeleteOrder *Storage) DeleteOrder(ctx context.Context, orderID model.OrderID, hash string) (err error) {
	mm_atomic.AddUint64(&mmDeleteOrder.beforeDeleteOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteOrder.afterDeleteOrderCounter, 1)

	if mmDeleteOrder.inspectFuncDeleteOrder != nil {
		mmDeleteOrder.inspectFuncDeleteOrder(ctx, orderID, hash)
	}

	mm_params := StorageDeleteOrderParams{ctx, orderID, hash}

	// Record call args
	mmDeleteOrder.DeleteOrderMock.mutex.Lock()
	mmDeleteOrder.DeleteOrderMock.callArgs = append(mmDeleteOrder.DeleteOrderMock.callArgs, &mm_params)
	mmDeleteOrder.DeleteOrderMock.mutex.Unlock()

	for _, e := range mmDeleteOrder.DeleteOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteOrder.DeleteOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteOrder.DeleteOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteOrder.DeleteOrderMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteOrder.DeleteOrderMock.defaultExpectation.paramPtrs

		mm_got := StorageDeleteOrderParams{ctx, orderID, hash}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteOrder.t.Errorf("Storage.DeleteOrder got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmDeleteOrder.t.Errorf("Storage.DeleteOrder got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.hash != nil && !minimock.Equal(*mm_want_ptrs.hash, mm_got.hash) {
				mmDeleteOrder.t.Errorf("Storage.DeleteOrder got unexpected parameter hash, want: %#v, got: %#v%s\n", *mm_want_ptrs.hash, mm_got.hash, minimock.Diff(*mm_want_ptrs.hash, mm_got.hash))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteOrder.t.Errorf("Storage.DeleteOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteOrder.DeleteOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteOrder.t.Fatal("No results are set for the Storage.DeleteOrder")
		}
		return (*mm_results).err
	}
	if mmDeleteOrder.funcDeleteOrder != nil {
		return mmDeleteOrder.funcDeleteOrder(ctx, orderID, hash)
	}
	mmDeleteOrder.t.Fatalf("Unexpected call to Storage.DeleteOrder. %v %v %v", ctx, orderID, hash)
	return
}

// DeleteOrderAfterCounter returns a count of finished Storage.DeleteOrder invocations
func (mmDeleteOrder *Storage) DeleteOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrder.afterDeleteOrderCounter)
}

// DeleteOrderBeforeCounter returns a count of Storage.DeleteOrder invocations
func (mmDeleteOrder *Storage) DeleteOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrder.beforeDeleteOrderCounter)
}

// Calls returns a list of arguments used in each call to Storage.DeleteOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteOrder *mStorageDeleteOrder) Calls() []*StorageDeleteOrderParams {
	mmDeleteOrder.mutex.RLock()

	argCopy := make([]*StorageDeleteOrderParams, len(mmDeleteOrder.callArgs))
	copy(argCopy, mmDeleteOrder.callArgs)

	mmDeleteOrder.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteOrderDone returns true if the count of the DeleteOrder invocations corresponds
// the number of defined expectations
func (m *Storage) MinimockDeleteOrderDone() bool {
	if m.DeleteOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteOrderMock.invocationsDone()
}

// MinimockDeleteOrderInspect logs each unmet expectation
func (m *Storage) MinimockDeleteOrderInspect() {
	for _, e := range m.DeleteOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Storage.DeleteOrder with params: %#v", *e.params)
		}
	}

	afterDeleteOrderCounter := mm_atomic.LoadUint64(&m.afterDeleteOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteOrderMock.defaultExpectation != nil && afterDeleteOrderCounter < 1 {
		if m.DeleteOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Storage.DeleteOrder")
		} else {
			m.t.Errorf("Expected call to Storage.DeleteOrder with params: %#v", *m.DeleteOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteOrder != nil && afterDeleteOrderCounter < 1 {
		m.t.Error("Expected call to Storage.DeleteOrder")
	}

	if !m.DeleteOrderMock.invocationsDone() && afterDeleteOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to Storage.DeleteOrder but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteOrderMock.expectedInvocations), afterDeleteOrderCounter)
	}
}

type mStorageLoadOrders struct {
	optional           bool
	mock               *Storage
	defaultExpectation *StorageLoadOrdersExpectation
	expectations       []*StorageLoadOrdersExpectation

	callArgs []*StorageLoadOrdersParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StorageLoadOrdersExpectation specifies expectation struct of the Storage.LoadOrders
type StorageLoadOrdersExpectation struct {
	mock      *Storage
	params    *StorageLoadOrdersParams
	paramPtrs *StorageLoadOrdersParamPtrs
	results   *StorageLoadOrdersResults
	Counter   uint64
}

// StorageLoadOrdersParams contains parameters of the Storage.LoadOrders
type StorageLoadOrdersParams struct {
	ctx  context.Context
	hash string
}

// StorageLoadOrdersParamPtrs contains pointers to parameters of the Storage.LoadOrders
type StorageLoadOrdersParamPtrs struct {
	ctx  *context.Context
	hash *string
}

// StorageLoadOrdersResults contains results of the Storage.LoadOrders
type StorageLoadOrdersResults struct {
	oa1 []model.Order
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLoadOrders *mStorageLoadOrders) Optional() *mStorageLoadOrders {
	mmLoadOrders.optional = true
	return mmLoadOrders
}

// Expect sets up expected params for Storage.LoadOrders
func (mmLoadOrders *mStorageLoadOrders) Expect(ctx context.Context, hash string) *mStorageLoadOrders {
	if mmLoadOrders.mock.funcLoadOrders != nil {
		mmLoadOrders.mock.t.Fatalf("Storage.LoadOrders mock is already set by Set")
	}

	if mmLoadOrders.defaultExpectation == nil {
		mmLoadOrders.defaultExpectation = &StorageLoadOrdersExpectation{}
	}

	if mmLoadOrders.defaultExpectation.paramPtrs != nil {
		mmLoadOrders.mock.t.Fatalf("Storage.LoadOrders mock is already set by ExpectParams functions")
	}

	mmLoadOrders.defaultExpectation.params = &StorageLoadOrdersParams{ctx, hash}
	for _, e := range mmLoadOrders.expectations {
		if minimock.Equal(e.params, mmLoadOrders.defaultExpectation.params) {
			mmLoadOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLoadOrders.defaultExpectation.params)
		}
	}

	return mmLoadOrders
}

// ExpectCtxParam1 sets up expected param ctx for Storage.LoadOrders
func (mmLoadOrders *mStorageLoadOrders) ExpectCtxParam1(ctx context.Context) *mStorageLoadOrders {
	if mmLoadOrders.mock.funcLoadOrders != nil {
		mmLoadOrders.mock.t.Fatalf("Storage.LoadOrders mock is already set by Set")
	}

	if mmLoadOrders.defaultExpectation == nil {
		mmLoadOrders.defaultExpectation = &StorageLoadOrdersExpectation{}
	}

	if mmLoadOrders.defaultExpectation.params != nil {
		mmLoadOrders.mock.t.Fatalf("Storage.LoadOrders mock is already set by Expect")
	}

	if mmLoadOrders.defaultExpectation.paramPtrs == nil {
		mmLoadOrders.defaultExpectation.paramPtrs = &StorageLoadOrdersParamPtrs{}
	}
	mmLoadOrders.defaultExpectation.paramPtrs.ctx = &ctx

	return mmLoadOrders
}

// ExpectHashParam2 sets up expected param hash for Storage.LoadOrders
func (mmLoadOrders *mStorageLoadOrders) ExpectHashParam2(hash string) *mStorageLoadOrders {
	if mmLoadOrders.mock.funcLoadOrders != nil {
		mmLoadOrders.mock.t.Fatalf("Storage.LoadOrders mock is already set by Set")
	}

	if mmLoadOrders.defaultExpectation == nil {
		mmLoadOrders.defaultExpectation = &StorageLoadOrdersExpectation{}
	}

	if mmLoadOrders.defaultExpectation.params != nil {
		mmLoadOrders.mock.t.Fatalf("Storage.LoadOrders mock is already set by Expect")
	}

	if mmLoadOrders.defaultExpectation.paramPtrs == nil {
		mmLoadOrders.defaultExpectation.paramPtrs = &StorageLoadOrdersParamPtrs{}
	}
	mmLoadOrders.defaultExpectation.paramPtrs.hash = &hash

	return mmLoadOrders
}

// Inspect accepts an inspector function that has same arguments as the Storage.LoadOrders
func (mmLoadOrders *mStorageLoadOrders) Inspect(f func(ctx context.Context, hash string)) *mStorageLoadOrders {
	if mmLoadOrders.mock.inspectFuncLoadOrders != nil {
		mmLoadOrders.mock.t.Fatalf("Inspect function is already set for Storage.LoadOrders")
	}

	mmLoadOrders.mock.inspectFuncLoadOrders = f

	return mmLoadOrders
}

// Return sets up results that will be returned by Storage.LoadOrders
func (mmLoadOrders *mStorageLoadOrders) Return(oa1 []model.Order, err error) *Storage {
	if mmLoadOrders.mock.funcLoadOrders != nil {
		mmLoadOrders.mock.t.Fatalf("Storage.LoadOrders mock is already set by Set")
	}

	if mmLoadOrders.defaultExpectation == nil {
		mmLoadOrders.defaultExpectation = &StorageLoadOrdersExpectation{mock: mmLoadOrders.mock}
	}
	mmLoadOrders.defaultExpectation.results = &StorageLoadOrdersResults{oa1, err}
	return mmLoadOrders.mock
}

// Set uses given function f to mock the Storage.LoadOrders method
func (mmLoadOrders *mStorageLoadOrders) Set(f func(ctx context.Context, hash string) (oa1 []model.Order, err error)) *Storage {
	if mmLoadOrders.defaultExpectation != nil {
		mmLoadOrders.mock.t.Fatalf("Default expectation is already set for the Storage.LoadOrders method")
	}

	if len(mmLoadOrders.expectations) > 0 {
		mmLoadOrders.mock.t.Fatalf("Some expectations are already set for the Storage.LoadOrders method")
	}

	mmLoadOrders.mock.funcLoadOrders = f
	return mmLoadOrders.mock
}

// When sets expectation for the Storage.LoadOrders which will trigger the result defined by the following
// Then helper
func (mmLoadOrders *mStorageLoadOrders) When(ctx context.Context, hash string) *StorageLoadOrdersExpectation {
	if mmLoadOrders.mock.funcLoadOrders != nil {
		mmLoadOrders.mock.t.Fatalf("Storage.LoadOrders mock is already set by Set")
	}

	expectation := &StorageLoadOrdersExpectation{
		mock:   mmLoadOrders.mock,
		params: &StorageLoadOrdersParams{ctx, hash},
	}
	mmLoadOrders.expectations = append(mmLoadOrders.expectations, expectation)
	return expectation
}

// Then sets up Storage.LoadOrders return parameters for the expectation previously defined by the When method
func (e *StorageLoadOrdersExpectation) Then(oa1 []model.Order, err error) *Storage {
	e.results = &StorageLoadOrdersResults{oa1, err}
	return e.mock
}

// Times sets number of times Storage.LoadOrders should be invoked
func (mmLoadOrders *mStorageLoadOrders) Times(n uint64) *mStorageLoadOrders {
	if n == 0 {
		mmLoadOrders.mock.t.Fatalf("Times of Storage.LoadOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLoadOrders.expectedInvocations, n)
	return mmLoadOrders
}

func (mmLoadOrders *mStorageLoadOrders) invocationsDone() bool {
	if len(mmLoadOrders.expectations) == 0 && mmLoadOrders.defaultExpectation == nil && mmLoadOrders.mock.funcLoadOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLoadOrders.mock.afterLoadOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLoadOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LoadOrders implements module.Storage
func (mmLoadOrders *Storage) LoadOrders(ctx context.Context, hash string) (oa1 []model.Order, err error) {
	mm_atomic.AddUint64(&mmLoadOrders.beforeLoadOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmLoadOrders.afterLoadOrdersCounter, 1)

	if mmLoadOrders.inspectFuncLoadOrders != nil {
		mmLoadOrders.inspectFuncLoadOrders(ctx, hash)
	}

	mm_params := StorageLoadOrdersParams{ctx, hash}

	// Record call args
	mmLoadOrders.LoadOrdersMock.mutex.Lock()
	mmLoadOrders.LoadOrdersMock.callArgs = append(mmLoadOrders.LoadOrdersMock.callArgs, &mm_params)
	mmLoadOrders.LoadOrdersMock.mutex.Unlock()

	for _, e := range mmLoadOrders.LoadOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmLoadOrders.LoadOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLoadOrders.LoadOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmLoadOrders.LoadOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmLoadOrders.LoadOrdersMock.defaultExpectation.paramPtrs

		mm_got := StorageLoadOrdersParams{ctx, hash}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLoadOrders.t.Errorf("Storage.LoadOrders got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.hash != nil && !minimock.Equal(*mm_want_ptrs.hash, mm_got.hash) {
				mmLoadOrders.t.Errorf("Storage.LoadOrders got unexpected parameter hash, want: %#v, got: %#v%s\n", *mm_want_ptrs.hash, mm_got.hash, minimock.Diff(*mm_want_ptrs.hash, mm_got.hash))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLoadOrders.t.Errorf("Storage.LoadOrders got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLoadOrders.LoadOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmLoadOrders.t.Fatal("No results are set for the Storage.LoadOrders")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmLoadOrders.funcLoadOrders != nil {
		return mmLoadOrders.funcLoadOrders(ctx, hash)
	}
	mmLoadOrders.t.Fatalf("Unexpected call to Storage.LoadOrders. %v %v", ctx, hash)
	return
}

// LoadOrdersAfterCounter returns a count of finished Storage.LoadOrders invocations
func (mmLoadOrders *Storage) LoadOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoadOrders.afterLoadOrdersCounter)
}

// LoadOrdersBeforeCounter returns a count of Storage.LoadOrders invocations
func (mmLoadOrders *Storage) LoadOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoadOrders.beforeLoadOrdersCounter)
}

// Calls returns a list of arguments used in each call to Storage.LoadOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLoadOrders *mStorageLoadOrders) Calls() []*StorageLoadOrdersParams {
	mmLoadOrders.mutex.RLock()

	argCopy := make([]*StorageLoadOrdersParams, len(mmLoadOrders.callArgs))
	copy(argCopy, mmLoadOrders.callArgs)

	mmLoadOrders.mutex.RUnlock()

	return argCopy
}

// MinimockLoadOrdersDone returns true if the count of the LoadOrders invocations corresponds
// the number of defined expectations
func (m *Storage) MinimockLoadOrdersDone() bool {
	if m.LoadOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoadOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoadOrdersMock.invocationsDone()
}

// MinimockLoadOrdersInspect logs each unmet expectation
func (m *Storage) MinimockLoadOrdersInspect() {
	for _, e := range m.LoadOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Storage.LoadOrders with params: %#v", *e.params)
		}
	}

	afterLoadOrdersCounter := mm_atomic.LoadUint64(&m.afterLoadOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoadOrdersMock.defaultExpectation != nil && afterLoadOrdersCounter < 1 {
		if m.LoadOrdersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Storage.LoadOrders")
		} else {
			m.t.Errorf("Expected call to Storage.LoadOrders with params: %#v", *m.LoadOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLoadOrders != nil && afterLoadOrdersCounter < 1 {
		m.t.Error("Expected call to Storage.LoadOrders")
	}

	if !m.LoadOrdersMock.invocationsDone() && afterLoadOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to Storage.LoadOrders but found %d calls",
			mm_atomic.LoadUint64(&m.LoadOrdersMock.expectedInvocations), afterLoadOrdersCounter)
	}
}

type mStorageLoadPackByType struct {
	optional           bool
	mock               *Storage
	defaultExpectation *StorageLoadPackByTypeExpectation
	expectations       []*StorageLoadPackByTypeExpectation

	callArgs []*StorageLoadPackByTypeParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StorageLoadPackByTypeExpectation specifies expectation struct of the Storage.LoadPackByType
type StorageLoadPackByTypeExpectation struct {
	mock      *Storage
	params    *StorageLoadPackByTypeParams
	paramPtrs *StorageLoadPackByTypeParamPtrs
	results   *StorageLoadPackByTypeResults
	Counter   uint64
}

// StorageLoadPackByTypeParams contains parameters of the Storage.LoadPackByType
type StorageLoadPackByTypeParams struct {
	ctx         context.Context
	packageType model.PackageType
}

// StorageLoadPackByTypeParamPtrs contains pointers to parameters of the Storage.LoadPackByType
type StorageLoadPackByTypeParamPtrs struct {
	ctx         *context.Context
	packageType *model.PackageType
}

// StorageLoadPackByTypeResults contains results of the Storage.LoadPackByType
type StorageLoadPackByTypeResults struct {
	pp1 *model.Package
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLoadPackByType *mStorageLoadPackByType) Optional() *mStorageLoadPackByType {
	mmLoadPackByType.optional = true
	return mmLoadPackByType
}

// Expect sets up expected params for Storage.LoadPackByType
func (mmLoadPackByType *mStorageLoadPackByType) Expect(ctx context.Context, packageType model.PackageType) *mStorageLoadPackByType {
	if mmLoadPackByType.mock.funcLoadPackByType != nil {
		mmLoadPackByType.mock.t.Fatalf("Storage.LoadPackByType mock is already set by Set")
	}

	if mmLoadPackByType.defaultExpectation == nil {
		mmLoadPackByType.defaultExpectation = &StorageLoadPackByTypeExpectation{}
	}

	if mmLoadPackByType.defaultExpectation.paramPtrs != nil {
		mmLoadPackByType.mock.t.Fatalf("Storage.LoadPackByType mock is already set by ExpectParams functions")
	}

	mmLoadPackByType.defaultExpectation.params = &StorageLoadPackByTypeParams{ctx, packageType}
	for _, e := range mmLoadPackByType.expectations {
		if minimock.Equal(e.params, mmLoadPackByType.defaultExpectation.params) {
			mmLoadPackByType.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLoadPackByType.defaultExpectation.params)
		}
	}

	return mmLoadPackByType
}

// ExpectCtxParam1 sets up expected param ctx for Storage.LoadPackByType
func (mmLoadPackByType *mStorageLoadPackByType) ExpectCtxParam1(ctx context.Context) *mStorageLoadPackByType {
	if mmLoadPackByType.mock.funcLoadPackByType != nil {
		mmLoadPackByType.mock.t.Fatalf("Storage.LoadPackByType mock is already set by Set")
	}

	if mmLoadPackByType.defaultExpectation == nil {
		mmLoadPackByType.defaultExpectation = &StorageLoadPackByTypeExpectation{}
	}

	if mmLoadPackByType.defaultExpectation.params != nil {
		mmLoadPackByType.mock.t.Fatalf("Storage.LoadPackByType mock is already set by Expect")
	}

	if mmLoadPackByType.defaultExpectation.paramPtrs == nil {
		mmLoadPackByType.defaultExpectation.paramPtrs = &StorageLoadPackByTypeParamPtrs{}
	}
	mmLoadPackByType.defaultExpectation.paramPtrs.ctx = &ctx

	return mmLoadPackByType
}

// ExpectPackageTypeParam2 sets up expected param packageType for Storage.LoadPackByType
func (mmLoadPackByType *mStorageLoadPackByType) ExpectPackageTypeParam2(packageType model.PackageType) *mStorageLoadPackByType {
	if mmLoadPackByType.mock.funcLoadPackByType != nil {
		mmLoadPackByType.mock.t.Fatalf("Storage.LoadPackByType mock is already set by Set")
	}

	if mmLoadPackByType.defaultExpectation == nil {
		mmLoadPackByType.defaultExpectation = &StorageLoadPackByTypeExpectation{}
	}

	if mmLoadPackByType.defaultExpectation.params != nil {
		mmLoadPackByType.mock.t.Fatalf("Storage.LoadPackByType mock is already set by Expect")
	}

	if mmLoadPackByType.defaultExpectation.paramPtrs == nil {
		mmLoadPackByType.defaultExpectation.paramPtrs = &StorageLoadPackByTypeParamPtrs{}
	}
	mmLoadPackByType.defaultExpectation.paramPtrs.packageType = &packageType

	return mmLoadPackByType
}

// Inspect accepts an inspector function that has same arguments as the Storage.LoadPackByType
func (mmLoadPackByType *mStorageLoadPackByType) Inspect(f func(ctx context.Context, packageType model.PackageType)) *mStorageLoadPackByType {
	if mmLoadPackByType.mock.inspectFuncLoadPackByType != nil {
		mmLoadPackByType.mock.t.Fatalf("Inspect function is already set for Storage.LoadPackByType")
	}

	mmLoadPackByType.mock.inspectFuncLoadPackByType = f

	return mmLoadPackByType
}

// Return sets up results that will be returned by Storage.LoadPackByType
func (mmLoadPackByType *mStorageLoadPackByType) Return(pp1 *model.Package, err error) *Storage {
	if mmLoadPackByType.mock.funcLoadPackByType != nil {
		mmLoadPackByType.mock.t.Fatalf("Storage.LoadPackByType mock is already set by Set")
	}

	if mmLoadPackByType.defaultExpectation == nil {
		mmLoadPackByType.defaultExpectation = &StorageLoadPackByTypeExpectation{mock: mmLoadPackByType.mock}
	}
	mmLoadPackByType.defaultExpectation.results = &StorageLoadPackByTypeResults{pp1, err}
	return mmLoadPackByType.mock
}

// Set uses given function f to mock the Storage.LoadPackByType method
func (mmLoadPackByType *mStorageLoadPackByType) Set(f func(ctx context.Context, packageType model.PackageType) (pp1 *model.Package, err error)) *Storage {
	if mmLoadPackByType.defaultExpectation != nil {
		mmLoadPackByType.mock.t.Fatalf("Default expectation is already set for the Storage.LoadPackByType method")
	}

	if len(mmLoadPackByType.expectations) > 0 {
		mmLoadPackByType.mock.t.Fatalf("Some expectations are already set for the Storage.LoadPackByType method")
	}

	mmLoadPackByType.mock.funcLoadPackByType = f
	return mmLoadPackByType.mock
}

// When sets expectation for the Storage.LoadPackByType which will trigger the result defined by the following
// Then helper
func (mmLoadPackByType *mStorageLoadPackByType) When(ctx context.Context, packageType model.PackageType) *StorageLoadPackByTypeExpectation {
	if mmLoadPackByType.mock.funcLoadPackByType != nil {
		mmLoadPackByType.mock.t.Fatalf("Storage.LoadPackByType mock is already set by Set")
	}

	expectation := &StorageLoadPackByTypeExpectation{
		mock:   mmLoadPackByType.mock,
		params: &StorageLoadPackByTypeParams{ctx, packageType},
	}
	mmLoadPackByType.expectations = append(mmLoadPackByType.expectations, expectation)
	return expectation
}

// Then sets up Storage.LoadPackByType return parameters for the expectation previously defined by the When method
func (e *StorageLoadPackByTypeExpectation) Then(pp1 *model.Package, err error) *Storage {
	e.results = &StorageLoadPackByTypeResults{pp1, err}
	return e.mock
}

// Times sets number of times Storage.LoadPackByType should be invoked
func (mmLoadPackByType *mStorageLoadPackByType) Times(n uint64) *mStorageLoadPackByType {
	if n == 0 {
		mmLoadPackByType.mock.t.Fatalf("Times of Storage.LoadPackByType mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLoadPackByType.expectedInvocations, n)
	return mmLoadPackByType
}

func (mmLoadPackByType *mStorageLoadPackByType) invocationsDone() bool {
	if len(mmLoadPackByType.expectations) == 0 && mmLoadPackByType.defaultExpectation == nil && mmLoadPackByType.mock.funcLoadPackByType == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLoadPackByType.mock.afterLoadPackByTypeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLoadPackByType.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LoadPackByType implements module.Storage
func (mmLoadPackByType *Storage) LoadPackByType(ctx context.Context, packageType model.PackageType) (pp1 *model.Package, err error) {
	mm_atomic.AddUint64(&mmLoadPackByType.beforeLoadPackByTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmLoadPackByType.afterLoadPackByTypeCounter, 1)

	if mmLoadPackByType.inspectFuncLoadPackByType != nil {
		mmLoadPackByType.inspectFuncLoadPackByType(ctx, packageType)
	}

	mm_params := StorageLoadPackByTypeParams{ctx, packageType}

	// Record call args
	mmLoadPackByType.LoadPackByTypeMock.mutex.Lock()
	mmLoadPackByType.LoadPackByTypeMock.callArgs = append(mmLoadPackByType.LoadPackByTypeMock.callArgs, &mm_params)
	mmLoadPackByType.LoadPackByTypeMock.mutex.Unlock()

	for _, e := range mmLoadPackByType.LoadPackByTypeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmLoadPackByType.LoadPackByTypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLoadPackByType.LoadPackByTypeMock.defaultExpectation.Counter, 1)
		mm_want := mmLoadPackByType.LoadPackByTypeMock.defaultExpectation.params
		mm_want_ptrs := mmLoadPackByType.LoadPackByTypeMock.defaultExpectation.paramPtrs

		mm_got := StorageLoadPackByTypeParams{ctx, packageType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLoadPackByType.t.Errorf("Storage.LoadPackByType got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.packageType != nil && !minimock.Equal(*mm_want_ptrs.packageType, mm_got.packageType) {
				mmLoadPackByType.t.Errorf("Storage.LoadPackByType got unexpected parameter packageType, want: %#v, got: %#v%s\n", *mm_want_ptrs.packageType, mm_got.packageType, minimock.Diff(*mm_want_ptrs.packageType, mm_got.packageType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLoadPackByType.t.Errorf("Storage.LoadPackByType got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLoadPackByType.LoadPackByTypeMock.defaultExpectation.results
		if mm_results == nil {
			mmLoadPackByType.t.Fatal("No results are set for the Storage.LoadPackByType")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmLoadPackByType.funcLoadPackByType != nil {
		return mmLoadPackByType.funcLoadPackByType(ctx, packageType)
	}
	mmLoadPackByType.t.Fatalf("Unexpected call to Storage.LoadPackByType. %v %v", ctx, packageType)
	return
}

// LoadPackByTypeAfterCounter returns a count of finished Storage.LoadPackByType invocations
func (mmLoadPackByType *Storage) LoadPackByTypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoadPackByType.afterLoadPackByTypeCounter)
}

// LoadPackByTypeBeforeCounter returns a count of Storage.LoadPackByType invocations
func (mmLoadPackByType *Storage) LoadPackByTypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoadPackByType.beforeLoadPackByTypeCounter)
}

// Calls returns a list of arguments used in each call to Storage.LoadPackByType.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLoadPackByType *mStorageLoadPackByType) Calls() []*StorageLoadPackByTypeParams {
	mmLoadPackByType.mutex.RLock()

	argCopy := make([]*StorageLoadPackByTypeParams, len(mmLoadPackByType.callArgs))
	copy(argCopy, mmLoadPackByType.callArgs)

	mmLoadPackByType.mutex.RUnlock()

	return argCopy
}

// MinimockLoadPackByTypeDone returns true if the count of the LoadPackByType invocations corresponds
// the number of defined expectations
func (m *Storage) MinimockLoadPackByTypeDone() bool {
	if m.LoadPackByTypeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoadPackByTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoadPackByTypeMock.invocationsDone()
}

// MinimockLoadPackByTypeInspect logs each unmet expectation
func (m *Storage) MinimockLoadPackByTypeInspect() {
	for _, e := range m.LoadPackByTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Storage.LoadPackByType with params: %#v", *e.params)
		}
	}

	afterLoadPackByTypeCounter := mm_atomic.LoadUint64(&m.afterLoadPackByTypeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoadPackByTypeMock.defaultExpectation != nil && afterLoadPackByTypeCounter < 1 {
		if m.LoadPackByTypeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Storage.LoadPackByType")
		} else {
			m.t.Errorf("Expected call to Storage.LoadPackByType with params: %#v", *m.LoadPackByTypeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLoadPackByType != nil && afterLoadPackByTypeCounter < 1 {
		m.t.Error("Expected call to Storage.LoadPackByType")
	}

	if !m.LoadPackByTypeMock.invocationsDone() && afterLoadPackByTypeCounter > 0 {
		m.t.Errorf("Expected %d calls to Storage.LoadPackByType but found %d calls",
			mm_atomic.LoadUint64(&m.LoadPackByTypeMock.expectedInvocations), afterLoadPackByTypeCounter)
	}
}

type mStorageLoadPackages struct {
	optional           bool
	mock               *Storage
	defaultExpectation *StorageLoadPackagesExpectation
	expectations       []*StorageLoadPackagesExpectation

	callArgs []*StorageLoadPackagesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StorageLoadPackagesExpectation specifies expectation struct of the Storage.LoadPackages
type StorageLoadPackagesExpectation struct {
	mock      *Storage
	params    *StorageLoadPackagesParams
	paramPtrs *StorageLoadPackagesParamPtrs
	results   *StorageLoadPackagesResults
	Counter   uint64
}

// StorageLoadPackagesParams contains parameters of the Storage.LoadPackages
type StorageLoadPackagesParams struct {
	ctx context.Context
}

// StorageLoadPackagesParamPtrs contains pointers to parameters of the Storage.LoadPackages
type StorageLoadPackagesParamPtrs struct {
	ctx *context.Context
}

// StorageLoadPackagesResults contains results of the Storage.LoadPackages
type StorageLoadPackagesResults struct {
	pa1 []model.Package
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLoadPackages *mStorageLoadPackages) Optional() *mStorageLoadPackages {
	mmLoadPackages.optional = true
	return mmLoadPackages
}

// Expect sets up expected params for Storage.LoadPackages
func (mmLoadPackages *mStorageLoadPackages) Expect(ctx context.Context) *mStorageLoadPackages {
	if mmLoadPackages.mock.funcLoadPackages != nil {
		mmLoadPackages.mock.t.Fatalf("Storage.LoadPackages mock is already set by Set")
	}

	if mmLoadPackages.defaultExpectation == nil {
		mmLoadPackages.defaultExpectation = &StorageLoadPackagesExpectation{}
	}

	if mmLoadPackages.defaultExpectation.paramPtrs != nil {
		mmLoadPackages.mock.t.Fatalf("Storage.LoadPackages mock is already set by ExpectParams functions")
	}

	mmLoadPackages.defaultExpectation.params = &StorageLoadPackagesParams{ctx}
	for _, e := range mmLoadPackages.expectations {
		if minimock.Equal(e.params, mmLoadPackages.defaultExpectation.params) {
			mmLoadPackages.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLoadPackages.defaultExpectation.params)
		}
	}

	return mmLoadPackages
}

// ExpectCtxParam1 sets up expected param ctx for Storage.LoadPackages
func (mmLoadPackages *mStorageLoadPackages) ExpectCtxParam1(ctx context.Context) *mStorageLoadPackages {
	if mmLoadPackages.mock.funcLoadPackages != nil {
		mmLoadPackages.mock.t.Fatalf("Storage.LoadPackages mock is already set by Set")
	}

	if mmLoadPackages.defaultExpectation == nil {
		mmLoadPackages.defaultExpectation = &StorageLoadPackagesExpectation{}
	}

	if mmLoadPackages.defaultExpectation.params != nil {
		mmLoadPackages.mock.t.Fatalf("Storage.LoadPackages mock is already set by Expect")
	}

	if mmLoadPackages.defaultExpectation.paramPtrs == nil {
		mmLoadPackages.defaultExpectation.paramPtrs = &StorageLoadPackagesParamPtrs{}
	}
	mmLoadPackages.defaultExpectation.paramPtrs.ctx = &ctx

	return mmLoadPackages
}

// Inspect accepts an inspector function that has same arguments as the Storage.LoadPackages
func (mmLoadPackages *mStorageLoadPackages) Inspect(f func(ctx context.Context)) *mStorageLoadPackages {
	if mmLoadPackages.mock.inspectFuncLoadPackages != nil {
		mmLoadPackages.mock.t.Fatalf("Inspect function is already set for Storage.LoadPackages")
	}

	mmLoadPackages.mock.inspectFuncLoadPackages = f

	return mmLoadPackages
}

// Return sets up results that will be returned by Storage.LoadPackages
func (mmLoadPackages *mStorageLoadPackages) Return(pa1 []model.Package, err error) *Storage {
	if mmLoadPackages.mock.funcLoadPackages != nil {
		mmLoadPackages.mock.t.Fatalf("Storage.LoadPackages mock is already set by Set")
	}

	if mmLoadPackages.defaultExpectation == nil {
		mmLoadPackages.defaultExpectation = &StorageLoadPackagesExpectation{mock: mmLoadPackages.mock}
	}
	mmLoadPackages.defaultExpectation.results = &StorageLoadPackagesResults{pa1, err}
	return mmLoadPackages.mock
}

// Set uses given function f to mock the Storage.LoadPackages method
func (mmLoadPackages *mStorageLoadPackages) Set(f func(ctx context.Context) (pa1 []model.Package, err error)) *Storage {
	if mmLoadPackages.defaultExpectation != nil {
		mmLoadPackages.mock.t.Fatalf("Default expectation is already set for the Storage.LoadPackages method")
	}

	if len(mmLoadPackages.expectations) > 0 {
		mmLoadPackages.mock.t.Fatalf("Some expectations are already set for the Storage.LoadPackages method")
	}

	mmLoadPackages.mock.funcLoadPackages = f
	return mmLoadPackages.mock
}

// When sets expectation for the Storage.LoadPackages which will trigger the result defined by the following
// Then helper
func (mmLoadPackages *mStorageLoadPackages) When(ctx context.Context) *StorageLoadPackagesExpectation {
	if mmLoadPackages.mock.funcLoadPackages != nil {
		mmLoadPackages.mock.t.Fatalf("Storage.LoadPackages mock is already set by Set")
	}

	expectation := &StorageLoadPackagesExpectation{
		mock:   mmLoadPackages.mock,
		params: &StorageLoadPackagesParams{ctx},
	}
	mmLoadPackages.expectations = append(mmLoadPackages.expectations, expectation)
	return expectation
}

// Then sets up Storage.LoadPackages return parameters for the expectation previously defined by the When method
func (e *StorageLoadPackagesExpectation) Then(pa1 []model.Package, err error) *Storage {
	e.results = &StorageLoadPackagesResults{pa1, err}
	return e.mock
}

// Times sets number of times Storage.LoadPackages should be invoked
func (mmLoadPackages *mStorageLoadPackages) Times(n uint64) *mStorageLoadPackages {
	if n == 0 {
		mmLoadPackages.mock.t.Fatalf("Times of Storage.LoadPackages mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLoadPackages.expectedInvocations, n)
	return mmLoadPackages
}

func (mmLoadPackages *mStorageLoadPackages) invocationsDone() bool {
	if len(mmLoadPackages.expectations) == 0 && mmLoadPackages.defaultExpectation == nil && mmLoadPackages.mock.funcLoadPackages == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLoadPackages.mock.afterLoadPackagesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLoadPackages.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LoadPackages implements module.Storage
func (mmLoadPackages *Storage) LoadPackages(ctx context.Context) (pa1 []model.Package, err error) {
	mm_atomic.AddUint64(&mmLoadPackages.beforeLoadPackagesCounter, 1)
	defer mm_atomic.AddUint64(&mmLoadPackages.afterLoadPackagesCounter, 1)

	if mmLoadPackages.inspectFuncLoadPackages != nil {
		mmLoadPackages.inspectFuncLoadPackages(ctx)
	}

	mm_params := StorageLoadPackagesParams{ctx}

	// Record call args
	mmLoadPackages.LoadPackagesMock.mutex.Lock()
	mmLoadPackages.LoadPackagesMock.callArgs = append(mmLoadPackages.LoadPackagesMock.callArgs, &mm_params)
	mmLoadPackages.LoadPackagesMock.mutex.Unlock()

	for _, e := range mmLoadPackages.LoadPackagesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmLoadPackages.LoadPackagesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLoadPackages.LoadPackagesMock.defaultExpectation.Counter, 1)
		mm_want := mmLoadPackages.LoadPackagesMock.defaultExpectation.params
		mm_want_ptrs := mmLoadPackages.LoadPackagesMock.defaultExpectation.paramPtrs

		mm_got := StorageLoadPackagesParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLoadPackages.t.Errorf("Storage.LoadPackages got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLoadPackages.t.Errorf("Storage.LoadPackages got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLoadPackages.LoadPackagesMock.defaultExpectation.results
		if mm_results == nil {
			mmLoadPackages.t.Fatal("No results are set for the Storage.LoadPackages")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmLoadPackages.funcLoadPackages != nil {
		return mmLoadPackages.funcLoadPackages(ctx)
	}
	mmLoadPackages.t.Fatalf("Unexpected call to Storage.LoadPackages. %v", ctx)
	return
}

// LoadPackagesAfterCounter returns a count of finished Storage.LoadPackages invocations
func (mmLoadPackages *Storage) LoadPackagesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoadPackages.afterLoadPackagesCounter)
}

// LoadPackagesBeforeCounter returns a count of Storage.LoadPackages invocations
func (mmLoadPackages *Storage) LoadPackagesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoadPackages.beforeLoadPackagesCounter)
}

// Calls returns a list of arguments used in each call to Storage.LoadPackages.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLoadPackages *mStorageLoadPackages) Calls() []*StorageLoadPackagesParams {
	mmLoadPackages.mutex.RLock()

	argCopy := make([]*StorageLoadPackagesParams, len(mmLoadPackages.callArgs))
	copy(argCopy, mmLoadPackages.callArgs)

	mmLoadPackages.mutex.RUnlock()

	return argCopy
}

// MinimockLoadPackagesDone returns true if the count of the LoadPackages invocations corresponds
// the number of defined expectations
func (m *Storage) MinimockLoadPackagesDone() bool {
	if m.LoadPackagesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoadPackagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoadPackagesMock.invocationsDone()
}

// MinimockLoadPackagesInspect logs each unmet expectation
func (m *Storage) MinimockLoadPackagesInspect() {
	for _, e := range m.LoadPackagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Storage.LoadPackages with params: %#v", *e.params)
		}
	}

	afterLoadPackagesCounter := mm_atomic.LoadUint64(&m.afterLoadPackagesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoadPackagesMock.defaultExpectation != nil && afterLoadPackagesCounter < 1 {
		if m.LoadPackagesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Storage.LoadPackages")
		} else {
			m.t.Errorf("Expected call to Storage.LoadPackages with params: %#v", *m.LoadPackagesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLoadPackages != nil && afterLoadPackagesCounter < 1 {
		m.t.Error("Expected call to Storage.LoadPackages")
	}

	if !m.LoadPackagesMock.invocationsDone() && afterLoadPackagesCounter > 0 {
		m.t.Errorf("Expected %d calls to Storage.LoadPackages but found %d calls",
			mm_atomic.LoadUint64(&m.LoadPackagesMock.expectedInvocations), afterLoadPackagesCounter)
	}
}

type mStorageOrderByClientIDOrderID struct {
	optional           bool
	mock               *Storage
	defaultExpectation *StorageOrderByClientIDOrderIDExpectation
	expectations       []*StorageOrderByClientIDOrderIDExpectation

	callArgs []*StorageOrderByClientIDOrderIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StorageOrderByClientIDOrderIDExpectation specifies expectation struct of the Storage.OrderByClientIDOrderID
type StorageOrderByClientIDOrderIDExpectation struct {
	mock      *Storage
	params    *StorageOrderByClientIDOrderIDParams
	paramPtrs *StorageOrderByClientIDOrderIDParamPtrs
	results   *StorageOrderByClientIDOrderIDResults
	Counter   uint64
}

// StorageOrderByClientIDOrderIDParams contains parameters of the Storage.OrderByClientIDOrderID
type StorageOrderByClientIDOrderIDParams struct {
	orderID  model.OrderID
	clientID model.ClientID
	c1       context.Context
	hash     string
}

// StorageOrderByClientIDOrderIDParamPtrs contains pointers to parameters of the Storage.OrderByClientIDOrderID
type StorageOrderByClientIDOrderIDParamPtrs struct {
	orderID  *model.OrderID
	clientID *model.ClientID
	c1       *context.Context
	hash     *string
}

// StorageOrderByClientIDOrderIDResults contains results of the Storage.OrderByClientIDOrderID
type StorageOrderByClientIDOrderIDResults struct {
	op1 *model.Order
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderByClientIDOrderID *mStorageOrderByClientIDOrderID) Optional() *mStorageOrderByClientIDOrderID {
	mmOrderByClientIDOrderID.optional = true
	return mmOrderByClientIDOrderID
}

// Expect sets up expected params for Storage.OrderByClientIDOrderID
func (mmOrderByClientIDOrderID *mStorageOrderByClientIDOrderID) Expect(orderID model.OrderID, clientID model.ClientID, c1 context.Context, hash string) *mStorageOrderByClientIDOrderID {
	if mmOrderByClientIDOrderID.mock.funcOrderByClientIDOrderID != nil {
		mmOrderByClientIDOrderID.mock.t.Fatalf("Storage.OrderByClientIDOrderID mock is already set by Set")
	}

	if mmOrderByClientIDOrderID.defaultExpectation == nil {
		mmOrderByClientIDOrderID.defaultExpectation = &StorageOrderByClientIDOrderIDExpectation{}
	}

	if mmOrderByClientIDOrderID.defaultExpectation.paramPtrs != nil {
		mmOrderByClientIDOrderID.mock.t.Fatalf("Storage.OrderByClientIDOrderID mock is already set by ExpectParams functions")
	}

	mmOrderByClientIDOrderID.defaultExpectation.params = &StorageOrderByClientIDOrderIDParams{orderID, clientID, c1, hash}
	for _, e := range mmOrderByClientIDOrderID.expectations {
		if minimock.Equal(e.params, mmOrderByClientIDOrderID.defaultExpectation.params) {
			mmOrderByClientIDOrderID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderByClientIDOrderID.defaultExpectation.params)
		}
	}

	return mmOrderByClientIDOrderID
}

// ExpectOrderIDParam1 sets up expected param orderID for Storage.OrderByClientIDOrderID
func (mmOrderByClientIDOrderID *mStorageOrderByClientIDOrderID) ExpectOrderIDParam1(orderID model.OrderID) *mStorageOrderByClientIDOrderID {
	if mmOrderByClientIDOrderID.mock.funcOrderByClientIDOrderID != nil {
		mmOrderByClientIDOrderID.mock.t.Fatalf("Storage.OrderByClientIDOrderID mock is already set by Set")
	}

	if mmOrderByClientIDOrderID.defaultExpectation == nil {
		mmOrderByClientIDOrderID.defaultExpectation = &StorageOrderByClientIDOrderIDExpectation{}
	}

	if mmOrderByClientIDOrderID.defaultExpectation.params != nil {
		mmOrderByClientIDOrderID.mock.t.Fatalf("Storage.OrderByClientIDOrderID mock is already set by Expect")
	}

	if mmOrderByClientIDOrderID.defaultExpectation.paramPtrs == nil {
		mmOrderByClientIDOrderID.defaultExpectation.paramPtrs = &StorageOrderByClientIDOrderIDParamPtrs{}
	}
	mmOrderByClientIDOrderID.defaultExpectation.paramPtrs.orderID = &orderID

	return mmOrderByClientIDOrderID
}

// ExpectClientIDParam2 sets up expected param clientID for Storage.OrderByClientIDOrderID
func (mmOrderByClientIDOrderID *mStorageOrderByClientIDOrderID) ExpectClientIDParam2(clientID model.ClientID) *mStorageOrderByClientIDOrderID {
	if mmOrderByClientIDOrderID.mock.funcOrderByClientIDOrderID != nil {
		mmOrderByClientIDOrderID.mock.t.Fatalf("Storage.OrderByClientIDOrderID mock is already set by Set")
	}

	if mmOrderByClientIDOrderID.defaultExpectation == nil {
		mmOrderByClientIDOrderID.defaultExpectation = &StorageOrderByClientIDOrderIDExpectation{}
	}

	if mmOrderByClientIDOrderID.defaultExpectation.params != nil {
		mmOrderByClientIDOrderID.mock.t.Fatalf("Storage.OrderByClientIDOrderID mock is already set by Expect")
	}

	if mmOrderByClientIDOrderID.defaultExpectation.paramPtrs == nil {
		mmOrderByClientIDOrderID.defaultExpectation.paramPtrs = &StorageOrderByClientIDOrderIDParamPtrs{}
	}
	mmOrderByClientIDOrderID.defaultExpectation.paramPtrs.clientID = &clientID

	return mmOrderByClientIDOrderID
}

// ExpectC1Param3 sets up expected param c1 for Storage.OrderByClientIDOrderID
func (mmOrderByClientIDOrderID *mStorageOrderByClientIDOrderID) ExpectC1Param3(c1 context.Context) *mStorageOrderByClientIDOrderID {
	if mmOrderByClientIDOrderID.mock.funcOrderByClientIDOrderID != nil {
		mmOrderByClientIDOrderID.mock.t.Fatalf("Storage.OrderByClientIDOrderID mock is already set by Set")
	}

	if mmOrderByClientIDOrderID.defaultExpectation == nil {
		mmOrderByClientIDOrderID.defaultExpectation = &StorageOrderByClientIDOrderIDExpectation{}
	}

	if mmOrderByClientIDOrderID.defaultExpectation.params != nil {
		mmOrderByClientIDOrderID.mock.t.Fatalf("Storage.OrderByClientIDOrderID mock is already set by Expect")
	}

	if mmOrderByClientIDOrderID.defaultExpectation.paramPtrs == nil {
		mmOrderByClientIDOrderID.defaultExpectation.paramPtrs = &StorageOrderByClientIDOrderIDParamPtrs{}
	}
	mmOrderByClientIDOrderID.defaultExpectation.paramPtrs.c1 = &c1

	return mmOrderByClientIDOrderID
}

// ExpectHashParam4 sets up expected param hash for Storage.OrderByClientIDOrderID
func (mmOrderByClientIDOrderID *mStorageOrderByClientIDOrderID) ExpectHashParam4(hash string) *mStorageOrderByClientIDOrderID {
	if mmOrderByClientIDOrderID.mock.funcOrderByClientIDOrderID != nil {
		mmOrderByClientIDOrderID.mock.t.Fatalf("Storage.OrderByClientIDOrderID mock is already set by Set")
	}

	if mmOrderByClientIDOrderID.defaultExpectation == nil {
		mmOrderByClientIDOrderID.defaultExpectation = &StorageOrderByClientIDOrderIDExpectation{}
	}

	if mmOrderByClientIDOrderID.defaultExpectation.params != nil {
		mmOrderByClientIDOrderID.mock.t.Fatalf("Storage.OrderByClientIDOrderID mock is already set by Expect")
	}

	if mmOrderByClientIDOrderID.defaultExpectation.paramPtrs == nil {
		mmOrderByClientIDOrderID.defaultExpectation.paramPtrs = &StorageOrderByClientIDOrderIDParamPtrs{}
	}
	mmOrderByClientIDOrderID.defaultExpectation.paramPtrs.hash = &hash

	return mmOrderByClientIDOrderID
}

// Inspect accepts an inspector function that has same arguments as the Storage.OrderByClientIDOrderID
func (mmOrderByClientIDOrderID *mStorageOrderByClientIDOrderID) Inspect(f func(orderID model.OrderID, clientID model.ClientID, c1 context.Context, hash string)) *mStorageOrderByClientIDOrderID {
	if mmOrderByClientIDOrderID.mock.inspectFuncOrderByClientIDOrderID != nil {
		mmOrderByClientIDOrderID.mock.t.Fatalf("Inspect function is already set for Storage.OrderByClientIDOrderID")
	}

	mmOrderByClientIDOrderID.mock.inspectFuncOrderByClientIDOrderID = f

	return mmOrderByClientIDOrderID
}

// Return sets up results that will be returned by Storage.OrderByClientIDOrderID
func (mmOrderByClientIDOrderID *mStorageOrderByClientIDOrderID) Return(op1 *model.Order, err error) *Storage {
	if mmOrderByClientIDOrderID.mock.funcOrderByClientIDOrderID != nil {
		mmOrderByClientIDOrderID.mock.t.Fatalf("Storage.OrderByClientIDOrderID mock is already set by Set")
	}

	if mmOrderByClientIDOrderID.defaultExpectation == nil {
		mmOrderByClientIDOrderID.defaultExpectation = &StorageOrderByClientIDOrderIDExpectation{mock: mmOrderByClientIDOrderID.mock}
	}
	mmOrderByClientIDOrderID.defaultExpectation.results = &StorageOrderByClientIDOrderIDResults{op1, err}
	return mmOrderByClientIDOrderID.mock
}

// Set uses given function f to mock the Storage.OrderByClientIDOrderID method
func (mmOrderByClientIDOrderID *mStorageOrderByClientIDOrderID) Set(f func(orderID model.OrderID, clientID model.ClientID, c1 context.Context, hash string) (op1 *model.Order, err error)) *Storage {
	if mmOrderByClientIDOrderID.defaultExpectation != nil {
		mmOrderByClientIDOrderID.mock.t.Fatalf("Default expectation is already set for the Storage.OrderByClientIDOrderID method")
	}

	if len(mmOrderByClientIDOrderID.expectations) > 0 {
		mmOrderByClientIDOrderID.mock.t.Fatalf("Some expectations are already set for the Storage.OrderByClientIDOrderID method")
	}

	mmOrderByClientIDOrderID.mock.funcOrderByClientIDOrderID = f
	return mmOrderByClientIDOrderID.mock
}

// When sets expectation for the Storage.OrderByClientIDOrderID which will trigger the result defined by the following
// Then helper
func (mmOrderByClientIDOrderID *mStorageOrderByClientIDOrderID) When(orderID model.OrderID, clientID model.ClientID, c1 context.Context, hash string) *StorageOrderByClientIDOrderIDExpectation {
	if mmOrderByClientIDOrderID.mock.funcOrderByClientIDOrderID != nil {
		mmOrderByClientIDOrderID.mock.t.Fatalf("Storage.OrderByClientIDOrderID mock is already set by Set")
	}

	expectation := &StorageOrderByClientIDOrderIDExpectation{
		mock:   mmOrderByClientIDOrderID.mock,
		params: &StorageOrderByClientIDOrderIDParams{orderID, clientID, c1, hash},
	}
	mmOrderByClientIDOrderID.expectations = append(mmOrderByClientIDOrderID.expectations, expectation)
	return expectation
}

// Then sets up Storage.OrderByClientIDOrderID return parameters for the expectation previously defined by the When method
func (e *StorageOrderByClientIDOrderIDExpectation) Then(op1 *model.Order, err error) *Storage {
	e.results = &StorageOrderByClientIDOrderIDResults{op1, err}
	return e.mock
}

// Times sets number of times Storage.OrderByClientIDOrderID should be invoked
func (mmOrderByClientIDOrderID *mStorageOrderByClientIDOrderID) Times(n uint64) *mStorageOrderByClientIDOrderID {
	if n == 0 {
		mmOrderByClientIDOrderID.mock.t.Fatalf("Times of Storage.OrderByClientIDOrderID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderByClientIDOrderID.expectedInvocations, n)
	return mmOrderByClientIDOrderID
}

func (mmOrderByClientIDOrderID *mStorageOrderByClientIDOrderID) invocationsDone() bool {
	if len(mmOrderByClientIDOrderID.expectations) == 0 && mmOrderByClientIDOrderID.defaultExpectation == nil && mmOrderByClientIDOrderID.mock.funcOrderByClientIDOrderID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderByClientIDOrderID.mock.afterOrderByClientIDOrderIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderByClientIDOrderID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderByClientIDOrderID implements module.Storage
func (mmOrderByClientIDOrderID *Storage) OrderByClientIDOrderID(orderID model.OrderID, clientID model.ClientID, c1 context.Context, hash string) (op1 *model.Order, err error) {
	mm_atomic.AddUint64(&mmOrderByClientIDOrderID.beforeOrderByClientIDOrderIDCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderByClientIDOrderID.afterOrderByClientIDOrderIDCounter, 1)

	if mmOrderByClientIDOrderID.inspectFuncOrderByClientIDOrderID != nil {
		mmOrderByClientIDOrderID.inspectFuncOrderByClientIDOrderID(orderID, clientID, c1, hash)
	}

	mm_params := StorageOrderByClientIDOrderIDParams{orderID, clientID, c1, hash}

	// Record call args
	mmOrderByClientIDOrderID.OrderByClientIDOrderIDMock.mutex.Lock()
	mmOrderByClientIDOrderID.OrderByClientIDOrderIDMock.callArgs = append(mmOrderByClientIDOrderID.OrderByClientIDOrderIDMock.callArgs, &mm_params)
	mmOrderByClientIDOrderID.OrderByClientIDOrderIDMock.mutex.Unlock()

	for _, e := range mmOrderByClientIDOrderID.OrderByClientIDOrderIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmOrderByClientIDOrderID.OrderByClientIDOrderIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderByClientIDOrderID.OrderByClientIDOrderIDMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderByClientIDOrderID.OrderByClientIDOrderIDMock.defaultExpectation.params
		mm_want_ptrs := mmOrderByClientIDOrderID.OrderByClientIDOrderIDMock.defaultExpectation.paramPtrs

		mm_got := StorageOrderByClientIDOrderIDParams{orderID, clientID, c1, hash}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmOrderByClientIDOrderID.t.Errorf("Storage.OrderByClientIDOrderID got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmOrderByClientIDOrderID.t.Errorf("Storage.OrderByClientIDOrderID got unexpected parameter clientID, want: %#v, got: %#v%s\n", *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

			if mm_want_ptrs.c1 != nil && !minimock.Equal(*mm_want_ptrs.c1, mm_got.c1) {
				mmOrderByClientIDOrderID.t.Errorf("Storage.OrderByClientIDOrderID got unexpected parameter c1, want: %#v, got: %#v%s\n", *mm_want_ptrs.c1, mm_got.c1, minimock.Diff(*mm_want_ptrs.c1, mm_got.c1))
			}

			if mm_want_ptrs.hash != nil && !minimock.Equal(*mm_want_ptrs.hash, mm_got.hash) {
				mmOrderByClientIDOrderID.t.Errorf("Storage.OrderByClientIDOrderID got unexpected parameter hash, want: %#v, got: %#v%s\n", *mm_want_ptrs.hash, mm_got.hash, minimock.Diff(*mm_want_ptrs.hash, mm_got.hash))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderByClientIDOrderID.t.Errorf("Storage.OrderByClientIDOrderID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderByClientIDOrderID.OrderByClientIDOrderIDMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderByClientIDOrderID.t.Fatal("No results are set for the Storage.OrderByClientIDOrderID")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmOrderByClientIDOrderID.funcOrderByClientIDOrderID != nil {
		return mmOrderByClientIDOrderID.funcOrderByClientIDOrderID(orderID, clientID, c1, hash)
	}
	mmOrderByClientIDOrderID.t.Fatalf("Unexpected call to Storage.OrderByClientIDOrderID. %v %v %v %v", orderID, clientID, c1, hash)
	return
}

// OrderByClientIDOrderIDAfterCounter returns a count of finished Storage.OrderByClientIDOrderID invocations
func (mmOrderByClientIDOrderID *Storage) OrderByClientIDOrderIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderByClientIDOrderID.afterOrderByClientIDOrderIDCounter)
}

// OrderByClientIDOrderIDBeforeCounter returns a count of Storage.OrderByClientIDOrderID invocations
func (mmOrderByClientIDOrderID *Storage) OrderByClientIDOrderIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderByClientIDOrderID.beforeOrderByClientIDOrderIDCounter)
}

// Calls returns a list of arguments used in each call to Storage.OrderByClientIDOrderID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderByClientIDOrderID *mStorageOrderByClientIDOrderID) Calls() []*StorageOrderByClientIDOrderIDParams {
	mmOrderByClientIDOrderID.mutex.RLock()

	argCopy := make([]*StorageOrderByClientIDOrderIDParams, len(mmOrderByClientIDOrderID.callArgs))
	copy(argCopy, mmOrderByClientIDOrderID.callArgs)

	mmOrderByClientIDOrderID.mutex.RUnlock()

	return argCopy
}

// MinimockOrderByClientIDOrderIDDone returns true if the count of the OrderByClientIDOrderID invocations corresponds
// the number of defined expectations
func (m *Storage) MinimockOrderByClientIDOrderIDDone() bool {
	if m.OrderByClientIDOrderIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderByClientIDOrderIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderByClientIDOrderIDMock.invocationsDone()
}

// MinimockOrderByClientIDOrderIDInspect logs each unmet expectation
func (m *Storage) MinimockOrderByClientIDOrderIDInspect() {
	for _, e := range m.OrderByClientIDOrderIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Storage.OrderByClientIDOrderID with params: %#v", *e.params)
		}
	}

	afterOrderByClientIDOrderIDCounter := mm_atomic.LoadUint64(&m.afterOrderByClientIDOrderIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderByClientIDOrderIDMock.defaultExpectation != nil && afterOrderByClientIDOrderIDCounter < 1 {
		if m.OrderByClientIDOrderIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Storage.OrderByClientIDOrderID")
		} else {
			m.t.Errorf("Expected call to Storage.OrderByClientIDOrderID with params: %#v", *m.OrderByClientIDOrderIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderByClientIDOrderID != nil && afterOrderByClientIDOrderIDCounter < 1 {
		m.t.Error("Expected call to Storage.OrderByClientIDOrderID")
	}

	if !m.OrderByClientIDOrderIDMock.invocationsDone() && afterOrderByClientIDOrderIDCounter > 0 {
		m.t.Errorf("Expected %d calls to Storage.OrderByClientIDOrderID but found %d calls",
			mm_atomic.LoadUint64(&m.OrderByClientIDOrderIDMock.expectedInvocations), afterOrderByClientIDOrderIDCounter)
	}
}

type mStorageOrderByID struct {
	optional           bool
	mock               *Storage
	defaultExpectation *StorageOrderByIDExpectation
	expectations       []*StorageOrderByIDExpectation

	callArgs []*StorageOrderByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StorageOrderByIDExpectation specifies expectation struct of the Storage.OrderByID
type StorageOrderByIDExpectation struct {
	mock      *Storage
	params    *StorageOrderByIDParams
	paramPtrs *StorageOrderByIDParamPtrs
	results   *StorageOrderByIDResults
	Counter   uint64
}

// StorageOrderByIDParams contains parameters of the Storage.OrderByID
type StorageOrderByIDParams struct {
	ctx     context.Context
	orderID model.OrderID
	hash    string
}

// StorageOrderByIDParamPtrs contains pointers to parameters of the Storage.OrderByID
type StorageOrderByIDParamPtrs struct {
	ctx     *context.Context
	orderID *model.OrderID
	hash    *string
}

// StorageOrderByIDResults contains results of the Storage.OrderByID
type StorageOrderByIDResults struct {
	op1 *model.Order
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderByID *mStorageOrderByID) Optional() *mStorageOrderByID {
	mmOrderByID.optional = true
	return mmOrderByID
}

// Expect sets up expected params for Storage.OrderByID
func (mmOrderByID *mStorageOrderByID) Expect(ctx context.Context, orderID model.OrderID, hash string) *mStorageOrderByID {
	if mmOrderByID.mock.funcOrderByID != nil {
		mmOrderByID.mock.t.Fatalf("Storage.OrderByID mock is already set by Set")
	}

	if mmOrderByID.defaultExpectation == nil {
		mmOrderByID.defaultExpectation = &StorageOrderByIDExpectation{}
	}

	if mmOrderByID.defaultExpectation.paramPtrs != nil {
		mmOrderByID.mock.t.Fatalf("Storage.OrderByID mock is already set by ExpectParams functions")
	}

	mmOrderByID.defaultExpectation.params = &StorageOrderByIDParams{ctx, orderID, hash}
	for _, e := range mmOrderByID.expectations {
		if minimock.Equal(e.params, mmOrderByID.defaultExpectation.params) {
			mmOrderByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderByID.defaultExpectation.params)
		}
	}

	return mmOrderByID
}

// ExpectCtxParam1 sets up expected param ctx for Storage.OrderByID
func (mmOrderByID *mStorageOrderByID) ExpectCtxParam1(ctx context.Context) *mStorageOrderByID {
	if mmOrderByID.mock.funcOrderByID != nil {
		mmOrderByID.mock.t.Fatalf("Storage.OrderByID mock is already set by Set")
	}

	if mmOrderByID.defaultExpectation == nil {
		mmOrderByID.defaultExpectation = &StorageOrderByIDExpectation{}
	}

	if mmOrderByID.defaultExpectation.params != nil {
		mmOrderByID.mock.t.Fatalf("Storage.OrderByID mock is already set by Expect")
	}

	if mmOrderByID.defaultExpectation.paramPtrs == nil {
		mmOrderByID.defaultExpectation.paramPtrs = &StorageOrderByIDParamPtrs{}
	}
	mmOrderByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmOrderByID
}

// ExpectOrderIDParam2 sets up expected param orderID for Storage.OrderByID
func (mmOrderByID *mStorageOrderByID) ExpectOrderIDParam2(orderID model.OrderID) *mStorageOrderByID {
	if mmOrderByID.mock.funcOrderByID != nil {
		mmOrderByID.mock.t.Fatalf("Storage.OrderByID mock is already set by Set")
	}

	if mmOrderByID.defaultExpectation == nil {
		mmOrderByID.defaultExpectation = &StorageOrderByIDExpectation{}
	}

	if mmOrderByID.defaultExpectation.params != nil {
		mmOrderByID.mock.t.Fatalf("Storage.OrderByID mock is already set by Expect")
	}

	if mmOrderByID.defaultExpectation.paramPtrs == nil {
		mmOrderByID.defaultExpectation.paramPtrs = &StorageOrderByIDParamPtrs{}
	}
	mmOrderByID.defaultExpectation.paramPtrs.orderID = &orderID

	return mmOrderByID
}

// ExpectHashParam3 sets up expected param hash for Storage.OrderByID
func (mmOrderByID *mStorageOrderByID) ExpectHashParam3(hash string) *mStorageOrderByID {
	if mmOrderByID.mock.funcOrderByID != nil {
		mmOrderByID.mock.t.Fatalf("Storage.OrderByID mock is already set by Set")
	}

	if mmOrderByID.defaultExpectation == nil {
		mmOrderByID.defaultExpectation = &StorageOrderByIDExpectation{}
	}

	if mmOrderByID.defaultExpectation.params != nil {
		mmOrderByID.mock.t.Fatalf("Storage.OrderByID mock is already set by Expect")
	}

	if mmOrderByID.defaultExpectation.paramPtrs == nil {
		mmOrderByID.defaultExpectation.paramPtrs = &StorageOrderByIDParamPtrs{}
	}
	mmOrderByID.defaultExpectation.paramPtrs.hash = &hash

	return mmOrderByID
}

// Inspect accepts an inspector function that has same arguments as the Storage.OrderByID
func (mmOrderByID *mStorageOrderByID) Inspect(f func(ctx context.Context, orderID model.OrderID, hash string)) *mStorageOrderByID {
	if mmOrderByID.mock.inspectFuncOrderByID != nil {
		mmOrderByID.mock.t.Fatalf("Inspect function is already set for Storage.OrderByID")
	}

	mmOrderByID.mock.inspectFuncOrderByID = f

	return mmOrderByID
}

// Return sets up results that will be returned by Storage.OrderByID
func (mmOrderByID *mStorageOrderByID) Return(op1 *model.Order, err error) *Storage {
	if mmOrderByID.mock.funcOrderByID != nil {
		mmOrderByID.mock.t.Fatalf("Storage.OrderByID mock is already set by Set")
	}

	if mmOrderByID.defaultExpectation == nil {
		mmOrderByID.defaultExpectation = &StorageOrderByIDExpectation{mock: mmOrderByID.mock}
	}
	mmOrderByID.defaultExpectation.results = &StorageOrderByIDResults{op1, err}
	return mmOrderByID.mock
}

// Set uses given function f to mock the Storage.OrderByID method
func (mmOrderByID *mStorageOrderByID) Set(f func(ctx context.Context, orderID model.OrderID, hash string) (op1 *model.Order, err error)) *Storage {
	if mmOrderByID.defaultExpectation != nil {
		mmOrderByID.mock.t.Fatalf("Default expectation is already set for the Storage.OrderByID method")
	}

	if len(mmOrderByID.expectations) > 0 {
		mmOrderByID.mock.t.Fatalf("Some expectations are already set for the Storage.OrderByID method")
	}

	mmOrderByID.mock.funcOrderByID = f
	return mmOrderByID.mock
}

// When sets expectation for the Storage.OrderByID which will trigger the result defined by the following
// Then helper
func (mmOrderByID *mStorageOrderByID) When(ctx context.Context, orderID model.OrderID, hash string) *StorageOrderByIDExpectation {
	if mmOrderByID.mock.funcOrderByID != nil {
		mmOrderByID.mock.t.Fatalf("Storage.OrderByID mock is already set by Set")
	}

	expectation := &StorageOrderByIDExpectation{
		mock:   mmOrderByID.mock,
		params: &StorageOrderByIDParams{ctx, orderID, hash},
	}
	mmOrderByID.expectations = append(mmOrderByID.expectations, expectation)
	return expectation
}

// Then sets up Storage.OrderByID return parameters for the expectation previously defined by the When method
func (e *StorageOrderByIDExpectation) Then(op1 *model.Order, err error) *Storage {
	e.results = &StorageOrderByIDResults{op1, err}
	return e.mock
}

// Times sets number of times Storage.OrderByID should be invoked
func (mmOrderByID *mStorageOrderByID) Times(n uint64) *mStorageOrderByID {
	if n == 0 {
		mmOrderByID.mock.t.Fatalf("Times of Storage.OrderByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderByID.expectedInvocations, n)
	return mmOrderByID
}

func (mmOrderByID *mStorageOrderByID) invocationsDone() bool {
	if len(mmOrderByID.expectations) == 0 && mmOrderByID.defaultExpectation == nil && mmOrderByID.mock.funcOrderByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderByID.mock.afterOrderByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderByID implements module.Storage
func (mmOrderByID *Storage) OrderByID(ctx context.Context, orderID model.OrderID, hash string) (op1 *model.Order, err error) {
	mm_atomic.AddUint64(&mmOrderByID.beforeOrderByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderByID.afterOrderByIDCounter, 1)

	if mmOrderByID.inspectFuncOrderByID != nil {
		mmOrderByID.inspectFuncOrderByID(ctx, orderID, hash)
	}

	mm_params := StorageOrderByIDParams{ctx, orderID, hash}

	// Record call args
	mmOrderByID.OrderByIDMock.mutex.Lock()
	mmOrderByID.OrderByIDMock.callArgs = append(mmOrderByID.OrderByIDMock.callArgs, &mm_params)
	mmOrderByID.OrderByIDMock.mutex.Unlock()

	for _, e := range mmOrderByID.OrderByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmOrderByID.OrderByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderByID.OrderByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderByID.OrderByIDMock.defaultExpectation.params
		mm_want_ptrs := mmOrderByID.OrderByIDMock.defaultExpectation.paramPtrs

		mm_got := StorageOrderByIDParams{ctx, orderID, hash}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrderByID.t.Errorf("Storage.OrderByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmOrderByID.t.Errorf("Storage.OrderByID got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.hash != nil && !minimock.Equal(*mm_want_ptrs.hash, mm_got.hash) {
				mmOrderByID.t.Errorf("Storage.OrderByID got unexpected parameter hash, want: %#v, got: %#v%s\n", *mm_want_ptrs.hash, mm_got.hash, minimock.Diff(*mm_want_ptrs.hash, mm_got.hash))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderByID.t.Errorf("Storage.OrderByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderByID.OrderByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderByID.t.Fatal("No results are set for the Storage.OrderByID")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmOrderByID.funcOrderByID != nil {
		return mmOrderByID.funcOrderByID(ctx, orderID, hash)
	}
	mmOrderByID.t.Fatalf("Unexpected call to Storage.OrderByID. %v %v %v", ctx, orderID, hash)
	return
}

// OrderByIDAfterCounter returns a count of finished Storage.OrderByID invocations
func (mmOrderByID *Storage) OrderByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderByID.afterOrderByIDCounter)
}

// OrderByIDBeforeCounter returns a count of Storage.OrderByID invocations
func (mmOrderByID *Storage) OrderByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderByID.beforeOrderByIDCounter)
}

// Calls returns a list of arguments used in each call to Storage.OrderByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderByID *mStorageOrderByID) Calls() []*StorageOrderByIDParams {
	mmOrderByID.mutex.RLock()

	argCopy := make([]*StorageOrderByIDParams, len(mmOrderByID.callArgs))
	copy(argCopy, mmOrderByID.callArgs)

	mmOrderByID.mutex.RUnlock()

	return argCopy
}

// MinimockOrderByIDDone returns true if the count of the OrderByID invocations corresponds
// the number of defined expectations
func (m *Storage) MinimockOrderByIDDone() bool {
	if m.OrderByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderByIDMock.invocationsDone()
}

// MinimockOrderByIDInspect logs each unmet expectation
func (m *Storage) MinimockOrderByIDInspect() {
	for _, e := range m.OrderByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Storage.OrderByID with params: %#v", *e.params)
		}
	}

	afterOrderByIDCounter := mm_atomic.LoadUint64(&m.afterOrderByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderByIDMock.defaultExpectation != nil && afterOrderByIDCounter < 1 {
		if m.OrderByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Storage.OrderByID")
		} else {
			m.t.Errorf("Expected call to Storage.OrderByID with params: %#v", *m.OrderByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderByID != nil && afterOrderByIDCounter < 1 {
		m.t.Error("Expected call to Storage.OrderByID")
	}

	if !m.OrderByIDMock.invocationsDone() && afterOrderByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to Storage.OrderByID but found %d calls",
			mm_atomic.LoadUint64(&m.OrderByIDMock.expectedInvocations), afterOrderByIDCounter)
	}
}

type mStorageOrdersByGivenOrderIDList struct {
	optional           bool
	mock               *Storage
	defaultExpectation *StorageOrdersByGivenOrderIDListExpectation
	expectations       []*StorageOrdersByGivenOrderIDListExpectation

	callArgs []*StorageOrdersByGivenOrderIDListParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StorageOrdersByGivenOrderIDListExpectation specifies expectation struct of the Storage.OrdersByGivenOrderIDList
type StorageOrdersByGivenOrderIDListExpectation struct {
	mock      *Storage
	params    *StorageOrdersByGivenOrderIDListParams
	paramPtrs *StorageOrdersByGivenOrderIDListParamPtrs
	results   *StorageOrdersByGivenOrderIDListResults
	Counter   uint64
}

// StorageOrdersByGivenOrderIDListParams contains parameters of the Storage.OrdersByGivenOrderIDList
type StorageOrdersByGivenOrderIDListParams struct {
	orderIDs []model.OrderID
	ctx      context.Context
	hash     string
}

// StorageOrdersByGivenOrderIDListParamPtrs contains pointers to parameters of the Storage.OrdersByGivenOrderIDList
type StorageOrdersByGivenOrderIDListParamPtrs struct {
	orderIDs *[]model.OrderID
	ctx      *context.Context
	hash     *string
}

// StorageOrdersByGivenOrderIDListResults contains results of the Storage.OrdersByGivenOrderIDList
type StorageOrdersByGivenOrderIDListResults struct {
	oa1 []model.Order
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrdersByGivenOrderIDList *mStorageOrdersByGivenOrderIDList) Optional() *mStorageOrdersByGivenOrderIDList {
	mmOrdersByGivenOrderIDList.optional = true
	return mmOrdersByGivenOrderIDList
}

// Expect sets up expected params for Storage.OrdersByGivenOrderIDList
func (mmOrdersByGivenOrderIDList *mStorageOrdersByGivenOrderIDList) Expect(orderIDs []model.OrderID, ctx context.Context, hash string) *mStorageOrdersByGivenOrderIDList {
	if mmOrdersByGivenOrderIDList.mock.funcOrdersByGivenOrderIDList != nil {
		mmOrdersByGivenOrderIDList.mock.t.Fatalf("Storage.OrdersByGivenOrderIDList mock is already set by Set")
	}

	if mmOrdersByGivenOrderIDList.defaultExpectation == nil {
		mmOrdersByGivenOrderIDList.defaultExpectation = &StorageOrdersByGivenOrderIDListExpectation{}
	}

	if mmOrdersByGivenOrderIDList.defaultExpectation.paramPtrs != nil {
		mmOrdersByGivenOrderIDList.mock.t.Fatalf("Storage.OrdersByGivenOrderIDList mock is already set by ExpectParams functions")
	}

	mmOrdersByGivenOrderIDList.defaultExpectation.params = &StorageOrdersByGivenOrderIDListParams{orderIDs, ctx, hash}
	for _, e := range mmOrdersByGivenOrderIDList.expectations {
		if minimock.Equal(e.params, mmOrdersByGivenOrderIDList.defaultExpectation.params) {
			mmOrdersByGivenOrderIDList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrdersByGivenOrderIDList.defaultExpectation.params)
		}
	}

	return mmOrdersByGivenOrderIDList
}

// ExpectOrderIDsParam1 sets up expected param orderIDs for Storage.OrdersByGivenOrderIDList
func (mmOrdersByGivenOrderIDList *mStorageOrdersByGivenOrderIDList) ExpectOrderIDsParam1(orderIDs []model.OrderID) *mStorageOrdersByGivenOrderIDList {
	if mmOrdersByGivenOrderIDList.mock.funcOrdersByGivenOrderIDList != nil {
		mmOrdersByGivenOrderIDList.mock.t.Fatalf("Storage.OrdersByGivenOrderIDList mock is already set by Set")
	}

	if mmOrdersByGivenOrderIDList.defaultExpectation == nil {
		mmOrdersByGivenOrderIDList.defaultExpectation = &StorageOrdersByGivenOrderIDListExpectation{}
	}

	if mmOrdersByGivenOrderIDList.defaultExpectation.params != nil {
		mmOrdersByGivenOrderIDList.mock.t.Fatalf("Storage.OrdersByGivenOrderIDList mock is already set by Expect")
	}

	if mmOrdersByGivenOrderIDList.defaultExpectation.paramPtrs == nil {
		mmOrdersByGivenOrderIDList.defaultExpectation.paramPtrs = &StorageOrdersByGivenOrderIDListParamPtrs{}
	}
	mmOrdersByGivenOrderIDList.defaultExpectation.paramPtrs.orderIDs = &orderIDs

	return mmOrdersByGivenOrderIDList
}

// ExpectCtxParam2 sets up expected param ctx for Storage.OrdersByGivenOrderIDList
func (mmOrdersByGivenOrderIDList *mStorageOrdersByGivenOrderIDList) ExpectCtxParam2(ctx context.Context) *mStorageOrdersByGivenOrderIDList {
	if mmOrdersByGivenOrderIDList.mock.funcOrdersByGivenOrderIDList != nil {
		mmOrdersByGivenOrderIDList.mock.t.Fatalf("Storage.OrdersByGivenOrderIDList mock is already set by Set")
	}

	if mmOrdersByGivenOrderIDList.defaultExpectation == nil {
		mmOrdersByGivenOrderIDList.defaultExpectation = &StorageOrdersByGivenOrderIDListExpectation{}
	}

	if mmOrdersByGivenOrderIDList.defaultExpectation.params != nil {
		mmOrdersByGivenOrderIDList.mock.t.Fatalf("Storage.OrdersByGivenOrderIDList mock is already set by Expect")
	}

	if mmOrdersByGivenOrderIDList.defaultExpectation.paramPtrs == nil {
		mmOrdersByGivenOrderIDList.defaultExpectation.paramPtrs = &StorageOrdersByGivenOrderIDListParamPtrs{}
	}
	mmOrdersByGivenOrderIDList.defaultExpectation.paramPtrs.ctx = &ctx

	return mmOrdersByGivenOrderIDList
}

// ExpectHashParam3 sets up expected param hash for Storage.OrdersByGivenOrderIDList
func (mmOrdersByGivenOrderIDList *mStorageOrdersByGivenOrderIDList) ExpectHashParam3(hash string) *mStorageOrdersByGivenOrderIDList {
	if mmOrdersByGivenOrderIDList.mock.funcOrdersByGivenOrderIDList != nil {
		mmOrdersByGivenOrderIDList.mock.t.Fatalf("Storage.OrdersByGivenOrderIDList mock is already set by Set")
	}

	if mmOrdersByGivenOrderIDList.defaultExpectation == nil {
		mmOrdersByGivenOrderIDList.defaultExpectation = &StorageOrdersByGivenOrderIDListExpectation{}
	}

	if mmOrdersByGivenOrderIDList.defaultExpectation.params != nil {
		mmOrdersByGivenOrderIDList.mock.t.Fatalf("Storage.OrdersByGivenOrderIDList mock is already set by Expect")
	}

	if mmOrdersByGivenOrderIDList.defaultExpectation.paramPtrs == nil {
		mmOrdersByGivenOrderIDList.defaultExpectation.paramPtrs = &StorageOrdersByGivenOrderIDListParamPtrs{}
	}
	mmOrdersByGivenOrderIDList.defaultExpectation.paramPtrs.hash = &hash

	return mmOrdersByGivenOrderIDList
}

// Inspect accepts an inspector function that has same arguments as the Storage.OrdersByGivenOrderIDList
func (mmOrdersByGivenOrderIDList *mStorageOrdersByGivenOrderIDList) Inspect(f func(orderIDs []model.OrderID, ctx context.Context, hash string)) *mStorageOrdersByGivenOrderIDList {
	if mmOrdersByGivenOrderIDList.mock.inspectFuncOrdersByGivenOrderIDList != nil {
		mmOrdersByGivenOrderIDList.mock.t.Fatalf("Inspect function is already set for Storage.OrdersByGivenOrderIDList")
	}

	mmOrdersByGivenOrderIDList.mock.inspectFuncOrdersByGivenOrderIDList = f

	return mmOrdersByGivenOrderIDList
}

// Return sets up results that will be returned by Storage.OrdersByGivenOrderIDList
func (mmOrdersByGivenOrderIDList *mStorageOrdersByGivenOrderIDList) Return(oa1 []model.Order, err error) *Storage {
	if mmOrdersByGivenOrderIDList.mock.funcOrdersByGivenOrderIDList != nil {
		mmOrdersByGivenOrderIDList.mock.t.Fatalf("Storage.OrdersByGivenOrderIDList mock is already set by Set")
	}

	if mmOrdersByGivenOrderIDList.defaultExpectation == nil {
		mmOrdersByGivenOrderIDList.defaultExpectation = &StorageOrdersByGivenOrderIDListExpectation{mock: mmOrdersByGivenOrderIDList.mock}
	}
	mmOrdersByGivenOrderIDList.defaultExpectation.results = &StorageOrdersByGivenOrderIDListResults{oa1, err}
	return mmOrdersByGivenOrderIDList.mock
}

// Set uses given function f to mock the Storage.OrdersByGivenOrderIDList method
func (mmOrdersByGivenOrderIDList *mStorageOrdersByGivenOrderIDList) Set(f func(orderIDs []model.OrderID, ctx context.Context, hash string) (oa1 []model.Order, err error)) *Storage {
	if mmOrdersByGivenOrderIDList.defaultExpectation != nil {
		mmOrdersByGivenOrderIDList.mock.t.Fatalf("Default expectation is already set for the Storage.OrdersByGivenOrderIDList method")
	}

	if len(mmOrdersByGivenOrderIDList.expectations) > 0 {
		mmOrdersByGivenOrderIDList.mock.t.Fatalf("Some expectations are already set for the Storage.OrdersByGivenOrderIDList method")
	}

	mmOrdersByGivenOrderIDList.mock.funcOrdersByGivenOrderIDList = f
	return mmOrdersByGivenOrderIDList.mock
}

// When sets expectation for the Storage.OrdersByGivenOrderIDList which will trigger the result defined by the following
// Then helper
func (mmOrdersByGivenOrderIDList *mStorageOrdersByGivenOrderIDList) When(orderIDs []model.OrderID, ctx context.Context, hash string) *StorageOrdersByGivenOrderIDListExpectation {
	if mmOrdersByGivenOrderIDList.mock.funcOrdersByGivenOrderIDList != nil {
		mmOrdersByGivenOrderIDList.mock.t.Fatalf("Storage.OrdersByGivenOrderIDList mock is already set by Set")
	}

	expectation := &StorageOrdersByGivenOrderIDListExpectation{
		mock:   mmOrdersByGivenOrderIDList.mock,
		params: &StorageOrdersByGivenOrderIDListParams{orderIDs, ctx, hash},
	}
	mmOrdersByGivenOrderIDList.expectations = append(mmOrdersByGivenOrderIDList.expectations, expectation)
	return expectation
}

// Then sets up Storage.OrdersByGivenOrderIDList return parameters for the expectation previously defined by the When method
func (e *StorageOrdersByGivenOrderIDListExpectation) Then(oa1 []model.Order, err error) *Storage {
	e.results = &StorageOrdersByGivenOrderIDListResults{oa1, err}
	return e.mock
}

// Times sets number of times Storage.OrdersByGivenOrderIDList should be invoked
func (mmOrdersByGivenOrderIDList *mStorageOrdersByGivenOrderIDList) Times(n uint64) *mStorageOrdersByGivenOrderIDList {
	if n == 0 {
		mmOrdersByGivenOrderIDList.mock.t.Fatalf("Times of Storage.OrdersByGivenOrderIDList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrdersByGivenOrderIDList.expectedInvocations, n)
	return mmOrdersByGivenOrderIDList
}

func (mmOrdersByGivenOrderIDList *mStorageOrdersByGivenOrderIDList) invocationsDone() bool {
	if len(mmOrdersByGivenOrderIDList.expectations) == 0 && mmOrdersByGivenOrderIDList.defaultExpectation == nil && mmOrdersByGivenOrderIDList.mock.funcOrdersByGivenOrderIDList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrdersByGivenOrderIDList.mock.afterOrdersByGivenOrderIDListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrdersByGivenOrderIDList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrdersByGivenOrderIDList implements module.Storage
func (mmOrdersByGivenOrderIDList *Storage) OrdersByGivenOrderIDList(orderIDs []model.OrderID, ctx context.Context, hash string) (oa1 []model.Order, err error) {
	mm_atomic.AddUint64(&mmOrdersByGivenOrderIDList.beforeOrdersByGivenOrderIDListCounter, 1)
	defer mm_atomic.AddUint64(&mmOrdersByGivenOrderIDList.afterOrdersByGivenOrderIDListCounter, 1)

	if mmOrdersByGivenOrderIDList.inspectFuncOrdersByGivenOrderIDList != nil {
		mmOrdersByGivenOrderIDList.inspectFuncOrdersByGivenOrderIDList(orderIDs, ctx, hash)
	}

	mm_params := StorageOrdersByGivenOrderIDListParams{orderIDs, ctx, hash}

	// Record call args
	mmOrdersByGivenOrderIDList.OrdersByGivenOrderIDListMock.mutex.Lock()
	mmOrdersByGivenOrderIDList.OrdersByGivenOrderIDListMock.callArgs = append(mmOrdersByGivenOrderIDList.OrdersByGivenOrderIDListMock.callArgs, &mm_params)
	mmOrdersByGivenOrderIDList.OrdersByGivenOrderIDListMock.mutex.Unlock()

	for _, e := range mmOrdersByGivenOrderIDList.OrdersByGivenOrderIDListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmOrdersByGivenOrderIDList.OrdersByGivenOrderIDListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrdersByGivenOrderIDList.OrdersByGivenOrderIDListMock.defaultExpectation.Counter, 1)
		mm_want := mmOrdersByGivenOrderIDList.OrdersByGivenOrderIDListMock.defaultExpectation.params
		mm_want_ptrs := mmOrdersByGivenOrderIDList.OrdersByGivenOrderIDListMock.defaultExpectation.paramPtrs

		mm_got := StorageOrdersByGivenOrderIDListParams{orderIDs, ctx, hash}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.orderIDs != nil && !minimock.Equal(*mm_want_ptrs.orderIDs, mm_got.orderIDs) {
				mmOrdersByGivenOrderIDList.t.Errorf("Storage.OrdersByGivenOrderIDList got unexpected parameter orderIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderIDs, mm_got.orderIDs, minimock.Diff(*mm_want_ptrs.orderIDs, mm_got.orderIDs))
			}

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrdersByGivenOrderIDList.t.Errorf("Storage.OrdersByGivenOrderIDList got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.hash != nil && !minimock.Equal(*mm_want_ptrs.hash, mm_got.hash) {
				mmOrdersByGivenOrderIDList.t.Errorf("Storage.OrdersByGivenOrderIDList got unexpected parameter hash, want: %#v, got: %#v%s\n", *mm_want_ptrs.hash, mm_got.hash, minimock.Diff(*mm_want_ptrs.hash, mm_got.hash))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrdersByGivenOrderIDList.t.Errorf("Storage.OrdersByGivenOrderIDList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrdersByGivenOrderIDList.OrdersByGivenOrderIDListMock.defaultExpectation.results
		if mm_results == nil {
			mmOrdersByGivenOrderIDList.t.Fatal("No results are set for the Storage.OrdersByGivenOrderIDList")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmOrdersByGivenOrderIDList.funcOrdersByGivenOrderIDList != nil {
		return mmOrdersByGivenOrderIDList.funcOrdersByGivenOrderIDList(orderIDs, ctx, hash)
	}
	mmOrdersByGivenOrderIDList.t.Fatalf("Unexpected call to Storage.OrdersByGivenOrderIDList. %v %v %v", orderIDs, ctx, hash)
	return
}

// OrdersByGivenOrderIDListAfterCounter returns a count of finished Storage.OrdersByGivenOrderIDList invocations
func (mmOrdersByGivenOrderIDList *Storage) OrdersByGivenOrderIDListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrdersByGivenOrderIDList.afterOrdersByGivenOrderIDListCounter)
}

// OrdersByGivenOrderIDListBeforeCounter returns a count of Storage.OrdersByGivenOrderIDList invocations
func (mmOrdersByGivenOrderIDList *Storage) OrdersByGivenOrderIDListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrdersByGivenOrderIDList.beforeOrdersByGivenOrderIDListCounter)
}

// Calls returns a list of arguments used in each call to Storage.OrdersByGivenOrderIDList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrdersByGivenOrderIDList *mStorageOrdersByGivenOrderIDList) Calls() []*StorageOrdersByGivenOrderIDListParams {
	mmOrdersByGivenOrderIDList.mutex.RLock()

	argCopy := make([]*StorageOrdersByGivenOrderIDListParams, len(mmOrdersByGivenOrderIDList.callArgs))
	copy(argCopy, mmOrdersByGivenOrderIDList.callArgs)

	mmOrdersByGivenOrderIDList.mutex.RUnlock()

	return argCopy
}

// MinimockOrdersByGivenOrderIDListDone returns true if the count of the OrdersByGivenOrderIDList invocations corresponds
// the number of defined expectations
func (m *Storage) MinimockOrdersByGivenOrderIDListDone() bool {
	if m.OrdersByGivenOrderIDListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrdersByGivenOrderIDListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrdersByGivenOrderIDListMock.invocationsDone()
}

// MinimockOrdersByGivenOrderIDListInspect logs each unmet expectation
func (m *Storage) MinimockOrdersByGivenOrderIDListInspect() {
	for _, e := range m.OrdersByGivenOrderIDListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Storage.OrdersByGivenOrderIDList with params: %#v", *e.params)
		}
	}

	afterOrdersByGivenOrderIDListCounter := mm_atomic.LoadUint64(&m.afterOrdersByGivenOrderIDListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrdersByGivenOrderIDListMock.defaultExpectation != nil && afterOrdersByGivenOrderIDListCounter < 1 {
		if m.OrdersByGivenOrderIDListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Storage.OrdersByGivenOrderIDList")
		} else {
			m.t.Errorf("Expected call to Storage.OrdersByGivenOrderIDList with params: %#v", *m.OrdersByGivenOrderIDListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrdersByGivenOrderIDList != nil && afterOrdersByGivenOrderIDListCounter < 1 {
		m.t.Error("Expected call to Storage.OrdersByGivenOrderIDList")
	}

	if !m.OrdersByGivenOrderIDListMock.invocationsDone() && afterOrdersByGivenOrderIDListCounter > 0 {
		m.t.Errorf("Expected %d calls to Storage.OrdersByGivenOrderIDList but found %d calls",
			mm_atomic.LoadUint64(&m.OrdersByGivenOrderIDListMock.expectedInvocations), afterOrdersByGivenOrderIDListCounter)
	}
}

type mStorageOrdersWithGivenClientID struct {
	optional           bool
	mock               *Storage
	defaultExpectation *StorageOrdersWithGivenClientIDExpectation
	expectations       []*StorageOrdersWithGivenClientIDExpectation

	callArgs []*StorageOrdersWithGivenClientIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StorageOrdersWithGivenClientIDExpectation specifies expectation struct of the Storage.OrdersWithGivenClientID
type StorageOrdersWithGivenClientIDExpectation struct {
	mock      *Storage
	params    *StorageOrdersWithGivenClientIDParams
	paramPtrs *StorageOrdersWithGivenClientIDParamPtrs
	results   *StorageOrdersWithGivenClientIDResults
	Counter   uint64
}

// StorageOrdersWithGivenClientIDParams contains parameters of the Storage.OrdersWithGivenClientID
type StorageOrdersWithGivenClientIDParams struct {
	clientID model.ClientID
	c1       context.Context
	hash     string
}

// StorageOrdersWithGivenClientIDParamPtrs contains pointers to parameters of the Storage.OrdersWithGivenClientID
type StorageOrdersWithGivenClientIDParamPtrs struct {
	clientID *model.ClientID
	c1       *context.Context
	hash     *string
}

// StorageOrdersWithGivenClientIDResults contains results of the Storage.OrdersWithGivenClientID
type StorageOrdersWithGivenClientIDResults struct {
	oa1 []model.Order
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrdersWithGivenClientID *mStorageOrdersWithGivenClientID) Optional() *mStorageOrdersWithGivenClientID {
	mmOrdersWithGivenClientID.optional = true
	return mmOrdersWithGivenClientID
}

// Expect sets up expected params for Storage.OrdersWithGivenClientID
func (mmOrdersWithGivenClientID *mStorageOrdersWithGivenClientID) Expect(clientID model.ClientID, c1 context.Context, hash string) *mStorageOrdersWithGivenClientID {
	if mmOrdersWithGivenClientID.mock.funcOrdersWithGivenClientID != nil {
		mmOrdersWithGivenClientID.mock.t.Fatalf("Storage.OrdersWithGivenClientID mock is already set by Set")
	}

	if mmOrdersWithGivenClientID.defaultExpectation == nil {
		mmOrdersWithGivenClientID.defaultExpectation = &StorageOrdersWithGivenClientIDExpectation{}
	}

	if mmOrdersWithGivenClientID.defaultExpectation.paramPtrs != nil {
		mmOrdersWithGivenClientID.mock.t.Fatalf("Storage.OrdersWithGivenClientID mock is already set by ExpectParams functions")
	}

	mmOrdersWithGivenClientID.defaultExpectation.params = &StorageOrdersWithGivenClientIDParams{clientID, c1, hash}
	for _, e := range mmOrdersWithGivenClientID.expectations {
		if minimock.Equal(e.params, mmOrdersWithGivenClientID.defaultExpectation.params) {
			mmOrdersWithGivenClientID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrdersWithGivenClientID.defaultExpectation.params)
		}
	}

	return mmOrdersWithGivenClientID
}

// ExpectClientIDParam1 sets up expected param clientID for Storage.OrdersWithGivenClientID
func (mmOrdersWithGivenClientID *mStorageOrdersWithGivenClientID) ExpectClientIDParam1(clientID model.ClientID) *mStorageOrdersWithGivenClientID {
	if mmOrdersWithGivenClientID.mock.funcOrdersWithGivenClientID != nil {
		mmOrdersWithGivenClientID.mock.t.Fatalf("Storage.OrdersWithGivenClientID mock is already set by Set")
	}

	if mmOrdersWithGivenClientID.defaultExpectation == nil {
		mmOrdersWithGivenClientID.defaultExpectation = &StorageOrdersWithGivenClientIDExpectation{}
	}

	if mmOrdersWithGivenClientID.defaultExpectation.params != nil {
		mmOrdersWithGivenClientID.mock.t.Fatalf("Storage.OrdersWithGivenClientID mock is already set by Expect")
	}

	if mmOrdersWithGivenClientID.defaultExpectation.paramPtrs == nil {
		mmOrdersWithGivenClientID.defaultExpectation.paramPtrs = &StorageOrdersWithGivenClientIDParamPtrs{}
	}
	mmOrdersWithGivenClientID.defaultExpectation.paramPtrs.clientID = &clientID

	return mmOrdersWithGivenClientID
}

// ExpectC1Param2 sets up expected param c1 for Storage.OrdersWithGivenClientID
func (mmOrdersWithGivenClientID *mStorageOrdersWithGivenClientID) ExpectC1Param2(c1 context.Context) *mStorageOrdersWithGivenClientID {
	if mmOrdersWithGivenClientID.mock.funcOrdersWithGivenClientID != nil {
		mmOrdersWithGivenClientID.mock.t.Fatalf("Storage.OrdersWithGivenClientID mock is already set by Set")
	}

	if mmOrdersWithGivenClientID.defaultExpectation == nil {
		mmOrdersWithGivenClientID.defaultExpectation = &StorageOrdersWithGivenClientIDExpectation{}
	}

	if mmOrdersWithGivenClientID.defaultExpectation.params != nil {
		mmOrdersWithGivenClientID.mock.t.Fatalf("Storage.OrdersWithGivenClientID mock is already set by Expect")
	}

	if mmOrdersWithGivenClientID.defaultExpectation.paramPtrs == nil {
		mmOrdersWithGivenClientID.defaultExpectation.paramPtrs = &StorageOrdersWithGivenClientIDParamPtrs{}
	}
	mmOrdersWithGivenClientID.defaultExpectation.paramPtrs.c1 = &c1

	return mmOrdersWithGivenClientID
}

// ExpectHashParam3 sets up expected param hash for Storage.OrdersWithGivenClientID
func (mmOrdersWithGivenClientID *mStorageOrdersWithGivenClientID) ExpectHashParam3(hash string) *mStorageOrdersWithGivenClientID {
	if mmOrdersWithGivenClientID.mock.funcOrdersWithGivenClientID != nil {
		mmOrdersWithGivenClientID.mock.t.Fatalf("Storage.OrdersWithGivenClientID mock is already set by Set")
	}

	if mmOrdersWithGivenClientID.defaultExpectation == nil {
		mmOrdersWithGivenClientID.defaultExpectation = &StorageOrdersWithGivenClientIDExpectation{}
	}

	if mmOrdersWithGivenClientID.defaultExpectation.params != nil {
		mmOrdersWithGivenClientID.mock.t.Fatalf("Storage.OrdersWithGivenClientID mock is already set by Expect")
	}

	if mmOrdersWithGivenClientID.defaultExpectation.paramPtrs == nil {
		mmOrdersWithGivenClientID.defaultExpectation.paramPtrs = &StorageOrdersWithGivenClientIDParamPtrs{}
	}
	mmOrdersWithGivenClientID.defaultExpectation.paramPtrs.hash = &hash

	return mmOrdersWithGivenClientID
}

// Inspect accepts an inspector function that has same arguments as the Storage.OrdersWithGivenClientID
func (mmOrdersWithGivenClientID *mStorageOrdersWithGivenClientID) Inspect(f func(clientID model.ClientID, c1 context.Context, hash string)) *mStorageOrdersWithGivenClientID {
	if mmOrdersWithGivenClientID.mock.inspectFuncOrdersWithGivenClientID != nil {
		mmOrdersWithGivenClientID.mock.t.Fatalf("Inspect function is already set for Storage.OrdersWithGivenClientID")
	}

	mmOrdersWithGivenClientID.mock.inspectFuncOrdersWithGivenClientID = f

	return mmOrdersWithGivenClientID
}

// Return sets up results that will be returned by Storage.OrdersWithGivenClientID
func (mmOrdersWithGivenClientID *mStorageOrdersWithGivenClientID) Return(oa1 []model.Order, err error) *Storage {
	if mmOrdersWithGivenClientID.mock.funcOrdersWithGivenClientID != nil {
		mmOrdersWithGivenClientID.mock.t.Fatalf("Storage.OrdersWithGivenClientID mock is already set by Set")
	}

	if mmOrdersWithGivenClientID.defaultExpectation == nil {
		mmOrdersWithGivenClientID.defaultExpectation = &StorageOrdersWithGivenClientIDExpectation{mock: mmOrdersWithGivenClientID.mock}
	}
	mmOrdersWithGivenClientID.defaultExpectation.results = &StorageOrdersWithGivenClientIDResults{oa1, err}
	return mmOrdersWithGivenClientID.mock
}

// Set uses given function f to mock the Storage.OrdersWithGivenClientID method
func (mmOrdersWithGivenClientID *mStorageOrdersWithGivenClientID) Set(f func(clientID model.ClientID, c1 context.Context, hash string) (oa1 []model.Order, err error)) *Storage {
	if mmOrdersWithGivenClientID.defaultExpectation != nil {
		mmOrdersWithGivenClientID.mock.t.Fatalf("Default expectation is already set for the Storage.OrdersWithGivenClientID method")
	}

	if len(mmOrdersWithGivenClientID.expectations) > 0 {
		mmOrdersWithGivenClientID.mock.t.Fatalf("Some expectations are already set for the Storage.OrdersWithGivenClientID method")
	}

	mmOrdersWithGivenClientID.mock.funcOrdersWithGivenClientID = f
	return mmOrdersWithGivenClientID.mock
}

// When sets expectation for the Storage.OrdersWithGivenClientID which will trigger the result defined by the following
// Then helper
func (mmOrdersWithGivenClientID *mStorageOrdersWithGivenClientID) When(clientID model.ClientID, c1 context.Context, hash string) *StorageOrdersWithGivenClientIDExpectation {
	if mmOrdersWithGivenClientID.mock.funcOrdersWithGivenClientID != nil {
		mmOrdersWithGivenClientID.mock.t.Fatalf("Storage.OrdersWithGivenClientID mock is already set by Set")
	}

	expectation := &StorageOrdersWithGivenClientIDExpectation{
		mock:   mmOrdersWithGivenClientID.mock,
		params: &StorageOrdersWithGivenClientIDParams{clientID, c1, hash},
	}
	mmOrdersWithGivenClientID.expectations = append(mmOrdersWithGivenClientID.expectations, expectation)
	return expectation
}

// Then sets up Storage.OrdersWithGivenClientID return parameters for the expectation previously defined by the When method
func (e *StorageOrdersWithGivenClientIDExpectation) Then(oa1 []model.Order, err error) *Storage {
	e.results = &StorageOrdersWithGivenClientIDResults{oa1, err}
	return e.mock
}

// Times sets number of times Storage.OrdersWithGivenClientID should be invoked
func (mmOrdersWithGivenClientID *mStorageOrdersWithGivenClientID) Times(n uint64) *mStorageOrdersWithGivenClientID {
	if n == 0 {
		mmOrdersWithGivenClientID.mock.t.Fatalf("Times of Storage.OrdersWithGivenClientID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrdersWithGivenClientID.expectedInvocations, n)
	return mmOrdersWithGivenClientID
}

func (mmOrdersWithGivenClientID *mStorageOrdersWithGivenClientID) invocationsDone() bool {
	if len(mmOrdersWithGivenClientID.expectations) == 0 && mmOrdersWithGivenClientID.defaultExpectation == nil && mmOrdersWithGivenClientID.mock.funcOrdersWithGivenClientID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrdersWithGivenClientID.mock.afterOrdersWithGivenClientIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrdersWithGivenClientID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrdersWithGivenClientID implements module.Storage
func (mmOrdersWithGivenClientID *Storage) OrdersWithGivenClientID(clientID model.ClientID, c1 context.Context, hash string) (oa1 []model.Order, err error) {
	mm_atomic.AddUint64(&mmOrdersWithGivenClientID.beforeOrdersWithGivenClientIDCounter, 1)
	defer mm_atomic.AddUint64(&mmOrdersWithGivenClientID.afterOrdersWithGivenClientIDCounter, 1)

	if mmOrdersWithGivenClientID.inspectFuncOrdersWithGivenClientID != nil {
		mmOrdersWithGivenClientID.inspectFuncOrdersWithGivenClientID(clientID, c1, hash)
	}

	mm_params := StorageOrdersWithGivenClientIDParams{clientID, c1, hash}

	// Record call args
	mmOrdersWithGivenClientID.OrdersWithGivenClientIDMock.mutex.Lock()
	mmOrdersWithGivenClientID.OrdersWithGivenClientIDMock.callArgs = append(mmOrdersWithGivenClientID.OrdersWithGivenClientIDMock.callArgs, &mm_params)
	mmOrdersWithGivenClientID.OrdersWithGivenClientIDMock.mutex.Unlock()

	for _, e := range mmOrdersWithGivenClientID.OrdersWithGivenClientIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmOrdersWithGivenClientID.OrdersWithGivenClientIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrdersWithGivenClientID.OrdersWithGivenClientIDMock.defaultExpectation.Counter, 1)
		mm_want := mmOrdersWithGivenClientID.OrdersWithGivenClientIDMock.defaultExpectation.params
		mm_want_ptrs := mmOrdersWithGivenClientID.OrdersWithGivenClientIDMock.defaultExpectation.paramPtrs

		mm_got := StorageOrdersWithGivenClientIDParams{clientID, c1, hash}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmOrdersWithGivenClientID.t.Errorf("Storage.OrdersWithGivenClientID got unexpected parameter clientID, want: %#v, got: %#v%s\n", *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

			if mm_want_ptrs.c1 != nil && !minimock.Equal(*mm_want_ptrs.c1, mm_got.c1) {
				mmOrdersWithGivenClientID.t.Errorf("Storage.OrdersWithGivenClientID got unexpected parameter c1, want: %#v, got: %#v%s\n", *mm_want_ptrs.c1, mm_got.c1, minimock.Diff(*mm_want_ptrs.c1, mm_got.c1))
			}

			if mm_want_ptrs.hash != nil && !minimock.Equal(*mm_want_ptrs.hash, mm_got.hash) {
				mmOrdersWithGivenClientID.t.Errorf("Storage.OrdersWithGivenClientID got unexpected parameter hash, want: %#v, got: %#v%s\n", *mm_want_ptrs.hash, mm_got.hash, minimock.Diff(*mm_want_ptrs.hash, mm_got.hash))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrdersWithGivenClientID.t.Errorf("Storage.OrdersWithGivenClientID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrdersWithGivenClientID.OrdersWithGivenClientIDMock.defaultExpectation.results
		if mm_results == nil {
			mmOrdersWithGivenClientID.t.Fatal("No results are set for the Storage.OrdersWithGivenClientID")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmOrdersWithGivenClientID.funcOrdersWithGivenClientID != nil {
		return mmOrdersWithGivenClientID.funcOrdersWithGivenClientID(clientID, c1, hash)
	}
	mmOrdersWithGivenClientID.t.Fatalf("Unexpected call to Storage.OrdersWithGivenClientID. %v %v %v", clientID, c1, hash)
	return
}

// OrdersWithGivenClientIDAfterCounter returns a count of finished Storage.OrdersWithGivenClientID invocations
func (mmOrdersWithGivenClientID *Storage) OrdersWithGivenClientIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrdersWithGivenClientID.afterOrdersWithGivenClientIDCounter)
}

// OrdersWithGivenClientIDBeforeCounter returns a count of Storage.OrdersWithGivenClientID invocations
func (mmOrdersWithGivenClientID *Storage) OrdersWithGivenClientIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrdersWithGivenClientID.beforeOrdersWithGivenClientIDCounter)
}

// Calls returns a list of arguments used in each call to Storage.OrdersWithGivenClientID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrdersWithGivenClientID *mStorageOrdersWithGivenClientID) Calls() []*StorageOrdersWithGivenClientIDParams {
	mmOrdersWithGivenClientID.mutex.RLock()

	argCopy := make([]*StorageOrdersWithGivenClientIDParams, len(mmOrdersWithGivenClientID.callArgs))
	copy(argCopy, mmOrdersWithGivenClientID.callArgs)

	mmOrdersWithGivenClientID.mutex.RUnlock()

	return argCopy
}

// MinimockOrdersWithGivenClientIDDone returns true if the count of the OrdersWithGivenClientID invocations corresponds
// the number of defined expectations
func (m *Storage) MinimockOrdersWithGivenClientIDDone() bool {
	if m.OrdersWithGivenClientIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrdersWithGivenClientIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrdersWithGivenClientIDMock.invocationsDone()
}

// MinimockOrdersWithGivenClientIDInspect logs each unmet expectation
func (m *Storage) MinimockOrdersWithGivenClientIDInspect() {
	for _, e := range m.OrdersWithGivenClientIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Storage.OrdersWithGivenClientID with params: %#v", *e.params)
		}
	}

	afterOrdersWithGivenClientIDCounter := mm_atomic.LoadUint64(&m.afterOrdersWithGivenClientIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrdersWithGivenClientIDMock.defaultExpectation != nil && afterOrdersWithGivenClientIDCounter < 1 {
		if m.OrdersWithGivenClientIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Storage.OrdersWithGivenClientID")
		} else {
			m.t.Errorf("Expected call to Storage.OrdersWithGivenClientID with params: %#v", *m.OrdersWithGivenClientIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrdersWithGivenClientID != nil && afterOrdersWithGivenClientIDCounter < 1 {
		m.t.Error("Expected call to Storage.OrdersWithGivenClientID")
	}

	if !m.OrdersWithGivenClientIDMock.invocationsDone() && afterOrdersWithGivenClientIDCounter > 0 {
		m.t.Errorf("Expected %d calls to Storage.OrdersWithGivenClientID but found %d calls",
			mm_atomic.LoadUint64(&m.OrdersWithGivenClientIDMock.expectedInvocations), afterOrdersWithGivenClientIDCounter)
	}
}

type mStorageOrdersWithGivenClientIDAndAcceptedCondition struct {
	optional           bool
	mock               *Storage
	defaultExpectation *StorageOrdersWithGivenClientIDAndAcceptedConditionExpectation
	expectations       []*StorageOrdersWithGivenClientIDAndAcceptedConditionExpectation

	callArgs []*StorageOrdersWithGivenClientIDAndAcceptedConditionParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StorageOrdersWithGivenClientIDAndAcceptedConditionExpectation specifies expectation struct of the Storage.OrdersWithGivenClientIDAndAcceptedCondition
type StorageOrdersWithGivenClientIDAndAcceptedConditionExpectation struct {
	mock      *Storage
	params    *StorageOrdersWithGivenClientIDAndAcceptedConditionParams
	paramPtrs *StorageOrdersWithGivenClientIDAndAcceptedConditionParamPtrs
	results   *StorageOrdersWithGivenClientIDAndAcceptedConditionResults
	Counter   uint64
}

// StorageOrdersWithGivenClientIDAndAcceptedConditionParams contains parameters of the Storage.OrdersWithGivenClientIDAndAcceptedCondition
type StorageOrdersWithGivenClientIDAndAcceptedConditionParams struct {
	clientID model.ClientID
	c1       context.Context
	hash     string
}

// StorageOrdersWithGivenClientIDAndAcceptedConditionParamPtrs contains pointers to parameters of the Storage.OrdersWithGivenClientIDAndAcceptedCondition
type StorageOrdersWithGivenClientIDAndAcceptedConditionParamPtrs struct {
	clientID *model.ClientID
	c1       *context.Context
	hash     *string
}

// StorageOrdersWithGivenClientIDAndAcceptedConditionResults contains results of the Storage.OrdersWithGivenClientIDAndAcceptedCondition
type StorageOrdersWithGivenClientIDAndAcceptedConditionResults struct {
	oa1 []model.Order
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrdersWithGivenClientIDAndAcceptedCondition *mStorageOrdersWithGivenClientIDAndAcceptedCondition) Optional() *mStorageOrdersWithGivenClientIDAndAcceptedCondition {
	mmOrdersWithGivenClientIDAndAcceptedCondition.optional = true
	return mmOrdersWithGivenClientIDAndAcceptedCondition
}

// Expect sets up expected params for Storage.OrdersWithGivenClientIDAndAcceptedCondition
func (mmOrdersWithGivenClientIDAndAcceptedCondition *mStorageOrdersWithGivenClientIDAndAcceptedCondition) Expect(clientID model.ClientID, c1 context.Context, hash string) *mStorageOrdersWithGivenClientIDAndAcceptedCondition {
	if mmOrdersWithGivenClientIDAndAcceptedCondition.mock.funcOrdersWithGivenClientIDAndAcceptedCondition != nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.mock.t.Fatalf("Storage.OrdersWithGivenClientIDAndAcceptedCondition mock is already set by Set")
	}

	if mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation == nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation = &StorageOrdersWithGivenClientIDAndAcceptedConditionExpectation{}
	}

	if mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation.paramPtrs != nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.mock.t.Fatalf("Storage.OrdersWithGivenClientIDAndAcceptedCondition mock is already set by ExpectParams functions")
	}

	mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation.params = &StorageOrdersWithGivenClientIDAndAcceptedConditionParams{clientID, c1, hash}
	for _, e := range mmOrdersWithGivenClientIDAndAcceptedCondition.expectations {
		if minimock.Equal(e.params, mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation.params) {
			mmOrdersWithGivenClientIDAndAcceptedCondition.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation.params)
		}
	}

	return mmOrdersWithGivenClientIDAndAcceptedCondition
}

// ExpectClientIDParam1 sets up expected param clientID for Storage.OrdersWithGivenClientIDAndAcceptedCondition
func (mmOrdersWithGivenClientIDAndAcceptedCondition *mStorageOrdersWithGivenClientIDAndAcceptedCondition) ExpectClientIDParam1(clientID model.ClientID) *mStorageOrdersWithGivenClientIDAndAcceptedCondition {
	if mmOrdersWithGivenClientIDAndAcceptedCondition.mock.funcOrdersWithGivenClientIDAndAcceptedCondition != nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.mock.t.Fatalf("Storage.OrdersWithGivenClientIDAndAcceptedCondition mock is already set by Set")
	}

	if mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation == nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation = &StorageOrdersWithGivenClientIDAndAcceptedConditionExpectation{}
	}

	if mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation.params != nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.mock.t.Fatalf("Storage.OrdersWithGivenClientIDAndAcceptedCondition mock is already set by Expect")
	}

	if mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation.paramPtrs == nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation.paramPtrs = &StorageOrdersWithGivenClientIDAndAcceptedConditionParamPtrs{}
	}
	mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation.paramPtrs.clientID = &clientID

	return mmOrdersWithGivenClientIDAndAcceptedCondition
}

// ExpectC1Param2 sets up expected param c1 for Storage.OrdersWithGivenClientIDAndAcceptedCondition
func (mmOrdersWithGivenClientIDAndAcceptedCondition *mStorageOrdersWithGivenClientIDAndAcceptedCondition) ExpectC1Param2(c1 context.Context) *mStorageOrdersWithGivenClientIDAndAcceptedCondition {
	if mmOrdersWithGivenClientIDAndAcceptedCondition.mock.funcOrdersWithGivenClientIDAndAcceptedCondition != nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.mock.t.Fatalf("Storage.OrdersWithGivenClientIDAndAcceptedCondition mock is already set by Set")
	}

	if mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation == nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation = &StorageOrdersWithGivenClientIDAndAcceptedConditionExpectation{}
	}

	if mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation.params != nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.mock.t.Fatalf("Storage.OrdersWithGivenClientIDAndAcceptedCondition mock is already set by Expect")
	}

	if mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation.paramPtrs == nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation.paramPtrs = &StorageOrdersWithGivenClientIDAndAcceptedConditionParamPtrs{}
	}
	mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation.paramPtrs.c1 = &c1

	return mmOrdersWithGivenClientIDAndAcceptedCondition
}

// ExpectHashParam3 sets up expected param hash for Storage.OrdersWithGivenClientIDAndAcceptedCondition
func (mmOrdersWithGivenClientIDAndAcceptedCondition *mStorageOrdersWithGivenClientIDAndAcceptedCondition) ExpectHashParam3(hash string) *mStorageOrdersWithGivenClientIDAndAcceptedCondition {
	if mmOrdersWithGivenClientIDAndAcceptedCondition.mock.funcOrdersWithGivenClientIDAndAcceptedCondition != nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.mock.t.Fatalf("Storage.OrdersWithGivenClientIDAndAcceptedCondition mock is already set by Set")
	}

	if mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation == nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation = &StorageOrdersWithGivenClientIDAndAcceptedConditionExpectation{}
	}

	if mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation.params != nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.mock.t.Fatalf("Storage.OrdersWithGivenClientIDAndAcceptedCondition mock is already set by Expect")
	}

	if mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation.paramPtrs == nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation.paramPtrs = &StorageOrdersWithGivenClientIDAndAcceptedConditionParamPtrs{}
	}
	mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation.paramPtrs.hash = &hash

	return mmOrdersWithGivenClientIDAndAcceptedCondition
}

// Inspect accepts an inspector function that has same arguments as the Storage.OrdersWithGivenClientIDAndAcceptedCondition
func (mmOrdersWithGivenClientIDAndAcceptedCondition *mStorageOrdersWithGivenClientIDAndAcceptedCondition) Inspect(f func(clientID model.ClientID, c1 context.Context, hash string)) *mStorageOrdersWithGivenClientIDAndAcceptedCondition {
	if mmOrdersWithGivenClientIDAndAcceptedCondition.mock.inspectFuncOrdersWithGivenClientIDAndAcceptedCondition != nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.mock.t.Fatalf("Inspect function is already set for Storage.OrdersWithGivenClientIDAndAcceptedCondition")
	}

	mmOrdersWithGivenClientIDAndAcceptedCondition.mock.inspectFuncOrdersWithGivenClientIDAndAcceptedCondition = f

	return mmOrdersWithGivenClientIDAndAcceptedCondition
}

// Return sets up results that will be returned by Storage.OrdersWithGivenClientIDAndAcceptedCondition
func (mmOrdersWithGivenClientIDAndAcceptedCondition *mStorageOrdersWithGivenClientIDAndAcceptedCondition) Return(oa1 []model.Order, err error) *Storage {
	if mmOrdersWithGivenClientIDAndAcceptedCondition.mock.funcOrdersWithGivenClientIDAndAcceptedCondition != nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.mock.t.Fatalf("Storage.OrdersWithGivenClientIDAndAcceptedCondition mock is already set by Set")
	}

	if mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation == nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation = &StorageOrdersWithGivenClientIDAndAcceptedConditionExpectation{mock: mmOrdersWithGivenClientIDAndAcceptedCondition.mock}
	}
	mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation.results = &StorageOrdersWithGivenClientIDAndAcceptedConditionResults{oa1, err}
	return mmOrdersWithGivenClientIDAndAcceptedCondition.mock
}

// Set uses given function f to mock the Storage.OrdersWithGivenClientIDAndAcceptedCondition method
func (mmOrdersWithGivenClientIDAndAcceptedCondition *mStorageOrdersWithGivenClientIDAndAcceptedCondition) Set(f func(clientID model.ClientID, c1 context.Context, hash string) (oa1 []model.Order, err error)) *Storage {
	if mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation != nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.mock.t.Fatalf("Default expectation is already set for the Storage.OrdersWithGivenClientIDAndAcceptedCondition method")
	}

	if len(mmOrdersWithGivenClientIDAndAcceptedCondition.expectations) > 0 {
		mmOrdersWithGivenClientIDAndAcceptedCondition.mock.t.Fatalf("Some expectations are already set for the Storage.OrdersWithGivenClientIDAndAcceptedCondition method")
	}

	mmOrdersWithGivenClientIDAndAcceptedCondition.mock.funcOrdersWithGivenClientIDAndAcceptedCondition = f
	return mmOrdersWithGivenClientIDAndAcceptedCondition.mock
}

// When sets expectation for the Storage.OrdersWithGivenClientIDAndAcceptedCondition which will trigger the result defined by the following
// Then helper
func (mmOrdersWithGivenClientIDAndAcceptedCondition *mStorageOrdersWithGivenClientIDAndAcceptedCondition) When(clientID model.ClientID, c1 context.Context, hash string) *StorageOrdersWithGivenClientIDAndAcceptedConditionExpectation {
	if mmOrdersWithGivenClientIDAndAcceptedCondition.mock.funcOrdersWithGivenClientIDAndAcceptedCondition != nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.mock.t.Fatalf("Storage.OrdersWithGivenClientIDAndAcceptedCondition mock is already set by Set")
	}

	expectation := &StorageOrdersWithGivenClientIDAndAcceptedConditionExpectation{
		mock:   mmOrdersWithGivenClientIDAndAcceptedCondition.mock,
		params: &StorageOrdersWithGivenClientIDAndAcceptedConditionParams{clientID, c1, hash},
	}
	mmOrdersWithGivenClientIDAndAcceptedCondition.expectations = append(mmOrdersWithGivenClientIDAndAcceptedCondition.expectations, expectation)
	return expectation
}

// Then sets up Storage.OrdersWithGivenClientIDAndAcceptedCondition return parameters for the expectation previously defined by the When method
func (e *StorageOrdersWithGivenClientIDAndAcceptedConditionExpectation) Then(oa1 []model.Order, err error) *Storage {
	e.results = &StorageOrdersWithGivenClientIDAndAcceptedConditionResults{oa1, err}
	return e.mock
}

// Times sets number of times Storage.OrdersWithGivenClientIDAndAcceptedCondition should be invoked
func (mmOrdersWithGivenClientIDAndAcceptedCondition *mStorageOrdersWithGivenClientIDAndAcceptedCondition) Times(n uint64) *mStorageOrdersWithGivenClientIDAndAcceptedCondition {
	if n == 0 {
		mmOrdersWithGivenClientIDAndAcceptedCondition.mock.t.Fatalf("Times of Storage.OrdersWithGivenClientIDAndAcceptedCondition mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrdersWithGivenClientIDAndAcceptedCondition.expectedInvocations, n)
	return mmOrdersWithGivenClientIDAndAcceptedCondition
}

func (mmOrdersWithGivenClientIDAndAcceptedCondition *mStorageOrdersWithGivenClientIDAndAcceptedCondition) invocationsDone() bool {
	if len(mmOrdersWithGivenClientIDAndAcceptedCondition.expectations) == 0 && mmOrdersWithGivenClientIDAndAcceptedCondition.defaultExpectation == nil && mmOrdersWithGivenClientIDAndAcceptedCondition.mock.funcOrdersWithGivenClientIDAndAcceptedCondition == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrdersWithGivenClientIDAndAcceptedCondition.mock.afterOrdersWithGivenClientIDAndAcceptedConditionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrdersWithGivenClientIDAndAcceptedCondition.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrdersWithGivenClientIDAndAcceptedCondition implements module.Storage
func (mmOrdersWithGivenClientIDAndAcceptedCondition *Storage) OrdersWithGivenClientIDAndAcceptedCondition(clientID model.ClientID, c1 context.Context, hash string) (oa1 []model.Order, err error) {
	mm_atomic.AddUint64(&mmOrdersWithGivenClientIDAndAcceptedCondition.beforeOrdersWithGivenClientIDAndAcceptedConditionCounter, 1)
	defer mm_atomic.AddUint64(&mmOrdersWithGivenClientIDAndAcceptedCondition.afterOrdersWithGivenClientIDAndAcceptedConditionCounter, 1)

	if mmOrdersWithGivenClientIDAndAcceptedCondition.inspectFuncOrdersWithGivenClientIDAndAcceptedCondition != nil {
		mmOrdersWithGivenClientIDAndAcceptedCondition.inspectFuncOrdersWithGivenClientIDAndAcceptedCondition(clientID, c1, hash)
	}

	mm_params := StorageOrdersWithGivenClientIDAndAcceptedConditionParams{clientID, c1, hash}

	// Record call args
	mmOrdersWithGivenClientIDAndAcceptedCondition.OrdersWithGivenClientIDAndAcceptedConditionMock.mutex.Lock()
	mmOrdersWithGivenClientIDAndAcceptedCondition.OrdersWithGivenClientIDAndAcceptedConditionMock.callArgs = append(mmOrdersWithGivenClientIDAndAcceptedCondition.OrdersWithGivenClientIDAndAcceptedConditionMock.callArgs, &mm_params)
	mmOrdersWithGivenClientIDAndAcceptedCondition.OrdersWithGivenClientIDAndAcceptedConditionMock.mutex.Unlock()

	for _, e := range mmOrdersWithGivenClientIDAndAcceptedCondition.OrdersWithGivenClientIDAndAcceptedConditionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmOrdersWithGivenClientIDAndAcceptedCondition.OrdersWithGivenClientIDAndAcceptedConditionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrdersWithGivenClientIDAndAcceptedCondition.OrdersWithGivenClientIDAndAcceptedConditionMock.defaultExpectation.Counter, 1)
		mm_want := mmOrdersWithGivenClientIDAndAcceptedCondition.OrdersWithGivenClientIDAndAcceptedConditionMock.defaultExpectation.params
		mm_want_ptrs := mmOrdersWithGivenClientIDAndAcceptedCondition.OrdersWithGivenClientIDAndAcceptedConditionMock.defaultExpectation.paramPtrs

		mm_got := StorageOrdersWithGivenClientIDAndAcceptedConditionParams{clientID, c1, hash}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmOrdersWithGivenClientIDAndAcceptedCondition.t.Errorf("Storage.OrdersWithGivenClientIDAndAcceptedCondition got unexpected parameter clientID, want: %#v, got: %#v%s\n", *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

			if mm_want_ptrs.c1 != nil && !minimock.Equal(*mm_want_ptrs.c1, mm_got.c1) {
				mmOrdersWithGivenClientIDAndAcceptedCondition.t.Errorf("Storage.OrdersWithGivenClientIDAndAcceptedCondition got unexpected parameter c1, want: %#v, got: %#v%s\n", *mm_want_ptrs.c1, mm_got.c1, minimock.Diff(*mm_want_ptrs.c1, mm_got.c1))
			}

			if mm_want_ptrs.hash != nil && !minimock.Equal(*mm_want_ptrs.hash, mm_got.hash) {
				mmOrdersWithGivenClientIDAndAcceptedCondition.t.Errorf("Storage.OrdersWithGivenClientIDAndAcceptedCondition got unexpected parameter hash, want: %#v, got: %#v%s\n", *mm_want_ptrs.hash, mm_got.hash, minimock.Diff(*mm_want_ptrs.hash, mm_got.hash))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrdersWithGivenClientIDAndAcceptedCondition.t.Errorf("Storage.OrdersWithGivenClientIDAndAcceptedCondition got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrdersWithGivenClientIDAndAcceptedCondition.OrdersWithGivenClientIDAndAcceptedConditionMock.defaultExpectation.results
		if mm_results == nil {
			mmOrdersWithGivenClientIDAndAcceptedCondition.t.Fatal("No results are set for the Storage.OrdersWithGivenClientIDAndAcceptedCondition")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmOrdersWithGivenClientIDAndAcceptedCondition.funcOrdersWithGivenClientIDAndAcceptedCondition != nil {
		return mmOrdersWithGivenClientIDAndAcceptedCondition.funcOrdersWithGivenClientIDAndAcceptedCondition(clientID, c1, hash)
	}
	mmOrdersWithGivenClientIDAndAcceptedCondition.t.Fatalf("Unexpected call to Storage.OrdersWithGivenClientIDAndAcceptedCondition. %v %v %v", clientID, c1, hash)
	return
}

// OrdersWithGivenClientIDAndAcceptedConditionAfterCounter returns a count of finished Storage.OrdersWithGivenClientIDAndAcceptedCondition invocations
func (mmOrdersWithGivenClientIDAndAcceptedCondition *Storage) OrdersWithGivenClientIDAndAcceptedConditionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrdersWithGivenClientIDAndAcceptedCondition.afterOrdersWithGivenClientIDAndAcceptedConditionCounter)
}

// OrdersWithGivenClientIDAndAcceptedConditionBeforeCounter returns a count of Storage.OrdersWithGivenClientIDAndAcceptedCondition invocations
func (mmOrdersWithGivenClientIDAndAcceptedCondition *Storage) OrdersWithGivenClientIDAndAcceptedConditionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrdersWithGivenClientIDAndAcceptedCondition.beforeOrdersWithGivenClientIDAndAcceptedConditionCounter)
}

// Calls returns a list of arguments used in each call to Storage.OrdersWithGivenClientIDAndAcceptedCondition.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrdersWithGivenClientIDAndAcceptedCondition *mStorageOrdersWithGivenClientIDAndAcceptedCondition) Calls() []*StorageOrdersWithGivenClientIDAndAcceptedConditionParams {
	mmOrdersWithGivenClientIDAndAcceptedCondition.mutex.RLock()

	argCopy := make([]*StorageOrdersWithGivenClientIDAndAcceptedConditionParams, len(mmOrdersWithGivenClientIDAndAcceptedCondition.callArgs))
	copy(argCopy, mmOrdersWithGivenClientIDAndAcceptedCondition.callArgs)

	mmOrdersWithGivenClientIDAndAcceptedCondition.mutex.RUnlock()

	return argCopy
}

// MinimockOrdersWithGivenClientIDAndAcceptedConditionDone returns true if the count of the OrdersWithGivenClientIDAndAcceptedCondition invocations corresponds
// the number of defined expectations
func (m *Storage) MinimockOrdersWithGivenClientIDAndAcceptedConditionDone() bool {
	if m.OrdersWithGivenClientIDAndAcceptedConditionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrdersWithGivenClientIDAndAcceptedConditionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrdersWithGivenClientIDAndAcceptedConditionMock.invocationsDone()
}

// MinimockOrdersWithGivenClientIDAndAcceptedConditionInspect logs each unmet expectation
func (m *Storage) MinimockOrdersWithGivenClientIDAndAcceptedConditionInspect() {
	for _, e := range m.OrdersWithGivenClientIDAndAcceptedConditionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Storage.OrdersWithGivenClientIDAndAcceptedCondition with params: %#v", *e.params)
		}
	}

	afterOrdersWithGivenClientIDAndAcceptedConditionCounter := mm_atomic.LoadUint64(&m.afterOrdersWithGivenClientIDAndAcceptedConditionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrdersWithGivenClientIDAndAcceptedConditionMock.defaultExpectation != nil && afterOrdersWithGivenClientIDAndAcceptedConditionCounter < 1 {
		if m.OrdersWithGivenClientIDAndAcceptedConditionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Storage.OrdersWithGivenClientIDAndAcceptedCondition")
		} else {
			m.t.Errorf("Expected call to Storage.OrdersWithGivenClientIDAndAcceptedCondition with params: %#v", *m.OrdersWithGivenClientIDAndAcceptedConditionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrdersWithGivenClientIDAndAcceptedCondition != nil && afterOrdersWithGivenClientIDAndAcceptedConditionCounter < 1 {
		m.t.Error("Expected call to Storage.OrdersWithGivenClientIDAndAcceptedCondition")
	}

	if !m.OrdersWithGivenClientIDAndAcceptedConditionMock.invocationsDone() && afterOrdersWithGivenClientIDAndAcceptedConditionCounter > 0 {
		m.t.Errorf("Expected %d calls to Storage.OrdersWithGivenClientIDAndAcceptedCondition but found %d calls",
			mm_atomic.LoadUint64(&m.OrdersWithGivenClientIDAndAcceptedConditionMock.expectedInvocations), afterOrdersWithGivenClientIDAndAcceptedConditionCounter)
	}
}

type mStorageOrdersWithRefundCondition struct {
	optional           bool
	mock               *Storage
	defaultExpectation *StorageOrdersWithRefundConditionExpectation
	expectations       []*StorageOrdersWithRefundConditionExpectation

	callArgs []*StorageOrdersWithRefundConditionParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StorageOrdersWithRefundConditionExpectation specifies expectation struct of the Storage.OrdersWithRefundCondition
type StorageOrdersWithRefundConditionExpectation struct {
	mock      *Storage
	params    *StorageOrdersWithRefundConditionParams
	paramPtrs *StorageOrdersWithRefundConditionParamPtrs
	results   *StorageOrdersWithRefundConditionResults
	Counter   uint64
}

// StorageOrdersWithRefundConditionParams contains parameters of the Storage.OrdersWithRefundCondition
type StorageOrdersWithRefundConditionParams struct {
	ctx  context.Context
	hash string
}

// StorageOrdersWithRefundConditionParamPtrs contains pointers to parameters of the Storage.OrdersWithRefundCondition
type StorageOrdersWithRefundConditionParamPtrs struct {
	ctx  *context.Context
	hash *string
}

// StorageOrdersWithRefundConditionResults contains results of the Storage.OrdersWithRefundCondition
type StorageOrdersWithRefundConditionResults struct {
	oa1 []model.Order
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrdersWithRefundCondition *mStorageOrdersWithRefundCondition) Optional() *mStorageOrdersWithRefundCondition {
	mmOrdersWithRefundCondition.optional = true
	return mmOrdersWithRefundCondition
}

// Expect sets up expected params for Storage.OrdersWithRefundCondition
func (mmOrdersWithRefundCondition *mStorageOrdersWithRefundCondition) Expect(ctx context.Context, hash string) *mStorageOrdersWithRefundCondition {
	if mmOrdersWithRefundCondition.mock.funcOrdersWithRefundCondition != nil {
		mmOrdersWithRefundCondition.mock.t.Fatalf("Storage.OrdersWithRefundCondition mock is already set by Set")
	}

	if mmOrdersWithRefundCondition.defaultExpectation == nil {
		mmOrdersWithRefundCondition.defaultExpectation = &StorageOrdersWithRefundConditionExpectation{}
	}

	if mmOrdersWithRefundCondition.defaultExpectation.paramPtrs != nil {
		mmOrdersWithRefundCondition.mock.t.Fatalf("Storage.OrdersWithRefundCondition mock is already set by ExpectParams functions")
	}

	mmOrdersWithRefundCondition.defaultExpectation.params = &StorageOrdersWithRefundConditionParams{ctx, hash}
	for _, e := range mmOrdersWithRefundCondition.expectations {
		if minimock.Equal(e.params, mmOrdersWithRefundCondition.defaultExpectation.params) {
			mmOrdersWithRefundCondition.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrdersWithRefundCondition.defaultExpectation.params)
		}
	}

	return mmOrdersWithRefundCondition
}

// ExpectCtxParam1 sets up expected param ctx for Storage.OrdersWithRefundCondition
func (mmOrdersWithRefundCondition *mStorageOrdersWithRefundCondition) ExpectCtxParam1(ctx context.Context) *mStorageOrdersWithRefundCondition {
	if mmOrdersWithRefundCondition.mock.funcOrdersWithRefundCondition != nil {
		mmOrdersWithRefundCondition.mock.t.Fatalf("Storage.OrdersWithRefundCondition mock is already set by Set")
	}

	if mmOrdersWithRefundCondition.defaultExpectation == nil {
		mmOrdersWithRefundCondition.defaultExpectation = &StorageOrdersWithRefundConditionExpectation{}
	}

	if mmOrdersWithRefundCondition.defaultExpectation.params != nil {
		mmOrdersWithRefundCondition.mock.t.Fatalf("Storage.OrdersWithRefundCondition mock is already set by Expect")
	}

	if mmOrdersWithRefundCondition.defaultExpectation.paramPtrs == nil {
		mmOrdersWithRefundCondition.defaultExpectation.paramPtrs = &StorageOrdersWithRefundConditionParamPtrs{}
	}
	mmOrdersWithRefundCondition.defaultExpectation.paramPtrs.ctx = &ctx

	return mmOrdersWithRefundCondition
}

// ExpectHashParam2 sets up expected param hash for Storage.OrdersWithRefundCondition
func (mmOrdersWithRefundCondition *mStorageOrdersWithRefundCondition) ExpectHashParam2(hash string) *mStorageOrdersWithRefundCondition {
	if mmOrdersWithRefundCondition.mock.funcOrdersWithRefundCondition != nil {
		mmOrdersWithRefundCondition.mock.t.Fatalf("Storage.OrdersWithRefundCondition mock is already set by Set")
	}

	if mmOrdersWithRefundCondition.defaultExpectation == nil {
		mmOrdersWithRefundCondition.defaultExpectation = &StorageOrdersWithRefundConditionExpectation{}
	}

	if mmOrdersWithRefundCondition.defaultExpectation.params != nil {
		mmOrdersWithRefundCondition.mock.t.Fatalf("Storage.OrdersWithRefundCondition mock is already set by Expect")
	}

	if mmOrdersWithRefundCondition.defaultExpectation.paramPtrs == nil {
		mmOrdersWithRefundCondition.defaultExpectation.paramPtrs = &StorageOrdersWithRefundConditionParamPtrs{}
	}
	mmOrdersWithRefundCondition.defaultExpectation.paramPtrs.hash = &hash

	return mmOrdersWithRefundCondition
}

// Inspect accepts an inspector function that has same arguments as the Storage.OrdersWithRefundCondition
func (mmOrdersWithRefundCondition *mStorageOrdersWithRefundCondition) Inspect(f func(ctx context.Context, hash string)) *mStorageOrdersWithRefundCondition {
	if mmOrdersWithRefundCondition.mock.inspectFuncOrdersWithRefundCondition != nil {
		mmOrdersWithRefundCondition.mock.t.Fatalf("Inspect function is already set for Storage.OrdersWithRefundCondition")
	}

	mmOrdersWithRefundCondition.mock.inspectFuncOrdersWithRefundCondition = f

	return mmOrdersWithRefundCondition
}

// Return sets up results that will be returned by Storage.OrdersWithRefundCondition
func (mmOrdersWithRefundCondition *mStorageOrdersWithRefundCondition) Return(oa1 []model.Order, err error) *Storage {
	if mmOrdersWithRefundCondition.mock.funcOrdersWithRefundCondition != nil {
		mmOrdersWithRefundCondition.mock.t.Fatalf("Storage.OrdersWithRefundCondition mock is already set by Set")
	}

	if mmOrdersWithRefundCondition.defaultExpectation == nil {
		mmOrdersWithRefundCondition.defaultExpectation = &StorageOrdersWithRefundConditionExpectation{mock: mmOrdersWithRefundCondition.mock}
	}
	mmOrdersWithRefundCondition.defaultExpectation.results = &StorageOrdersWithRefundConditionResults{oa1, err}
	return mmOrdersWithRefundCondition.mock
}

// Set uses given function f to mock the Storage.OrdersWithRefundCondition method
func (mmOrdersWithRefundCondition *mStorageOrdersWithRefundCondition) Set(f func(ctx context.Context, hash string) (oa1 []model.Order, err error)) *Storage {
	if mmOrdersWithRefundCondition.defaultExpectation != nil {
		mmOrdersWithRefundCondition.mock.t.Fatalf("Default expectation is already set for the Storage.OrdersWithRefundCondition method")
	}

	if len(mmOrdersWithRefundCondition.expectations) > 0 {
		mmOrdersWithRefundCondition.mock.t.Fatalf("Some expectations are already set for the Storage.OrdersWithRefundCondition method")
	}

	mmOrdersWithRefundCondition.mock.funcOrdersWithRefundCondition = f
	return mmOrdersWithRefundCondition.mock
}

// When sets expectation for the Storage.OrdersWithRefundCondition which will trigger the result defined by the following
// Then helper
func (mmOrdersWithRefundCondition *mStorageOrdersWithRefundCondition) When(ctx context.Context, hash string) *StorageOrdersWithRefundConditionExpectation {
	if mmOrdersWithRefundCondition.mock.funcOrdersWithRefundCondition != nil {
		mmOrdersWithRefundCondition.mock.t.Fatalf("Storage.OrdersWithRefundCondition mock is already set by Set")
	}

	expectation := &StorageOrdersWithRefundConditionExpectation{
		mock:   mmOrdersWithRefundCondition.mock,
		params: &StorageOrdersWithRefundConditionParams{ctx, hash},
	}
	mmOrdersWithRefundCondition.expectations = append(mmOrdersWithRefundCondition.expectations, expectation)
	return expectation
}

// Then sets up Storage.OrdersWithRefundCondition return parameters for the expectation previously defined by the When method
func (e *StorageOrdersWithRefundConditionExpectation) Then(oa1 []model.Order, err error) *Storage {
	e.results = &StorageOrdersWithRefundConditionResults{oa1, err}
	return e.mock
}

// Times sets number of times Storage.OrdersWithRefundCondition should be invoked
func (mmOrdersWithRefundCondition *mStorageOrdersWithRefundCondition) Times(n uint64) *mStorageOrdersWithRefundCondition {
	if n == 0 {
		mmOrdersWithRefundCondition.mock.t.Fatalf("Times of Storage.OrdersWithRefundCondition mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrdersWithRefundCondition.expectedInvocations, n)
	return mmOrdersWithRefundCondition
}

func (mmOrdersWithRefundCondition *mStorageOrdersWithRefundCondition) invocationsDone() bool {
	if len(mmOrdersWithRefundCondition.expectations) == 0 && mmOrdersWithRefundCondition.defaultExpectation == nil && mmOrdersWithRefundCondition.mock.funcOrdersWithRefundCondition == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrdersWithRefundCondition.mock.afterOrdersWithRefundConditionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrdersWithRefundCondition.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrdersWithRefundCondition implements module.Storage
func (mmOrdersWithRefundCondition *Storage) OrdersWithRefundCondition(ctx context.Context, hash string) (oa1 []model.Order, err error) {
	mm_atomic.AddUint64(&mmOrdersWithRefundCondition.beforeOrdersWithRefundConditionCounter, 1)
	defer mm_atomic.AddUint64(&mmOrdersWithRefundCondition.afterOrdersWithRefundConditionCounter, 1)

	if mmOrdersWithRefundCondition.inspectFuncOrdersWithRefundCondition != nil {
		mmOrdersWithRefundCondition.inspectFuncOrdersWithRefundCondition(ctx, hash)
	}

	mm_params := StorageOrdersWithRefundConditionParams{ctx, hash}

	// Record call args
	mmOrdersWithRefundCondition.OrdersWithRefundConditionMock.mutex.Lock()
	mmOrdersWithRefundCondition.OrdersWithRefundConditionMock.callArgs = append(mmOrdersWithRefundCondition.OrdersWithRefundConditionMock.callArgs, &mm_params)
	mmOrdersWithRefundCondition.OrdersWithRefundConditionMock.mutex.Unlock()

	for _, e := range mmOrdersWithRefundCondition.OrdersWithRefundConditionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmOrdersWithRefundCondition.OrdersWithRefundConditionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrdersWithRefundCondition.OrdersWithRefundConditionMock.defaultExpectation.Counter, 1)
		mm_want := mmOrdersWithRefundCondition.OrdersWithRefundConditionMock.defaultExpectation.params
		mm_want_ptrs := mmOrdersWithRefundCondition.OrdersWithRefundConditionMock.defaultExpectation.paramPtrs

		mm_got := StorageOrdersWithRefundConditionParams{ctx, hash}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrdersWithRefundCondition.t.Errorf("Storage.OrdersWithRefundCondition got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.hash != nil && !minimock.Equal(*mm_want_ptrs.hash, mm_got.hash) {
				mmOrdersWithRefundCondition.t.Errorf("Storage.OrdersWithRefundCondition got unexpected parameter hash, want: %#v, got: %#v%s\n", *mm_want_ptrs.hash, mm_got.hash, minimock.Diff(*mm_want_ptrs.hash, mm_got.hash))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrdersWithRefundCondition.t.Errorf("Storage.OrdersWithRefundCondition got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrdersWithRefundCondition.OrdersWithRefundConditionMock.defaultExpectation.results
		if mm_results == nil {
			mmOrdersWithRefundCondition.t.Fatal("No results are set for the Storage.OrdersWithRefundCondition")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmOrdersWithRefundCondition.funcOrdersWithRefundCondition != nil {
		return mmOrdersWithRefundCondition.funcOrdersWithRefundCondition(ctx, hash)
	}
	mmOrdersWithRefundCondition.t.Fatalf("Unexpected call to Storage.OrdersWithRefundCondition. %v %v", ctx, hash)
	return
}

// OrdersWithRefundConditionAfterCounter returns a count of finished Storage.OrdersWithRefundCondition invocations
func (mmOrdersWithRefundCondition *Storage) OrdersWithRefundConditionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrdersWithRefundCondition.afterOrdersWithRefundConditionCounter)
}

// OrdersWithRefundConditionBeforeCounter returns a count of Storage.OrdersWithRefundCondition invocations
func (mmOrdersWithRefundCondition *Storage) OrdersWithRefundConditionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrdersWithRefundCondition.beforeOrdersWithRefundConditionCounter)
}

// Calls returns a list of arguments used in each call to Storage.OrdersWithRefundCondition.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrdersWithRefundCondition *mStorageOrdersWithRefundCondition) Calls() []*StorageOrdersWithRefundConditionParams {
	mmOrdersWithRefundCondition.mutex.RLock()

	argCopy := make([]*StorageOrdersWithRefundConditionParams, len(mmOrdersWithRefundCondition.callArgs))
	copy(argCopy, mmOrdersWithRefundCondition.callArgs)

	mmOrdersWithRefundCondition.mutex.RUnlock()

	return argCopy
}

// MinimockOrdersWithRefundConditionDone returns true if the count of the OrdersWithRefundCondition invocations corresponds
// the number of defined expectations
func (m *Storage) MinimockOrdersWithRefundConditionDone() bool {
	if m.OrdersWithRefundConditionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrdersWithRefundConditionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrdersWithRefundConditionMock.invocationsDone()
}

// MinimockOrdersWithRefundConditionInspect logs each unmet expectation
func (m *Storage) MinimockOrdersWithRefundConditionInspect() {
	for _, e := range m.OrdersWithRefundConditionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Storage.OrdersWithRefundCondition with params: %#v", *e.params)
		}
	}

	afterOrdersWithRefundConditionCounter := mm_atomic.LoadUint64(&m.afterOrdersWithRefundConditionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrdersWithRefundConditionMock.defaultExpectation != nil && afterOrdersWithRefundConditionCounter < 1 {
		if m.OrdersWithRefundConditionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Storage.OrdersWithRefundCondition")
		} else {
			m.t.Errorf("Expected call to Storage.OrdersWithRefundCondition with params: %#v", *m.OrdersWithRefundConditionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrdersWithRefundCondition != nil && afterOrdersWithRefundConditionCounter < 1 {
		m.t.Error("Expected call to Storage.OrdersWithRefundCondition")
	}

	if !m.OrdersWithRefundConditionMock.invocationsDone() && afterOrdersWithRefundConditionCounter > 0 {
		m.t.Errorf("Expected %d calls to Storage.OrdersWithRefundCondition but found %d calls",
			mm_atomic.LoadUint64(&m.OrdersWithRefundConditionMock.expectedInvocations), afterOrdersWithRefundConditionCounter)
	}
}

type mStorageUpdateOrders struct {
	optional           bool
	mock               *Storage
	defaultExpectation *StorageUpdateOrdersExpectation
	expectations       []*StorageUpdateOrdersExpectation

	callArgs []*StorageUpdateOrdersParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StorageUpdateOrdersExpectation specifies expectation struct of the Storage.UpdateOrders
type StorageUpdateOrdersExpectation struct {
	mock      *Storage
	params    *StorageUpdateOrdersParams
	paramPtrs *StorageUpdateOrdersParamPtrs
	results   *StorageUpdateOrdersResults
	Counter   uint64
}

// StorageUpdateOrdersParams contains parameters of the Storage.UpdateOrders
type StorageUpdateOrdersParams struct {
	ctx    context.Context
	orders []model.Order
	hash   string
}

// StorageUpdateOrdersParamPtrs contains pointers to parameters of the Storage.UpdateOrders
type StorageUpdateOrdersParamPtrs struct {
	ctx    *context.Context
	orders *[]model.Order
	hash   *string
}

// StorageUpdateOrdersResults contains results of the Storage.UpdateOrders
type StorageUpdateOrdersResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateOrders *mStorageUpdateOrders) Optional() *mStorageUpdateOrders {
	mmUpdateOrders.optional = true
	return mmUpdateOrders
}

// Expect sets up expected params for Storage.UpdateOrders
func (mmUpdateOrders *mStorageUpdateOrders) Expect(ctx context.Context, orders []model.Order, hash string) *mStorageUpdateOrders {
	if mmUpdateOrders.mock.funcUpdateOrders != nil {
		mmUpdateOrders.mock.t.Fatalf("Storage.UpdateOrders mock is already set by Set")
	}

	if mmUpdateOrders.defaultExpectation == nil {
		mmUpdateOrders.defaultExpectation = &StorageUpdateOrdersExpectation{}
	}

	if mmUpdateOrders.defaultExpectation.paramPtrs != nil {
		mmUpdateOrders.mock.t.Fatalf("Storage.UpdateOrders mock is already set by ExpectParams functions")
	}

	mmUpdateOrders.defaultExpectation.params = &StorageUpdateOrdersParams{ctx, orders, hash}
	for _, e := range mmUpdateOrders.expectations {
		if minimock.Equal(e.params, mmUpdateOrders.defaultExpectation.params) {
			mmUpdateOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrders.defaultExpectation.params)
		}
	}

	return mmUpdateOrders
}

// ExpectCtxParam1 sets up expected param ctx for Storage.UpdateOrders
func (mmUpdateOrders *mStorageUpdateOrders) ExpectCtxParam1(ctx context.Context) *mStorageUpdateOrders {
	if mmUpdateOrders.mock.funcUpdateOrders != nil {
		mmUpdateOrders.mock.t.Fatalf("Storage.UpdateOrders mock is already set by Set")
	}

	if mmUpdateOrders.defaultExpectation == nil {
		mmUpdateOrders.defaultExpectation = &StorageUpdateOrdersExpectation{}
	}

	if mmUpdateOrders.defaultExpectation.params != nil {
		mmUpdateOrders.mock.t.Fatalf("Storage.UpdateOrders mock is already set by Expect")
	}

	if mmUpdateOrders.defaultExpectation.paramPtrs == nil {
		mmUpdateOrders.defaultExpectation.paramPtrs = &StorageUpdateOrdersParamPtrs{}
	}
	mmUpdateOrders.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateOrders
}

// ExpectOrdersParam2 sets up expected param orders for Storage.UpdateOrders
func (mmUpdateOrders *mStorageUpdateOrders) ExpectOrdersParam2(orders []model.Order) *mStorageUpdateOrders {
	if mmUpdateOrders.mock.funcUpdateOrders != nil {
		mmUpdateOrders.mock.t.Fatalf("Storage.UpdateOrders mock is already set by Set")
	}

	if mmUpdateOrders.defaultExpectation == nil {
		mmUpdateOrders.defaultExpectation = &StorageUpdateOrdersExpectation{}
	}

	if mmUpdateOrders.defaultExpectation.params != nil {
		mmUpdateOrders.mock.t.Fatalf("Storage.UpdateOrders mock is already set by Expect")
	}

	if mmUpdateOrders.defaultExpectation.paramPtrs == nil {
		mmUpdateOrders.defaultExpectation.paramPtrs = &StorageUpdateOrdersParamPtrs{}
	}
	mmUpdateOrders.defaultExpectation.paramPtrs.orders = &orders

	return mmUpdateOrders
}

// ExpectHashParam3 sets up expected param hash for Storage.UpdateOrders
func (mmUpdateOrders *mStorageUpdateOrders) ExpectHashParam3(hash string) *mStorageUpdateOrders {
	if mmUpdateOrders.mock.funcUpdateOrders != nil {
		mmUpdateOrders.mock.t.Fatalf("Storage.UpdateOrders mock is already set by Set")
	}

	if mmUpdateOrders.defaultExpectation == nil {
		mmUpdateOrders.defaultExpectation = &StorageUpdateOrdersExpectation{}
	}

	if mmUpdateOrders.defaultExpectation.params != nil {
		mmUpdateOrders.mock.t.Fatalf("Storage.UpdateOrders mock is already set by Expect")
	}

	if mmUpdateOrders.defaultExpectation.paramPtrs == nil {
		mmUpdateOrders.defaultExpectation.paramPtrs = &StorageUpdateOrdersParamPtrs{}
	}
	mmUpdateOrders.defaultExpectation.paramPtrs.hash = &hash

	return mmUpdateOrders
}

// Inspect accepts an inspector function that has same arguments as the Storage.UpdateOrders
func (mmUpdateOrders *mStorageUpdateOrders) Inspect(f func(ctx context.Context, orders []model.Order, hash string)) *mStorageUpdateOrders {
	if mmUpdateOrders.mock.inspectFuncUpdateOrders != nil {
		mmUpdateOrders.mock.t.Fatalf("Inspect function is already set for Storage.UpdateOrders")
	}

	mmUpdateOrders.mock.inspectFuncUpdateOrders = f

	return mmUpdateOrders
}

// Return sets up results that will be returned by Storage.UpdateOrders
func (mmUpdateOrders *mStorageUpdateOrders) Return(err error) *Storage {
	if mmUpdateOrders.mock.funcUpdateOrders != nil {
		mmUpdateOrders.mock.t.Fatalf("Storage.UpdateOrders mock is already set by Set")
	}

	if mmUpdateOrders.defaultExpectation == nil {
		mmUpdateOrders.defaultExpectation = &StorageUpdateOrdersExpectation{mock: mmUpdateOrders.mock}
	}
	mmUpdateOrders.defaultExpectation.results = &StorageUpdateOrdersResults{err}
	return mmUpdateOrders.mock
}

// Set uses given function f to mock the Storage.UpdateOrders method
func (mmUpdateOrders *mStorageUpdateOrders) Set(f func(ctx context.Context, orders []model.Order, hash string) (err error)) *Storage {
	if mmUpdateOrders.defaultExpectation != nil {
		mmUpdateOrders.mock.t.Fatalf("Default expectation is already set for the Storage.UpdateOrders method")
	}

	if len(mmUpdateOrders.expectations) > 0 {
		mmUpdateOrders.mock.t.Fatalf("Some expectations are already set for the Storage.UpdateOrders method")
	}

	mmUpdateOrders.mock.funcUpdateOrders = f
	return mmUpdateOrders.mock
}

// When sets expectation for the Storage.UpdateOrders which will trigger the result defined by the following
// Then helper
func (mmUpdateOrders *mStorageUpdateOrders) When(ctx context.Context, orders []model.Order, hash string) *StorageUpdateOrdersExpectation {
	if mmUpdateOrders.mock.funcUpdateOrders != nil {
		mmUpdateOrders.mock.t.Fatalf("Storage.UpdateOrders mock is already set by Set")
	}

	expectation := &StorageUpdateOrdersExpectation{
		mock:   mmUpdateOrders.mock,
		params: &StorageUpdateOrdersParams{ctx, orders, hash},
	}
	mmUpdateOrders.expectations = append(mmUpdateOrders.expectations, expectation)
	return expectation
}

// Then sets up Storage.UpdateOrders return parameters for the expectation previously defined by the When method
func (e *StorageUpdateOrdersExpectation) Then(err error) *Storage {
	e.results = &StorageUpdateOrdersResults{err}
	return e.mock
}

// Times sets number of times Storage.UpdateOrders should be invoked
func (mmUpdateOrders *mStorageUpdateOrders) Times(n uint64) *mStorageUpdateOrders {
	if n == 0 {
		mmUpdateOrders.mock.t.Fatalf("Times of Storage.UpdateOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateOrders.expectedInvocations, n)
	return mmUpdateOrders
}

func (mmUpdateOrders *mStorageUpdateOrders) invocationsDone() bool {
	if len(mmUpdateOrders.expectations) == 0 && mmUpdateOrders.defaultExpectation == nil && mmUpdateOrders.mock.funcUpdateOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateOrders.mock.afterUpdateOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateOrders implements module.Storage
func (mmUpdateOrders *Storage) UpdateOrders(ctx context.Context, orders []model.Order, hash string) (err error) {
	mm_atomic.AddUint64(&mmUpdateOrders.beforeUpdateOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrders.afterUpdateOrdersCounter, 1)

	if mmUpdateOrders.inspectFuncUpdateOrders != nil {
		mmUpdateOrders.inspectFuncUpdateOrders(ctx, orders, hash)
	}

	mm_params := StorageUpdateOrdersParams{ctx, orders, hash}

	// Record call args
	mmUpdateOrders.UpdateOrdersMock.mutex.Lock()
	mmUpdateOrders.UpdateOrdersMock.callArgs = append(mmUpdateOrders.UpdateOrdersMock.callArgs, &mm_params)
	mmUpdateOrders.UpdateOrdersMock.mutex.Unlock()

	for _, e := range mmUpdateOrders.UpdateOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateOrders.UpdateOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrders.UpdateOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrders.UpdateOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateOrders.UpdateOrdersMock.defaultExpectation.paramPtrs

		mm_got := StorageUpdateOrdersParams{ctx, orders, hash}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateOrders.t.Errorf("Storage.UpdateOrders got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orders != nil && !minimock.Equal(*mm_want_ptrs.orders, mm_got.orders) {
				mmUpdateOrders.t.Errorf("Storage.UpdateOrders got unexpected parameter orders, want: %#v, got: %#v%s\n", *mm_want_ptrs.orders, mm_got.orders, minimock.Diff(*mm_want_ptrs.orders, mm_got.orders))
			}

			if mm_want_ptrs.hash != nil && !minimock.Equal(*mm_want_ptrs.hash, mm_got.hash) {
				mmUpdateOrders.t.Errorf("Storage.UpdateOrders got unexpected parameter hash, want: %#v, got: %#v%s\n", *mm_want_ptrs.hash, mm_got.hash, minimock.Diff(*mm_want_ptrs.hash, mm_got.hash))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrders.t.Errorf("Storage.UpdateOrders got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrders.UpdateOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrders.t.Fatal("No results are set for the Storage.UpdateOrders")
		}
		return (*mm_results).err
	}
	if mmUpdateOrders.funcUpdateOrders != nil {
		return mmUpdateOrders.funcUpdateOrders(ctx, orders, hash)
	}
	mmUpdateOrders.t.Fatalf("Unexpected call to Storage.UpdateOrders. %v %v %v", ctx, orders, hash)
	return
}

// UpdateOrdersAfterCounter returns a count of finished Storage.UpdateOrders invocations
func (mmUpdateOrders *Storage) UpdateOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrders.afterUpdateOrdersCounter)
}

// UpdateOrdersBeforeCounter returns a count of Storage.UpdateOrders invocations
func (mmUpdateOrders *Storage) UpdateOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrders.beforeUpdateOrdersCounter)
}

// Calls returns a list of arguments used in each call to Storage.UpdateOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrders *mStorageUpdateOrders) Calls() []*StorageUpdateOrdersParams {
	mmUpdateOrders.mutex.RLock()

	argCopy := make([]*StorageUpdateOrdersParams, len(mmUpdateOrders.callArgs))
	copy(argCopy, mmUpdateOrders.callArgs)

	mmUpdateOrders.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrdersDone returns true if the count of the UpdateOrders invocations corresponds
// the number of defined expectations
func (m *Storage) MinimockUpdateOrdersDone() bool {
	if m.UpdateOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateOrdersMock.invocationsDone()
}

// MinimockUpdateOrdersInspect logs each unmet expectation
func (m *Storage) MinimockUpdateOrdersInspect() {
	for _, e := range m.UpdateOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to Storage.UpdateOrders with params: %#v", *e.params)
		}
	}

	afterUpdateOrdersCounter := mm_atomic.LoadUint64(&m.afterUpdateOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrdersMock.defaultExpectation != nil && afterUpdateOrdersCounter < 1 {
		if m.UpdateOrdersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to Storage.UpdateOrders")
		} else {
			m.t.Errorf("Expected call to Storage.UpdateOrders with params: %#v", *m.UpdateOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrders != nil && afterUpdateOrdersCounter < 1 {
		m.t.Error("Expected call to Storage.UpdateOrders")
	}

	if !m.UpdateOrdersMock.invocationsDone() && afterUpdateOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to Storage.UpdateOrders but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateOrdersMock.expectedInvocations), afterUpdateOrdersCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *Storage) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAppendOrderInspect()

			m.MinimockDeleteOrderInspect()

			m.MinimockLoadOrdersInspect()

			m.MinimockLoadPackByTypeInspect()

			m.MinimockLoadPackagesInspect()

			m.MinimockOrderByClientIDOrderIDInspect()

			m.MinimockOrderByIDInspect()

			m.MinimockOrdersByGivenOrderIDListInspect()

			m.MinimockOrdersWithGivenClientIDInspect()

			m.MinimockOrdersWithGivenClientIDAndAcceptedConditionInspect()

			m.MinimockOrdersWithRefundConditionInspect()

			m.MinimockUpdateOrdersInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *Storage) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *Storage) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAppendOrderDone() &&
		m.MinimockDeleteOrderDone() &&
		m.MinimockLoadOrdersDone() &&
		m.MinimockLoadPackByTypeDone() &&
		m.MinimockLoadPackagesDone() &&
		m.MinimockOrderByClientIDOrderIDDone() &&
		m.MinimockOrderByIDDone() &&
		m.MinimockOrdersByGivenOrderIDListDone() &&
		m.MinimockOrdersWithGivenClientIDDone() &&
		m.MinimockOrdersWithGivenClientIDAndAcceptedConditionDone() &&
		m.MinimockOrdersWithRefundConditionDone() &&
		m.MinimockUpdateOrdersDone()
}
